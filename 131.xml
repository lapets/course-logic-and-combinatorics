<material title="Logic and Combinatorics">
  <section title="Introduction, Background, and Motivation">
    <subsection title="Overview">
      <paragraph><![CDATA[
The physical laws in our universe appear to be predictable (i.e., they are consistent across time and space, and under similar circumstances, we can expect matter and energy to behave in similar ways). We can exploit this to make models and predictions about how events might unfold at a certain time and place in the universe, and we can test these predictions (we might call this the <i>scientific method</i>).
      ]]></paragraph>
      <paragraph><![CDATA[
We can also exploit the predictability of physical laws by identifying what conditions match a particular goal we may wan to bring about, or task that we may want to accomplish, and then setting up initial conditions (such as inside a mechanical, electronic, chemical, biological, and/or computational device) that will eventually lead to those circumstances.
      ]]></paragraph>
      <paragraph><![CDATA[
Many physical processes that currently understand and use to accomplish our tasks are based on only a small collection of building blocks (typically, these are collections of rules that are consistently followed by systems). Just as humans have developed symbolic systems (i.e., natural languages such as English) to name, describe, and think about day-to-day objects and processes in their environment, communities of people within the mathematics, applied mathematics, computer science, and related disciplines have developed symbolic systems for describing the simple building blocks according to which phenomena in our physical environment (including everything from mechanical devices, to physical computers, to software) seem to operate.      
      ]]></paragraph>
      <paragraph><![CDATA[
In this course, we will study a particular mathematical language that is well-suited for describing certain structures (as well as their properties and behaviors) that are routinely and widely employed within mathematical and computational modelling, data representation and storage, data processing, and other software applications. These structures include logical formulas, proofs, sets, trees, and graphs. We will also study the combinatorial properties of these structures, including how to define them recursively, how to quantify and compute their size, as well as how to categorize, count, and measure the ways in which they can be constructed, combined, and explored. We will become familiar with induction and recursive and self-referential definitions for these structures and their properties. We will also look at how these structures and associated techniques can be used in some practical applications.
      ]]></paragraph>
    </subsection>
    <subsection title="Expected background, prerequisites, and course format">
      <paragraph hooks="math"><![CDATA[
In covering the material for this course, we will use the standard language and conventions for discussing mathematical structures that have been developed by the mathematics and computer science communities. You should be familiar with high school level algebra and calculus (including mathematical functions of a single variable, e.g., %f(%x) = %x^2). We will introduce the terminology and concepts associated with boolean arithmetic, logic, set theory, graph theory, and combinatorics as part of the course material, but you should have some familiarity with logical operators (i.e., "and", "or", and "not"), at least within the context of a programming language, and the mathematical notion of an abstract set that contains zero or more elements.
       ]]></paragraph>
      <paragraph><![CDATA[
The homework assignments in this course will involve the assembly of programs in the Python programming language, as well as the manual assembly of solutions to mathematical problems. A basic familiarity with programming is expected, but no previous knowledge of the Python programming language is expected. Relevant features of the Python programming language will be introduced as needed within the course material.
       ]]></paragraph>
     </subsection>
  </section>
  <section title="Boolean Arithmetic, Boolean Algebra, and Logical Formulas">
    <paragraph><![CDATA[
In this section, we will introduce the fundamental building blocks of boolean arithmetic and logic, including the symbolic language used to represent logical formulas and proofs. Simultaneously, we will employ the modern programming language Python, together with some specialized libraries, to assemble and work with logical formulas and proofs.
    ]]></paragraph>
    <paragraph><![CDATA[
As with most human languages that have developed organically over time, mathematics has a rich and often redundant vocabulary. We introduce terminology in this section that we will use consistently in this course. However, keep in mind that there are often other synonyms within mathematics and computer science for the concepts we encounter.
    ]]></paragraph>
    <paragraph><![CDATA[
Those who may wish to review and practice the material in this section in the form of a board game <a href="http://boardgamegeek.com/boardgame/5663/wff-n-proof">can be accommodated</a>.
    ]]></paragraph>
    <subsection title="Boolean formulas and boolean arithmetic">
      <definition required="true" hooks="math" id="47254608df414ace8d04c630a2b15689"><![CDATA[
A <i>boolean formula</i> or <i>formula</i> is a string of symbols that follow a certain syntax. If the formula is written using a correct syntax, we say it is a <i>well-formed</i> formula (or <i>WFF</i>). The symbols \vee (which represents the binary <i>or</i> operation, also called <i>disjunction</i>), \wedge (which represents the binary <i>and</i> operation, also called <i>conjunction</i>) , \neg (which represents the <i>not</i> operation, also called <i>negation</i>), \Rightarrow (which represents the <i>implies</i> relationship), and \Leftrightarrow (which represents the <i>if and only if</i> or <i>iff</i> relationship) are <i>boolean operators</i>.
<br/>
<table class="fig_table">
 <tr>
  <td><b>boolean formula</b></td>
  <td><b>conditions</b></td>
 </tr>
 <tr>
  <td>\top</td>
  <td>always a well-formed formula</td>
 </tr>
 <tr> 
  <td>\bot</td>
  <td>always a well-formed formula</td>
  </td>
 </tr>
 <tr> 
  <td>%f_1 \vee %f_2</td>
  <td>is a formula if %f_1 and %f_2 are both well-formed formulas</td>
 </tr>
 <tr> 
  <td>%f_1 \wedge %f_2</td>
  <td>is a formula if %f_1 and %f_2 are both well-formed formulas</td>
 </tr>
 <tr> 
  <td>\neg %f</td>
  <td>is a formula if %f is a well-formed formula</td>
 </tr>
 <tr> 
  <td>%f_1 \oplus %f_2</td>
  <td>is a formula if %f_1 and %f_2 are both well-formed formulas</td>
 </tr>
 <tr>
  <td>%f_1 \Rightarrow %f_2</td>
  <td>is a formula if %f_1 and %f_2 are both well-formed formulas</td>
 </tr>
 <tr> 
  <td>%f_1 \Leftrightarrow %f_2</td>
  <td>is a formula if %f_1 and %f_2 are both well-formed formulas</td>
 </tr>
 <tr> 
  <td>( %f )</td>
  <td>is a formula if %f is a well-formed formula</td>
 </tr>
</table>
      ]]></definition>
      <paragraph hooks="math"><![CDATA[
Notice that we can "build up" formulas from the basic building blocks \top, \bot, and by combining existing formulas using the operators \vee, \wedge, \neg, \oplus, \Rightarrow, and \Leftrightarrow. We can say that formulas are defined in a self-referential way, or <b><i>inductively</i></b>, because a formula is built up of other, smaller formulas. We will introduce a more formal definition of induction later, but it is accurate to say that the definition for well-formed formulas is <i>inductive</i>.
      ]]></paragraph>
      <paragraph><![CDATA[
In the same way that we can assign meaning to sequences of symbols such as "sky", "tree", or "the girl threw the frisbee" by pointing to the physical objects and events they represent, we can assign meaning to each sequence of symbols that happens to be a well-formed formula. 
      ]]></paragraph>
      <definition required="true" hooks="math" id="3bd4848251cb47c98a603e19d5beea64"><![CDATA[
There are only two possible meanings for a well-formed formula: <i>true</i> and <i>false</i>. The following table specifies how we can determine the meaning of a given well-formed formula.
<br/>
<table class="fig_table">
 <tr>
  <td><b>boolean<br/>formula</b></td>
  <td><b>meaning<br/>(true or false)</b></td>
  <td><b>example using the representation<br/>of the Python programming language</b></td>
 </tr>
 <tr> 
  <td>\top</td>
  <td>always true</td>
  <td><code>True</code></td>
 </tr>
 <tr> 
  <td>\bot</td>
  <td>always false</td>
  <td><code>False</code>
  </td>
 </tr>
 <tr> 
  <td>%f_1 \vee %f_2</td>
  <td>true if %f_1 or %f_2 (or both) are true</td>
  <td><code>True or (False and True)</code></td>
 </tr>
 <tr> 
  <td>%f_1 \wedge %f_2</td>
  <td>only true if both %f_1 and %f_2 are true</td>
  <td><code>True and False</code></td>
 </tr>
 <tr> 
  <td>\neg %f</td>
  <td>true if %f is false</td>
  <td><code>not (True or (False and True))</code></td>
 </tr>
 <tr> 
  <td>%f_1 \oplus %f_2</td>
  <td>true if %f_1 or %f_2,<br/>but not both, are true</td>
  <td><code>True != False</code></td>
 </tr>
 <tr>
  <td>%f_1 \Rightarrow %f_2</td>
  <td>
    <ul style="margin-left:-22px;">
      <li>if %f_1 is true, then %f_2 must be true</li>
      <li>%f_1 is false, or %f_2 is true</li>
      <li>%f_1 is "less than or equal to" %f_2<br/>(if \bot is 0 and \top is 1)</li>
    </ul>
  </td>
  <td><code>True <= False</code></td>
 </tr>
 <tr> 
  <td>%f_1 \Leftrightarrow %f_2</td>
  <td>
    <ul style="margin-left:-22px;">
      <li>%f_1 is true if and only if %f_2 is true</li>
      <li>%f_1 and %f_2 are either<br/>both true or both false</li>
    </ul>
  </td>
  <td><code>True == False</code></td>
 </tr>
 <tr> 
  <td>( %f )</td>
  <td>true if %f is true</td>
  <td><code>(True and False)</code></td>
 </tr>
</table>
      ]]></definition>
      <paragraph><![CDATA[
Notice that like the definition of well-formed formulas, the process for assigning a meaning to a formula is self-referential, or <b><i>recursive</i></b>: to determine the meaning of a formula, we determine the meanings of the smaller formulas from which is it built and combine the results. We will introduce a more formal definition of recursion later, but it is accurate to say that the process of assigning a meaning to a formula is <i>recursive</i>.
      ]]></paragraph>
      <definition required="true" hooks="math" id="46859e4a64eb47eba16fd09822382e83"><![CDATA[
The process of converting a well-formed formula to its meaning is often called <i>evaluation</i> (especially within the context of a programming language), because the sequence of symbols that comprises the formula is converted into one of two possible values: <i>true</i> or <i>false</i>.
      ]]></definition>
      <paragraph><![CDATA[
It is worth noting that the terms <i>inductive</i> and <i>recursive</i> are often used interchangeably to refer to self-referential definitions, whether the definitions specify a method for "building up" a self-referential structure, or an algorithm for "breaking down" a self-referential structure.
      ]]></paragraph>
      <example required="true" hooks="math" id="cdf2df96b7924749a37bcbc2f4415180"><![CDATA[
We can determine the meaning of a formula by working our way up from the innermost subformulas, replacing each subformula with its meaning. This process is guaranteed to terminate and produce the meaning of the formula. For example:
\begin{eqnarray}
 (\neg \bot) & \oplus & (\top \vee (\bot \Rightarrow \top)) \\
 <b style="color:firebrick;">\top</b> & \oplus & (\top \vee (\bot \Rightarrow \top)) \\
 \top & \oplus & (\top \vee <b style="color:firebrick;">\top</b>) \\
 \top & \oplus & <b style="color:firebrick;">\top</b> \\
     <b style="color:firebrick;">\bot</b> & %~ & \\
\end{eqnarray}
      ]]></example>
      <example required="true" hooks="math" id="06bf17302b314e80837ad892aca57106"><![CDATA[
For each of the following formulas, determine its meaning.
<ol style="list-style-type:lower-alpha; margin-left:-12px;">
  <li>
\top \vee \bot
  </li>
  <li>
\top \wedge \top \wedge \top
  </li>
  <li>
\top \oplus \top
  </li>
  <li>
\bot
  </li>
  <li>
(\top \Rightarrow \top) \wedge (\bot \Rightarrow \top)
  </li>
  <li>
(\top \vee \bot) \Leftrightarrow \top
  </li>
  <li>
(\top \vee \bot) \Leftrightarrow (\top \oplus \top)
  </li>
  <li>
\top \wedge (\neg \top)
  </li>
</ol>
      ]]></example>
    </subsection>
    <subsection title="Boolean algebra">
      <paragraph hooks="math"><![CDATA[
Algebra of the integers and real numbers is often introduced as a method for solving equations with one or more unknown variables (in fact, this was historically the <a href="http://en.wikipedia.org/wiki/The_Compendious_Book_on_Calculation_by_Completion_and_Balancing">purpose</a> for which some of the techniques we now call algebra were developed). Equations are either true or false; they are, in fact, formulas. Solving an equation over the integers, such as the one below, usually involves finding a <i>value</i> with which %x can be replaced so that the formula is <i>true</i>.
\begin{eqnarray}
 %x + 4 & = & 7
\end{eqnarray}
In the above example, if %x is replaced with the integer 3, the equation is true. If we instead only allow our variables to have the values \top and \bot, we can ask the same question about any formula that contains a variable.
      ]]></paragraph>
      <definition required="true" hooks="math" id="1a0e7874e33a4464bd790b94bc2f13b2"><![CDATA[
We can extend our definition of a well-formed boolean formula to also allow variables:   
<table class="fig_table">
 <tr>
  <td><b>boolean formula</b></td>
  <td><b>conditions</b></td>
 </tr>
 <tr>
  <td>\vdots</td>
  <td>\vdots</td>
 </tr>
 <tr> 
  <td>%x</td>
  <td>a well-formed formula if %x is a variable name</td>
 </tr>
</table>
Sometimes, we will want to write very long variables names; in those cases, we will write the variable in %[underlined italics]%. For example, a formula with two variables %[the sun is visible]% and %[it is daytime]% might look as follows:
\begin{eqnarray}
   %[the sun is visible]% \Rightarrow %[it is daytime]%
\end{eqnarray}
      ]]></definition>
      <example required="true" hooks="math" id="6e9970794ae24fc6860368be7afe8154"><![CDATA[
For each of the following formulas, determine what combinations of values for %x and %y ensure that the formula is true (in some cases, there may be no solution for %x and %y that would make the formula true).
<ol style="list-style-type:lower-alpha; margin-left:-12px;">
  <li>
%x \vee \bot
  </li>
  <li>
%y \wedge %x \wedge \top
  </li>
  <li>
\top \oplus %y
  </li>
  <li>
\bot
  </li>
  <li>
(%x \Rightarrow %y) \wedge (%y \Rightarrow %x)
  </li>
  <li>
%x \Leftrightarrow %y
  </li>
  <li>
%x \Leftrightarrow %x
  </li>
  <li>
%x \wedge (\neg %x)
  </li>
</ol>
      ]]></example>
      <example required="true" hooks="math" id="993ad40e45e54ebaafffcffdb86657fa"><![CDATA[
Suppose we want to find what values for %x and %y make the following formula <i>false</i>:
\begin{eqnarray}
 (%x \wedge %y) \Rightarrow \top
\end{eqnarray}
Note that the <i>if and only if</i> operator \Leftrightarrow behaves just like equality; thus, we could instead find the values for %x and %y that make the following "equation" <i>true</i>:
\begin{eqnarray}
 ((%x \wedge %y) \Rightarrow \top) & \Leftrightarrow & \bot
\end{eqnarray}
Equivalently, we could find the values for %x and %y that make the logical negation of the original formula true:
\begin{eqnarray}
 \neg (%x \wedge %y)
\end{eqnarray}
      ]]></example>
      <definition required="true" hooks="math" id="eaae8a531cb7445b998a36a2dd4c3b41"><![CDATA[
When we assign some value, such as \top, to a variable %x, we say that <i>the value \top is assigned to %x</i> or that <i>%x maps to \top</i>, and we denote this using mathematical notation as:
\begin{eqnarray}
  %x \mapsto \top
\end{eqnarray}
      ]]></definition>
      <definition required="true" hooks="math" id="0c347fffa8264600ba4945fadd51a409"><![CDATA[
Suppose we have a mapping that assigns multiple variables to values, such as the following:
\begin{eqnarray}
  {%x_1 \mapsto \top, %x_2 \mapsto \bot, %x_3 \mapsto \bot, ..., %x_{%k} \mapsto \top}
\end{eqnarray}
We call such a mapping an <i>assignment</i> or a <i>model</i>.
      ]]></definition>
      <definition required="true" hooks="math" id="78a1e0ed892346a396f55cd665904b0d"><![CDATA[
Suppose that a formula %f contains some variables %x_1, ..., %x_{%k}. If we can find some <i>assignment</i> %m of the values \bot and \top to each of the variables such that substituting each variable in the formula with its assigned value results in a formula with the meaning <i>true</i>, we say that this particular assignment of values to %x_1, ..., %x_{%k} <i>solves</i> or <i>satisfies</i> the formula %f. We denote this fact using the following notation:
\begin{eqnarray}
  %m \models %f
\end{eqnarray}
      ]]></definition>
      <example required="true" hooks="math" id="0a2e68597a62407081608edadb04a751"><![CDATA[
Consider the formula %x \vee (%y \wedge %z) and the assignment {%x \mapsto \top, %y \mapsto \bot, %z \mapsto \bot}. Replacing %x with \top, %y with \bot, and %z with \bot in %x \vee (%y \wedge %z) results in the formula:
\begin{eqnarray}
  \top \vee (\bot \wedge \bot)
\end{eqnarray}
Since the above formula has the meaning <i>true</i>, we can say that {%x \mapsto \top, %y \mapsto \bot, %z \mapsto \bot} <i>satisfies</i> %x \vee (%y \wedge %z), which we denote:
\begin{eqnarray}
  {%x \mapsto \top, %y \mapsto \bot, %z \mapsto \bot} \models %x \vee (%y \wedge %z)
\end{eqnarray}
      ]]></example>
      <paragraph hooks="math"><![CDATA[
When equations involving logical formulas are used to model possible facts about some <i>system</i>, the variables will often represent some state or property of the system.
      ]]></paragraph>
      <example required="true" hooks="math" id="0dd54f9ef9a248f4aaa7a99c88e62099"><![CDATA[
Suppose we have the following formula involving the variables %[the sun is visible]% and %[it is daytime]%:
\begin{eqnarray}
  %[the sun is visible]% \Rightarrow %[it is daytime]%
\end{eqnarray}
This formula might describe a property of our real-world experience of a person that is in a particular fixed location on the surface of the Earth. We could state that the above formula is <i>always</i> true (i.e., it is always an accurate description of the system it describes). For every possible assignment of values to each variable, the above formula is indeed accurate, in that it is true exactly in those situations that might occur on Earth, and false in any situation that cannot occur:
<br/>
<table class="fig_table">
 <tr>
  <td><b>%[the sun is visible]%</b></td>
  <td><b>%[it is daytime]%</b></td>
  <td><b>meaning</b></td>
  <td><b>interpretation</b></td>
 </tr>
 <tr> 
  <td>\top</td>
  <td>\top</td>
  <td><i>true</i></td>
  <td>a sunny day</td>
 </tr>
 <tr> 
  <td>\top</td>
  <td>\bot</td>
  <td><i>false</i></td>
  <td></td>
 </tr>
 <tr> 
  <td>\bot</td>
  <td>\top</td>
  <td><i>true</i></td>
  <td>a cloudy day</td>
 </tr>
 <tr> 
  <td>\bot</td>
  <td>\bot</td>
  <td><i>true</i></td>
  <td>nighttime</td>
 </tr>
</table>
In particular, only one set of values causes the formula to be false: if the sun is in the sky, but it is not daytime. This is indeed impossible; all the others are possible (it may be day or night, or it may be cloudy during the day). In other words, the <i>assignments</i> that represent a sunny day, a cloudy day, and nighttime all <i>satisfy</i> the formula %[the sun is visible]% \Rightarrow %[it is daytime]%. For example:
\begin{eqnarray}
  {%[the sun is visible]% \mapsto \top, %[it is daytime]% \mapsto \top} \models %[the sun is visible]% \Rightarrow %[it is daytime]%
\end{eqnarray}
      ]]></example>
      <paragraph hooks="math"><![CDATA[
One way to find all the solutions for a boolean formula with one or more variables is to build a <i>truth table</i> that enumerates every possible combination of values that can be assigned to the variables, and then shows how the formula (and possibly its subformulas) evaluate under that assignment.
      ]]></paragraph>
      <example required="true" hooks="math" id="d42bee0a337a4892b4d62e9eab9d2bed"><![CDATA[
Suppose we want to solve the following formula:
\begin{eqnarray}
  (%z \vee %x) \Leftrightarrow (%y \oplus %z)
\end{eqnarray}
We can build a truth table for the above formula.
<br/>
<table class="fig_table truthtable">
 <tr>
  <td><b>%x</b></td>
  <td><b>%y</b></td>
  <td><b>%z</b></td>
  <td><b>%z \vee %x</b></td>
  <td><b>%y \oplus %z</b></td>
  <td><b>(%z \vee %x) \Leftrightarrow (%y \oplus %z)</b></td>
 </tr>
 <tr><td>\top</td><td>\top</td><td>\top</td><td>\top</td><td>\bot</td><td>\bot</td></tr>
 <tr><td>\top</td><td>\top</td><td>\bot</td><td>\top</td><td>\top</td><td>\top</td></tr>
 <tr><td>\top</td><td>\bot</td><td>\top</td><td>\top</td><td>\top</td><td>\top</td></tr>
 <tr><td>\top</td><td>\bot</td><td>\bot</td><td>\top</td><td>\bot</td><td>\bot</td></tr>
 <tr><td>\bot</td><td>\top</td><td>\top</td><td>\top</td><td>\bot</td><td>\bot</td></tr>
 <tr><td>\bot</td><td>\top</td><td>\bot</td><td>\bot</td><td>\top</td><td>\bot</td></tr>
 <tr><td>\bot</td><td>\bot</td><td>\top</td><td>\top</td><td>\top</td><td>\top</td></tr>
 <tr><td>\bot</td><td>\bot</td><td>\bot</td><td>\bot</td><td>\bot</td><td>\top</td></tr>
</table>
Thus, there are four possible solutions for the formula (%z \vee %x) \Leftrightarrow (%y \oplus %z). For example, the assignment %x \mapsto \top, %y \mapsto \top, and %z \mapsto \bot is one possible solution.
      ]]></example>
      <paragraph hooks="math"><![CDATA[
Just as operators on the real numbers or integers have algebraic properties (such as %x + %y = %y + %x, or 2 \cdot %x = %x + %x, and so on), boolean operators also have algebraic properties that can be derived from their <a href="#3bd4848251cb47c98a603e19d5beea64">meaning</a>. In fact, every formula that contains variables and is true for every possible assignment of values to those variables is technically an algebraic property. However, we will list several common algebraic properties.
      ]]></paragraph>
      <fact required="true" hooks="math" id="8d3f9ceeda1945c78cbb9c6a24c4f4ba"><![CDATA[
We define \equiv to be <i>equivalence</i> of formulas: if %f \equiv %g for two formulas %f and %g, this means that %f and %g have the same meaning (i.e., under <i>any</i> given assignment of variables to values, both formulas are either true or false, but never different; in other words, their truth tables are identical).
      ]]></fact>
      <paragraph hooks="math"><![CDATA[
Note that we do not need \equiv, since \Leftrightarrow would suffice for a presentation of the properties below. However, we introduce \equiv to emphasize that we are defining algebraic properties that govern formulas which may themselves contain \Leftrightarrow.
      ]]></paragraph>
      <fact required="true" hooks="math" id="abd9f8f2a89b44018970dffc4732b77b"><![CDATA[
The \vee, \wedge, and \neg operators have some familiar algebraic properties:
\begin{eqnarray}
  %x \vee %y & \equiv & %y \vee %x & %~ & (commutativity of \vee) \\
  (%x \vee %y) \vee %z & \equiv & %x \vee (%y \vee %z) & %~ & (associativity of \vee) \\
  %x \vee \bot & \equiv & %x & %~ & (identity of \vee) \\
  %x \wedge %y & \equiv & %y \wedge %x & %~ & (commutativity of \wedge) \\
  (%x \wedge %y) \wedge %z & \equiv & %x \wedge (%y \wedge %z) & %~ & (associativity of \wedge) \\
  %x \wedge \top & \equiv & %x & %~ & (identity of \wedge) \\
  %x \wedge (%y \vee %z) & \equiv & (%x \wedge %y) \vee (%x \wedge %z) & %~ & (distributivity of \wedge across \vee) \\
  \neg(\neg(%x)) & \equiv & %x & %~ & (invertibility of \neg)
\end{eqnarray}
Furthermore, \vee and \wedge can be expressed in terms of one another with the help of &nbsp;\neg:
\begin{eqnarray}
  \neg(%x \wedge %y) & \equiv & (\neg (%x)) \vee (\neg (%y)) & %~ & (<a href="http://en.wikipedia.org/wiki/De_Morgan's_laws">De Morgan's Law</a>)
\end{eqnarray}
Using the above, we can define \wedge in terms of \vee by negating both sides:
\begin{eqnarray}
  %x \wedge %y & \equiv & \neg((\neg (%x)) \vee (\neg (%y)))
\end{eqnarray}
Alternatively, we could define \vee in terms of \wedge by negating %x and %y (e.g., negating %x everywhere should not change anything, because the formula is true for <i>any</i> value of %x, whether it is \top or \bot):
\begin{eqnarray}
  \neg(\neg(%x) \wedge \neg(%y)) & \equiv & %x \vee %y
\end{eqnarray}
      ]]></fact>
      <example required="true" hooks="math" id="9b52a0ce17e44d259b47573b205994a3"><![CDATA[
If an algebraic property holds, this means that the final rows of the truth tables for the two formulas are exactly the same. For example, consider the following algebraic law:
\begin{eqnarray}
  \neg(%x \wedge %y) & \equiv & \neg(%x) \vee \neg(%y) \\
\end{eqnarray}
If we build truth tables for both formulas, we see that the final row in both tables is the same:
<table class="fig_table truthtable">
 <tr>
  <td><b>%x</b></td>
  <td><b>%y</b></td>
  <td><b>%x \wedge %y</b></td>
  <td><b>\neg(%x \wedge %y)</b></td>
 </tr>
 <tr><td>\top</td><td>\top</td><td>\top</td><td>\bot</td></tr>
 <tr><td>\top</td><td>\bot</td><td>\bot</td><td>\top</td></tr>
 <tr><td>\bot</td><td>\top</td><td>\bot</td><td>\top</td></tr>
 <tr><td>\bot</td><td>\bot</td><td>\bot</td><td>\top</td></tr>
</table>

<table class="fig_table">
 <tr>
  <td><b>%x</b></td>
  <td><b>%y</b></td>
  <td><b>\neg(%x)</b></td>
  <td><b>\neg(%y)</b></td>
  <td><b>\neg(%x) \vee \neg(%y)</b></td>
 </tr>
 <tr><td>\top</td><td>\top</td><td>\bot</td><td>\bot</td><td>\bot</td></tr>
 <tr><td>\top</td><td>\bot</td><td>\bot</td><td>\top</td><td>\top</td></tr>
 <tr><td>\bot</td><td>\top</td><td>\top</td><td>\bot</td><td>\top</td></tr>
 <tr><td>\bot</td><td>\bot</td><td>\top</td><td>\top</td><td>\top</td></tr>
</table>
      ]]></example>
      <fact required="true" hooks="math" id="2954df01e1e84156bbdfd8563217a66f"><![CDATA[
The \oplus, \Rightarrow, and \Leftrightarrow operators have many algebraic properties. We present a few important properties. In particular, these operators can be defined using \vee, \wedge, and \neg:
\begin{eqnarray}
  %x \oplus %y & \equiv & (%x \vee %y) \wedge (\neg(%x \wedge %y)) \\
  %x \Rightarrow %y & \equiv & (\neg(%x)) \vee %y \\
  (%x \Leftrightarrow %y) & \equiv & (%x \wedge %y) \vee (\neg(%x) \wedge \neg(%y))
\end{eqnarray}
Furthermore, \Leftrightarrow can be defined in terms of \Rightarrow, and \Leftrightarrow is an equivalence relation:
\begin{eqnarray}
  %x \Leftrightarrow %y & \equiv & (%x \Rightarrow %y) \wedge (%y \Rightarrow %x) \\
  %x \Leftrightarrow %x & \equiv & \top & %~ & (reflexivity of \Leftrightarrow) \\
  %x \Leftrightarrow %y & \equiv & %y \Leftrightarrow %x & %~ & (symmetry of \Leftrightarrow) \\
  (%x \Leftrightarrow %y) \wedge (%y \Leftrightarrow %z) \Rightarrow (%x \Leftrightarrow %z) & \equiv & \top & %~ & (transitivity of \Leftrightarrow) \\
\end{eqnarray}
One important property of \oplus is that taking \oplus of a formula with itself always yields \bot:
\begin{eqnarray}
  %x \oplus %x & \equiv & \bot
\end{eqnarray}
      ]]></fact>
      <paragraph hooks="math"><![CDATA[
Since \oplus, \Leftrightarrow, and \Leftrightarrow can all be defined in terms of \vee, \wedge, and \neg, we could actually eliminate them completely without affected the power of our boolean formula language. Since \vee and \wedge are also related, we could also eliminate one of these. The fact that \wedge and \neg would be sufficient to express all possible logical formulas makes \neg and \wedge <i>functionally complete</i> (i.e., capable of expressing all possible truth tables on any number of variables).
      ]]></paragraph>
      <paragraph hooks="math"><![CDATA[
In fact, we can go even further; the following single boolean operator \uparrow (also called the <a href="http://en.wikipedia.org/wiki/Logical_NAND">Sheffer stroke</a>, or NAND) is functionally complete all by itself, because it can be used to define \wedge and \neg:
\begin{eqnarray}
  \top \uparrow \top & \equiv & \bot \\
  \top \uparrow \bot & \equiv & \top \\
  \bot \uparrow \top & \equiv & \top \\
  \bot \uparrow \bot & \equiv & \top
\end{eqnarray}
There are other such operators, such as <a href="http://en.wikipedia.org/wiki/Logical_NOR">NOR</a>.
      ]]></paragraph>
      <paragraph title="Note on operator precedence" hooks="math"><![CDATA[
Because different communities of mathematicians and computer scientists sometimes use different precedence conventions for logical operators, in this course we will include parentheses in formulas where the order of operations might otherwise be ambiguous. One common convention is that \neg has highest precedence, followed by \wedge (since it can corresponding to multiplication when \top is represented with 1 and \bot is represented with 0), then by \vee (since it can corresponding to addition), then by \Rightarrow (since it is often used to organize relationships and dependencies between "simpler" formulas involving operations with higher precedence), and then by \oplus.
      ]]></paragraph>
      <example required="true" id="92e08d71e05e4a5b86865312279d262a">
        <text  hooks="math"><![CDATA[
Using the programming language Python, we can represent a formula with variables as a function that takes boolean arguments and returns a boolean result. For example, suppose we have the following formula:
\begin{eqnarray}
  %x \wedge (%y \vee (\neg (%z)))
\end{eqnarray}
We could represent this as the following Python function:
        ]]></text>
        <code hooks="Python">
@def f(x, y, z):
  @return x @and (y @or (@not(z)))
        </code>
        <text  hooks="math"><![CDATA[
We can then evaluate the above for a given assignment by calling the function <code>f</code> on some arguments. For example, if we want to evaluate the formula under the assignment {%x \mapsto \top, %y \mapsto \bot, %z \mapsto \bot}, we can make the following function call:
        ]]></text>
        <code hooks="Python">
>>> f(@True, @False, @False)
@True
        </code>
        <text  hooks="math"><![CDATA[
We can also use the Python unpacking operators to explicitly represent our assignment as a Python list or dictionary. For example:
        ]]></text>
        <code hooks="Python">
>>> m = [@True, @False, @False]   # Python list.
>>> f(*m)                      # Argument unpacking (also known as splat) operator.
@True
>>> m = {'x': @True, 'y': @False, 'z': @False}   # Python dictionary.
>>> f(**m)                                    # Keyword argument unpacking operator.
@True
        </code>
      </example>
    </subsection>    
    <subsection title="Boolean satisfiability, recursive backtracking, and applications">
      <paragraph hooks="math"><![CDATA[
Finding an assignment or model that satisfies a boolean formula is a fundamental and ubiquitous problem in computer science. An immense variety of different real-world and theoretical constructs, systems, devices, concepts, and problems can be represented as boolean formulas (where the solutions to the formula might provide a solution to the problem, or might answer some question about the properties of whatever is being represented). In this section we define two versions of this problem, and describe one standard algorithmic approach for solving the problem.
      ]]></paragraph>
      <definition required="true" hooks="math" id="5b5e038221fb4c589a88692a761645a8"><![CDATA[
We define an instance of the <i>boolean satisfiability problem</i> as follows: given a formula %f, find an assignment (or <i>model</i>) %m such that %m satisfies %f:
\begin{eqnarray}
  %m \models %f
\end{eqnarray}
      ]]></definition>
      <definition required="true" hooks="math" id="6afb8e78ab444513990059ce160838fe"><![CDATA[
We define an instance of the <i>maximum boolean satisfiability problem</i> as follows: given a formula %f, find an assignment (or <i>model</i>) %m such that %m satisfies %f, and such that %m has at least as many variables assigned to \top as any other model that satisfies %f.
<br/><br/>
In other words, if we list <i>all</i> the models that satisfy %f, we want the one that has the most variables mapped to \top (or at least as many as any other, since more than one model may map the same number of variables to \top).
      ]]></definition>
      <paragraph hooks="math"><![CDATA[
Unfortunately, unless something is known about the particular structure of the formula %f, the problem of finding a model that satisfies a formula cannot be solved efficiently. Essentially, the best known algorithm is as fast as any algorithm that builds the entire truth table for the formula.
      ]]></paragraph>
      <paragraph hooks="math"><![CDATA[
One standard way to implement an algorithm that exhaustively tries all possible combinations of assignments to a set of variables is to use <i>recursive backtracking</i>.
      ]]></paragraph>
      <algorithm required="true" title="recursive backtracking" hooks="math" id="97f1ff31c4c24ebc88a3d96efb112225"><![CDATA[
The <i>recursive backtracking</i> algorithm is a way to exhaustively try all possible solution to a problem by nesting an arbitrarily large number of loops inside each other using recursion. The following pseudocode describes a generic version of the recursive backtracking algorithm for some problem %f for which we are seeking a candidate solution %s.
<ol style="list-style-type:none;">
  <li><b>inputs:</b> some function %f, and some partial candidate solution %s
    <ol style="list-style-type:none;">
      <li><b>if</b> %s is a full-size candidate solution
        <ol style="list-style-type:none;">
          <li><b>if</b> %s solves the problem %f
            <ol style="list-style-type:none;">
              <li><b>return</b> the result %s</li>
            </ol>
          </li>
          <li><b>otherwise</b>
            <ol style="list-style-type:none;">
              <li><b>return</b> nothing</li>
            </ol>
          </li>
        </ol>
      </li>
      <li><b>otherwise</b> %s is not a full-size solution and must be extended      
        <ol style="list-style-type:none;">
          <li><b>for</b> every possible way that %s can be extended to some %s' that is closer to a full-size solution
            <ol style="list-style-type:none;">
              <li><b>call</b> this algorithm recursively on %f and %s'</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>
      ]]></algorithm>
      <example required="true" id="177a8f567f664a0688c6ebcfd417a7d6">
        <text hooks="math"><![CDATA[
A simple example is the problem of opening a safe. Suppose that a safe combination consists of some sequence of the letters <code>a</code>, <code>b</code>, and <code>c</code>. We do not know the length of the sequence, or what sequence will unlock the safe. Suppose that there is a function that checks if the sequence is correct and unlocks the safe (we do not know how it works, but we know its name and that if it unlocks the safe, it returns <code>True</code>):
        ]]></text>
        <code hooks="Python"><![CDATA[
@def unlock(password):
   # ... returns True of password is correct, False otherwise ...
   @if password == 'abcbac':
     @return @True
   @else:
     @return @False
        ]]></code>
        <text hooks="math"><![CDATA[
We want to write a Python function that tries passing every possible string containing <code>a</code>, <code>b</code>, and <code>c</code> to <code>unlock()</code>. If we know the length of the safe combination (and if the length were short, e.g., three letters), then we could simply use nested <code>for</code> loops to try all the combinations and print the combination that unlocks the safe:
        ]]></text>
        <code hooks="Python"><![CDATA[
@def three():
   @for x @in {'a', 'b', 'c'}:
     @for y @in {'a', 'b', 'c'}:
       @for z @in {'a', 'b', 'c'}:
         @if unlock(x + y + z):
           @print(x + y + z)
        ]]></code>
        <text hooks="math"><![CDATA[
However, if we do not know the length of the sequence, we might want to make an arbitrary hierarchy of nested <code>for</code> loops to find the password:
        ]]></text>
        <code hooks="Python"><![CDATA[
@def any():
   @for x1 @in {'a', 'b', 'c'}:
     @for x2 @in {'a', 'b', 'c'}:
       # ...
         @for xN @in {'a', 'b', 'c'}:
           # ...
             @if unlock(x1 + x2 + ... + xN + ...):
               @print(x1 + x2 + ... + xN + ...)
        ]]></code>
        <text hooks="math"><![CDATA[
Of course, it is not possible to write the above explicitly. However, by using recursion, we can write a function that behaves exactly in this way: as an arbitrarily nested hierarchy of <code>for</code> loops. First, suppose we simply want to print all the combinations. We could do the following:
        ]]></text>
        <code hooks="Python"><![CDATA[
@def any(guess = ""):
  @print(guess)
  @for c @in {'a', 'b', 'c'}:
    newGuess = guess + c
    any(newGuess)
        ]]></code>
        <text hooks="math"><![CDATA[
The above algorithm actually keeps trying combinations of all lengths. If we run the above, we'll see that it keeps printing combinations as they get longer and longer. How can we make this process stop at a certain length of password? We would need to check the length of our guess and <i>not</i> make a recursive call if the guess is too long. We can do this by using an <code>if</code> statement:
        ]]></text>
        <code hooks="Python"><![CDATA[
@def any(guess = ""):
  @if @len(guess) <= 4:
    @print(guess)
    @for c @in {'a', 'b', 'c'}:
      newGuess = guess + c
      any(newGuess)
        ]]></code>
        <text hooks="math"><![CDATA[
Suppose we only want to print the guess if it actually unlocks the safe. We can do so in the following way:
        ]]></text>
        <code hooks="Python"><![CDATA[
@def any(guess = ""):
   @if unlock(guess):
     @print(guess)
   @else:
     @for c @in {'a', 'b', 'c'}:
       newGuess = guess + c
       any(newGuess)
        ]]></code>
        <text hooks="math"><![CDATA[
Suppose that you knew the length of the combination would be supplied as an integer argument to the function. How would you modify the above to actually return the correct guess instead of just printing it? One way to do the latter is presented below.
        ]]></text>
        <code hooks="Python"><![CDATA[
@def any(guess = ""):
   @if unlock(guess):
     @return guess
   @else:
     @for c @in {'a', 'b', 'c'}:
       newGuess = guess + c
       result = any(newGuess)
       @if result != @None:
         @return result
        ]]></code>
        <text hooks="math"><![CDATA[
How could you modify the above to only try combinations of a specific length, and nothing longer?
        ]]></text>
      </example>
      <example required="true" id="645006d6669342dfab0e720a462fb52e">
        <text hooks="math"><![CDATA[
As a simpler example, suppose a password consists of a string of some length containing only the letter <code>a</code>, but we do not know its length.
        ]]></text>
        <code hooks="Python"><![CDATA[
@def unlock(password):
   @if password == "aaaaa":
     @return @True
   @else:
     @return @False
        ]]></code>
        <text hooks="math"><![CDATA[
We can write a recursive function that tries every possible length, and returns the working password once it is found:
        ]]></text>
        <code hooks="Python"><![CDATA[
@def find(guess = ""):
   @if unlock(guess):
     @return guess
   @else:
     @return find(guess + "a")   # Return result of recursive call.
        ]]></code>
        <paragraph hooks="math"><![CDATA[
Notice that the above function <code>find()</code> will recursively call itself and "build up" its parameter <code>guess</code> until it is long enough to match the true password. 
        ]]></paragraph>
        <paragraph hooks="math"><![CDATA[
Now, suppose we are worried that the password might contain letters other than <code>a</code>, in which case the above function will keep calling itself recursively forever. We may want to set an upper bound on how long the <code>guess</code> can become, and then allow the function to fail gracefully by returning <code>None</code>:
        ]]></paragraph>
        <code hooks="Python"><![CDATA[
@def find(guess = ""):
   @if unlock(guess):
     @return guess
   @elif @len(guess) > 100:
     @return @None   # Give up.
   @else:
     @return find(guess + "a")
        ]]></code>
      </example>
      <example required="true" id="f65b85886ae649d8bb60125a9385228f">
        <text hooks="math"><![CDATA[
Suppose we want to write a recursive algorithm that returns the largest integer in a list. We can do so by first splitting the list two two halves, and then finding the largest element in each half. We can then take the larger of these two results. This is guaranteed to give us the largest element in the list.
        ]]></text>
        <code hooks="Python"><![CDATA[
@def largest(xs):
  @if @len(xs) == 1:
    @return xs[0]
  @else:
    # All elements from index 0 to len(xs)/2 - 1.
    leftHalf = xs[:@len(xs)/2] 
    
    # All elements from index len(xs)/2 to the last element.
    rightHalf = xs[@len(xs)/2:]
    
    @return @max(largest(leftHalf), largest(rightHalf))
        ]]></code>
      </example>
      <paragraph hooks="math"><![CDATA[
Many real-world situations and devices, or <i>systems</i>, can be modeled mathematically by identifying a set of discrete <i>system states</i> in which that system can be (e.g., a lamp can either be "on" or "off"). 
      ]]></paragraph>
      <paragraph hooks="math"><![CDATA[
In many cases, it is possible to model the various interesting, discrete properties of the system as variables (e.g., the variable %[the lamp is on]% can be used to keep track of whether the lamp is actually on or off by assigning the values \top and \bot to it, respectively). Then, a given state can be modeled using <i>assignments</i> (or <i>models</i>) of values to variables (e.g., the model {%[the lamp is on]% \mapsto \top} is a model of a system state in which the lamp is on, and {%[the lamp is on]% \mapsto \top} is a model of the system state in which the lamp is off).
      ]]></paragraph>
      <paragraph hooks="math"><![CDATA[
If a system can be described using a set of models of possible system states, we can then use formulas to describe logical constraints over (and relationships between) the various parts of the system. For example, we can then say that the only "allowed" or "possible" system states are those that satisfy a particular formula.
      ]]></paragraph>
      <example required="true" id="29822d9e25084fa89cad0c994619b500">
        <text hooks="math"><![CDATA[
Suppose we want to model a system consisting of a single light switch that can either be in an "on" position or an "off" position, and a light controlled by the switch, which may be either "on" or "off". We can introduce two predicates for describing this system state: %[switch]% and %[light]%, where the first represents the state of the switch, and the second represents the state of the light (in both cases, \top is "on" and \bot is "off").
        ]]></text>
        <paragraph hooks="math"><![CDATA[
While there are 2^2 = 4 possible ways to assign values to these two variables, not all would correspond to a possible state of the system if the light switch works correctly. In particular, any model %m of a state must adhere to the following:
\begin{eqnarray}
  %m \models %[switch]% \Leftrightarrow %[light]%
\end{eqnarray}
In other words, the switch and light should always correspond to the same setting. The two system states that satisfy the above formula are:
\begin{eqnarray}
  %m_1 & \equiv & {%[switch]% \mapsto \top, %[light]% \mapsto \top} \\
  %m_2 & \equiv & {%[switch]% \mapsto \bot, %[light]% \mapsto \bot}
\end{eqnarray}
        ]]></paragraph>
      </example>
      <example required="true" id="202b4e61a8264e0996a6fb30e2c6f58c">
        <text hooks="math"><![CDATA[
Note that there is no single correct way to model a situation using formulas. In an alternative form of the <a href="#29822d9e25084fa89cad0c994619b500">light switch example</a>, we can introduce four predicates for describing system states: %[switch is off]%, %[switch is on]%, %[light is off]%, %[light is on]%. 
        ]]></text>
        <paragraph hooks="math"><![CDATA[
While there are 2^4 = 16 possible ways to assign values to these four variables, not all would correspond to a possible state of the system if the light switch works correctly. For example, any model %m of a state must adhere to the following:
\begin{eqnarray}
  %m \models %[switch is off]% \oplus %[switch is on]%
\end{eqnarray}
In other words, the switch cannot be in two positions at once. Likewise, the light can only be in one state at a time:
\begin{eqnarray}
  %m \models %[light is off]% \oplus %[light is on]%
\end{eqnarray}
Finally, the switch and light should always correspond:
\begin{eqnarray}
  %m \models (%[switch is off]% \Leftrightarrow %[light is off]%) \wedge (%[switch is on]% \Leftrightarrow %[light is on]%)
\end{eqnarray}
Thus, the two system states that satisfies the conjunction (i.e., \wedge) all these formulas are:
\begin{eqnarray}
  %m_1 & \equiv & {%[switch is off]% \mapsto \top, %[switch is on]% \mapsto \bot, %[light is off]% \mapsto \top, %[light is on]% \mapsto \bot} \\
  %m_2 & \equiv & {%[switch is off]% \mapsto \bot, %[switch is on]% \mapsto \top, %[light is off]% \mapsto \bot, %[light is on]% \mapsto \top}
\end{eqnarray}
        ]]></paragraph>
      </example>
      <example required="true" id="acda575e529645aab9b6bb9b20300c14">
        <text hooks="math"><![CDATA[
Suppose we want to model a system consisting of an airlock (i.e., a room with two doors, one leading outside and one leading into an enclosure). If the airlock's outer door is open, the inner door must be closed.
        ]]></text>
        <paragraph hooks="math"><![CDATA[
First, suppose we use %[outer door]% and %[inner door]% to represent whether the doors are open (\top) or closed (\bot). A naive programmer implemented the airlock software so that every possible state %m of the airlock door adheres to the following requirement:
\begin{eqnarray}
  %m \models %[outer door]% \oplus %[inner door]%
\end{eqnarray}
Does the above constraint satisfy the practical requirements of an airlock? If the airlock needs to allow someone to depressurize or pressurize before they exit the airlock, it should be possible to have both doors of the airlock closed at the same time. Is this possible under the given constraint? We can answer this question by determining if any state of the airlock satisfies the following formula:
\begin{eqnarray}
  %m \models (%[outer door]% \oplus %[inner door]%) \wedge \neg(%[outer door]%) \wedge \neg(%[inner door]%)
\end{eqnarray}
In other words, is it possible for the constraint guaranteed by the programmer to be satisfied, and for the two doors to both be locked? If we try to solve the above boolean satisfaction problem for %m, we will find that it has no solution (states that satisfy the formula are in <b style="color:green;">green</b>, and states that do not satisfy the formula are in <b style="color:firebrick;">red</b>):
<table class="fig_table truthtable">
 <tr>
  <td><b>%[outer<br/>door]%</b></td>
  <td><b>%[inner<br/>door]%</b></td>
  <td><b>\neg(%[outer door]%)</b></td>
  <td><b>\neg(%[inner door]%)</b></td>
  <td><b>%[outer door]%<br/>\oplus<br/>%[inner door]%</b></td>
  <td><b>overall<br/>formula</b></td>
 </tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\top (open)</td><td>\top (open)</td><td>\bot</td><td>\bot</td><td>\bot</td><td>\bot</td></tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\top (open)</td><td>\bot (closed)</td><td>\bot</td><td>\top</td><td>\top</td><td>\bot</td></tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\bot (closed)</td><td>\top (open)</td><td>\top</td><td>\bot</td><td>\top</td><td>\bot</td></tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\bot (closed)</td><td>\bot (closed)</td><td>\top</td><td>\top</td><td>\bot</td><td>\bot</td></tr>
</table>
How can this be fixed? Instead of using the \oplus operator, the programmer should have used \Rightarrow, so that every state of the airlock %m should satisfy:
\begin{eqnarray}
  %m \models %[outer door]% \Rightarrow \neg(%[inner door]%)
\end{eqnarray}
Then, we can try to solve the following formula:
\begin{eqnarray}
  %m \models (%[outer door]% \Rightarrow \neg(%[inner door]%)) \wedge \neg(%[outer door]%) \wedge \neg(%[inner door]%)
\end{eqnarray}
We see that the above formula does have a solution:
<table class="fig_table truthtable">
 <tr>
  <td><b>%[outer<br/>door]%</b></td>
  <td><b>%[inner<br/>door]%</b></td>
  <td><b>\neg(%[outer door]%)</b></td>
  <td><b>\neg(%[inner door]%)</b></td>
  <td><b>%[outer door]%<br/>\Rightarrow<br/>\neg(%[inner door]%)</b></td>
  <td><b>overall<br/>formula</b></td>
 </tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\top (open)</td><td>\top (open)</td><td>\bot</td><td>\bot</td><td>\bot</td><td>\bot</td></tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\top (open)</td><td>\bot (closed)</td><td>\bot</td><td>\top</td><td>\top</td><td>\bot</td></tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\bot (closed)</td><td>\top (open)</td><td>\top</td><td>\bot</td><td>\top</td><td>\bot</td></tr>
 <tr style="color:green; font-weight:bold;"><td>\bot (closed)</td><td>\bot (closed)</td><td>\top</td><td>\top</td><td>\top</td><td>\top</td></tr>
</table>
        ]]></paragraph>
      </example>
      <example required="true" id="c614855dcb274f3c93fa38c7a73b1378">
        <text hooks="math"><![CDATA[
Suppose we want to improve <a href="acda575e529645aab9b6bb9b20300c14">our airlock</a> by installing a fire detector inside the enclosure. The fire detector should ensure that someone in the airlock cannot go inside the enclosure if there is a fire detected inside.
        ]]></text>
        <paragraph hooks="math"><![CDATA[
A new programmer comes along and incorporates the functionality of the fire detector into the software, and now the airlock's software adheres to the following constraint:
\begin{eqnarray}
  %m \models (%[outer door]% \Rightarrow \neg(%[inner door]%)) \wedge (%[fire]% \Rightarrow \neg(%[inner door]%))
\end{eqnarray}
In other words, in addition to the first constraint, the inner door locks if there is a fire. Is there a potentially dangerous flaw in the software? One problem is that if there is a fire, it should not be possible for both doors to be closed because this may be dangerous (e.g., due to heat accumulation in the airlock). For concision, let us call the formula to which the software adheres %f:
\begin{eqnarray}
  %f & \equiv & (%[outer door]% \Rightarrow \neg(%[inner door]%)) \wedge (%[fire]% \Rightarrow \neg(%[inner door]%))
\end{eqnarray}
We can then check whether the dangerous situation might occur by looking for states that adhere to the following:
\begin{eqnarray}
  %m \models %f \wedge %[fire]% \wedge \neg(%[outer door]%) \wedge \neg(%[inner door]%)
\end{eqnarray}
We can examine the truth table to determine if there is a solution (states that satisfy the formula are in <b style="color:green;">green</b>, and states that do not satisfy the formula are in <b style="color:firebrick;">red</b>, and we abbreviate some of the variable names):
<table class="fig_table truthtable">
 <tr>
  <td><b>%[outer]%</b></td>
  <td><b>%[inner]%</b></td>
  <td><b>\neg(%[outer]%)</b></td>
  <td><b>\neg(%[inner]%)</b></td>
  <td><b>%[fire]%</b></td>
  <td><b>%[outer]%<br/>\Rightarrow \neg(%[inner]%)</b></td>
  <td><b>%[fire]%<br/>\Rightarrow \neg(%[inner]%)</b></td>
 </tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\top (open)</td><td>\top (open)</td><td>\bot</td><td>\bot</td><td>\bot (safe)</td><td>\bot</td><td>\top</td></tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\top (open)</td><td>\bot (closed)</td><td>\bot</td><td>\top</td><td>\bot (safe)</td><td>\top</td><td>\top</td></tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\bot (closed)</td><td>\top (open)</td><td>\top</td><td>\bot</td><td>\bot (safe)</td><td>\top</td><td>\top</td></tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\bot (closed)</td><td>\bot (closed)</td><td>\top</td><td>\top</td><td>\bot (safe)</td><td>\top</td><td>\top</td></tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\top (open)</td><td>\top (open)</td><td>\bot</td><td>\bot</td><td>\top (fire)</td><td>\bot</td><td>\bot</td></tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\top (open)</td><td>\bot (closed)</td><td>\bot</td><td>\top</td><td>\top (fire)</td><td>\top</td><td>\top</td></tr>
 <tr style="color:firebrick; font-weight:bold;"><td>\bot (closed)</td><td>\top (open)</td><td>\top</td><td>\bot</td><td>\top (fire)</td><td>\bot</td><td>\bot</td></tr>
 <tr style="color:green; font-weight:bold; font-style:italic;"><td>\bot (closed)</td><td>\bot (closed)</td><td>\top</td><td>\top</td>   <td>\top (fire)</td><td>\top</td><td>\top</td></tr>
</table>
Thus, there exists an unsafe state. One way to avoid this is to modify the software so that it ensure that the outer door is open during a fire (i.e., that the formula %[fire]% \Rightarrow %[outer door]% is always true).
        ]]></paragraph>
      </example>
      <example required="true" id="c0b83811ed134245bbacacc295e2f804">
        <text hooks="math"><![CDATA[
You are running a cloud computing service and receive several customer requests for a particular computing resource that fall into specific, fixed time windows:
<ul>
  <li>request %a: from 2 AM - 4 AM</li>
  <li>request %b: from 3 AM - 7 AM</li>
  <li>request %c: from 6 AM - 10 AM</li>
  <li>request %d: from 2 AM - 8 AM</li>
  <li>request %e: from 8 AM - 9 AM</li>
  <li>request %f: from 9 AM - 10 AM</li>
</ul>
Since the resource can only be allocated to one customer at a time, you cannot satisfy all the requests. How can you satisfy the maximum number of requests?
        ]]></text>
        <paragraph hooks="math"><![CDATA[
One approach is to assemble a collection of logical formulas that capture the fact that certain requests are mutually exclusive. If each request has a corresponding variable, then a model that assigns \top to that variable would indicate that the request will be allocated, while a model that assigns \bot to that variable would indicate that the request will not be allocated. The formulas in this case would be:
\begin{eqnarray}
  %a \Rightarrow (\neg(%b)) \\
  %a \Rightarrow (\neg(%d)) \\
  %b \Rightarrow (\neg(%c)) \\
  %b \Rightarrow (\neg(%d)) \\
  %c \Rightarrow (\neg(%d)) \\
  %c \Rightarrow (\neg(%e)) \\
  %c \Rightarrow (\neg(%f))
\end{eqnarray}
If we take the conjunction (i.e., \wedge) of all of the above formulas to make a new formula %h, then any model %m that satisfies the formula %h would correspond to a possible allocation of the requests. If we choose the model %m that allocates the <i>maximum</i> number of requests (i.e., if we solve the <a href="#6afb8e78ab444513990059ce160838fe">maximum boolean satisfiability problem</a>), we can determine how to allocate the maximum number of requests.
        ]]></paragraph>
      </example>
      <!-- 
      truth table using integers

      compute running time of recursive backtracking
      system states and predicates
      definition of "in" predicate/relational operator      
      example of set of models
      example for relationship (sets and formulas)
      -->
    </subsection>
    <assignment title="Boolean Arithmetic, Algebra, and Satisfiability">
      <instructions><![CDATA[
In this assignment you will define several Python functions for solving problems involving boolean algebra.
<br/><br/>
<b style="color:firebrick;">Your solution may not import any modules or employ any external library functions (unless the problem statement explicitly permits this).</b> The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
      ]]></instructions>
      <problems>
        <problem>
          <text hooks="math"><![CDATA[
Convert each of the following boolean formulas into their corresponding Python syntax. For each problem part, define an <b>uppercase</b> single-letter variable and assign the formula to that variable in a single assignment statement. For example, suppose the formula for <b>part (f)</b> were specified as follows:
\begin{eqnarray}
  \bot \wedge (\top \vee (\neg (\bot)))
\end{eqnarray}
You would then add the following line to your Python file:
          ]]></text>
          <code hooks="Python">
F = @False @and (@True @or (@not (@False)))
          </code>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
\bot \Rightarrow (\top \vee \bot)
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
(\top \Rightarrow (\top \vee \bot)) \oplus \bot
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
(\top \oplus (\neg(\top))) \Leftrightarrow (\neg (\top))
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
(\top \Leftrightarrow \bot) \oplus (\bot \Leftrightarrow \top)
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
(\top \Rightarrow \bot) \wedge (\neg(\bot) \Rightarrow \neg(\top))
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
Convert each of the following boolean formulas that contain variables into a corresponding Python function. For each problem part, define a <b>lowercase</b> single-letter named function that takes one or more named arguments (one corresponding to each variable in the formula) and returns the result of evaluating that formula given those arguments. For example, suppose the formula for <b>part (f)</b> were specified as follows:
\begin{eqnarray}
  %z \wedge (%x \vee (\neg (%y)))
\end{eqnarray}
You would then add the following function definition to your Python file:
          ]]></text>
          <code hooks="Python">
@def f(x, y, z):
  @return z @and (x @or (@not (y)))
          </code>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
%x \Rightarrow %y
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
%x \Leftrightarrow (%y \oplus %z)
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
((%x \Rightarrow %y) \wedge %x) \Rightarrow %y
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
(%x \Leftrightarrow %y) \Rightarrow (\neg(%x) \Leftrightarrow \neg(%y))
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
((%x \Rightarrow %y) \vee (%w \Rightarrow %v)) \Rightarrow ((%x \wedge %w) \Rightarrow (%z \wedge (%y \vee %v)))
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text><![CDATA[
In this problem, you will implement functions for printing truth tables for formulas with variables. You may use the following helper function, which prints a tab-delimited list of values.
          ]]></text>
          <code hooks="Python">
@def prints(values):
  @print("\t".join([@str(value) @for value @in values]))
          </code>
          <text><![CDATA[
The above function can be used as follows:
          ]]></text>
          <code hooks="Python">
>>> prints([@True, @False, @True])
@True   @False  @True
          </code>
          <text><![CDATA[
You may also use the following helper function, which returns a list of the argument names of a function:
          ]]></text>
          <code hooks="Python">
@def variables(f):
    @return @list(f.__code__.co_varnames)
          </code>
          <text><![CDATA[
The above function can be used as follows:
          ]]></text>
          <code hooks="Python"><![CDATA[
>>> @def h(x,y,z): @return (y @or x) @and (@not(z) <= x)

>>> variables(h)
['x', 'y', 'z']
          ]]></code>
          <parts>
            <part>
              <text><![CDATA[
Implement a function <code>truthtableXY(f)</code> that takes as its input a single function <code>f</code> (i.e., a Python function corresponding to a formula such as those you defined in <b>Problem #2</b> above). You may assume <code>f</code> takes two boolean arguments <code>x</code> and <code>y</code>. The function should print a truth table for <code>f</code>.
              ]]></text>
              <code hooks="Python">
>>> @def f(x,y): @return x @and y

>>> truthtableXY(f)
y      x      formula
@True   @True   @True
@True   @False  @False
@False  @True   @False
@False  @False  @False
              </code>
            </part>
            <part>
              <text><![CDATA[
Implement a <b>recursive</b> function <code>truthtable(f)</code> that takes as its first argument a single function <code>f</code> (i.e., a Python function corresponding to a formula). <b>The function <code>f</code> may take <i>any</i> non-zero quantity of arguments.</b> The function should print a truth table for <code>f</code>.
              ]]></text>
              <code hooks="Python"><![CDATA[
>>> @def h(x,y,z): @return (y @or x) @and (@not(z) <= x)

>>> truthtable(h)
x       y       z       formula
@True    @True    @True    @False
@True    @True    @False   @False
@True    @False   @True    @False
@True    @False   @False   @False
@False   @True    @True    @True
@False   @True    @False   @False
@False   @False   @True    @False
@False   @False   @False   @False
              ]]></code>
              <text><![CDATA[
Your <code>truthtable()</code> function should employ the <a href="#97f1ff31c4c24ebc88a3d96efb112225">recursive backtracking</a> approach, and can be organized as follows:
<ul>
  <li>the function should have a second parameter <code>values</code> with a default value of <code>[]</code>, which will be the list of values the function builds up and eventually passes to <code>f</code>;</li>
  <li>if the list <code>values</code> is empty, the function should print a row containing all the variable names (one column header per variable);</li>
  <li>if the list <code>values</code> is the same length as the list of variables of <code>f</code>, the function should print a row of values containing all the values in <code>values</code>, as well as the result of applying <code>f</code> to that list of values (use the <a href="#B.4"><b><code>*</code>-operator</b></a> to apply <code>f</code> to the list of arguments);</li>
  <li>if the list <code>values</code> is shorter than the list of variables of <code>f</code>, the function should make recursive calls to <code>truthtable()</code>, with approprate changes to the arguments of <code>truthtable()</code>.</li>
</ul>
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>rows(f)</code> that takes as its first argument a single function <code>f</code> (i.e., a Python function corresponding to a formula). The function should return the number of rows in the truth table for <code>f</code>.
              ]]></text>
              <code hooks="Python"><![CDATA[
>>> @def h(x,y,z): @return (y @or x) @and (@not(z) <= x)

>>> rows(h)
8
              ]]></code>
            </part>
          </parts>
        </problem>
        <problem>
          <text><![CDATA[
In this problem you will implement an algorithm for solving the maximum boolean satisfiability problem. You will then use it to solve a simple instance of the maximum boolean satisfiability problem. You may use the following helper function, which counts the number of <code>True</code> values in a list:
          ]]></text>
          <code hooks="Python">
@def count(values):
  @return @len([v @for v @in values @if v == @True])
          </code>
          <text><![CDATA[
The above function can be used as follows:
          ]]></text>
          <code hooks="Python"><![CDATA[
>>> count([@True, @False, @True, @False])
2
          ]]></code>
         <parts>
            <part>
              <text><![CDATA[
Implement a recursive function <code>solve(f)</code> that takes as its first argument a single function <code>f</code> (i.e., a Python function corresponding to a formula). The function <code>f</code> may take <i>any</i> non-zero quantity of arguments. The function <code>solve(f)</code> should return a list of values that satisfies <code>f</code> and has the largest possible number of <code>True</code> values (as many as any other list of values that satisfies <code>f</code>).
              ]]></text>
              <!--<code hooks="Python">

              </code>-->
            </part>
            <part>
              <text hooks="math"><![CDATA[
Suppose you need to transport some animals (a rhino, a lion, a zebra, a hyena, and a snake) across a river in a boat. Since certain animals are predators or may poison or step on each other, there are certain constraints in this situation that you want to follow, and you model these using boolean formulas:
<ul>
  <li>if a snake is in the boat, then the hyena is not in the boat;</li>
  <li>if a lion is in the boat, then the hyena is not in the boat;</li>
  <li>if a rhino is in the boat, then the snake is not in the boat;</li>
  <li>if a lion is in the boat, then the snake is not in the boat;</li>
  <li>if a lion is in the boat, then the zebra is not in the boat;</li>
  <li>if a snake is in the boat, then the zebra is not in the boat.</li>
</ul>
Define a formula <code>transport()</code> containing five variables (%[rhino]%, %[lion]%, %[zebra]%, %[hyena]%, and %[snake]%). If a variable corresponding to a particular animal is assigned the value <code>True</code>, this represents that the animal is in the boat. <b>The formula should capture all of the constraints.</b>
<br style="margin-bottom:8px;"/>
Define a variable <code>maximum</code> to be an integer that represents the largest number of animals that can be in the boat at the same time. <b>You must use the <code>solve()</code> function in your definition of <code>maximum</code>.</b>
              ]]></text>
            </part>
          </parts>            
        </problem>
      </problems>
    </assignment>
  </section>
  <section title="Set Theory and its Relationships to Boolean Algebra">
    <paragraph><![CDATA[
Set theory and boolean algebra were both derived from intuitive processes and techniques that humans developed for solving problems in their environment. Thus, both set theory and boolean algebra are languages for describing (in an <i>abstract</i> way that eliminates many of the concrete details) the same universal principles we observe in our environment. This also means that set theory and boolean algebra can be defined in terms of one another: it is possible to define boolean algebra using set theory, and it is possible to define set theory using boolean algebra. In this section, we will study and explore both directions of this relationship.
    ]]></paragraph>
    <subsection title="Sets, set operations, and their algebraic properties">
      <paragraph><![CDATA[
Sets are an intuitive mathematical concept that can capture the idea of a collection of distinct items. Since every item in a set must be distinct, there can be no duplicates. Thus, it is not a good way to represent collections containing various quantiities of each distinct item; it is more suitable for representing collections of more "abstract" things, like concepts.
      ]]></paragraph>
      <paragraph><![CDATA[
As with formulas, we will use sequences of certain symbols to describe sets. We define this symbolic language below.
      ]]></paragraph>
      <definition required="true" hooks="math" id="561c1438722c4edbb2fb052fe9d687df"><![CDATA[
The following table specifies various notations for sets, what they mean, and how they can be represented within the Python programming language.
<br/>
<table class="fig_table">
 <tr>
  <td><b>set notation</b></td>
  <td><b>name</td>
  <td><b>meaning</td>
  <td><b>example in<br/>Python</b></td>
 </tr>
 <tr> 
  <td>{@a, @b, @c}</td>
  <td><i>set</i></td>
  <td>a set containing<br/>four distcint elements<br/>@a, @b, and @c</td>
  <td><code>{'a', 'b', 'c'}</code></td>
 </tr>
 <tr> 
  <td>\emptyset</td>
  <td><i>empty set</i></td>
  <td>an empty set that<br/>contains no elements</td>
  <td><code>set()</code></td>
 </tr>
 <tr> 
  <td>%A \cup %B</td>
  <td><i>union of<br/>%A and %B</i></td>
  <td>the set containing all<br/>elements in %A and all<br/>elements in %B</td>
  <td><code>A.union(B)</code><br/><code>A | B</code></td>
 </tr>
 <tr> 
  <td>%A \cap %B</td>
  <td><i>intersection of<br/>%A and %B</i></td>
  <td>the set containing only<br/>elements that are both<br/>in %A and in %B</td>
  <td><code>A.intersection(B)</code><br/><code>A & B</code></td>
 </tr>
 <tr> 
  <td>%A %- %B</td>
  <td><i>set difference</i></td>
  <td>the set containing all<br/>elements in %A that are<br/><b>not</b> in %B</td>
  <td><code>A - B</code></td>
 </tr>
 <tr> 
  <td>%{^%A}%</td>
  <td><i>complement<br/>of %A</i></td>
  <td>the set containing only<br/>elements that are <b>not</b> in %A</td>
  <td><code>U - A</code></td>
 </tr>
 <tr>
  <td>\U</td>
  <td><i>universe</i></td>
  <td>the set containing<br/>all possible elements<br/>(depends on context)</td>
  <td><i>must be defined<br/>by user</i></td>
 </tr>
</table>
      ]]></definition>
      <paragraph hooks="math"><![CDATA[
Typically (but not always, so it is always a good idea to confirm this), all the set operations have the same level of precedence, and should be performed left-to-right (i.e., they are left-associative). For example:
\begin{eqnarray}
  %A \cup %B \cap %C \cup %D & = & ((%A \cup %B) \cap %C) \cup %D
\end{eqnarray}
      ]]></paragraph>
      <example required="true" hooks="math" id="2e07f738aa494a389ef533e8eaf5c85e"><![CDATA[
Determine what elements are contained in each of the following sets:
<ol style="list-style-type:lower-alpha; margin-left:-12px; line-height:30px;">
  <li>
\emptyset \cap {@a, @b, @c}
  </li>
  <li>
({@a, @b, @c} \cup {@c, @d, @e}) - {@c}
  </li>
  <li>
%{^{@a, @b, @c}}%  where \U = {@a, @b, @c, @d, @e, @f}
  </li>
  <li>
%{^{@a, @b, @c} \cap {@b, @d, @f}}%  where \U = {@a, @b, @c, @d, @e, @f}
  </li>
  <li>
%{^\U}% where \U = {@a, @b, @c, @d, @e, @f}
  </li>
  <li>
%{^%A}%  where %A = %{^{@d, @e, @f}}% and \U = {@a, @b, @c, @d, @e, @f}
  </li>
</ol>
      ]]></example>
      <fact required="true" hooks="math" id="a0b1c66107bf49ada80fa6092dedfa1f"><![CDATA[
The set operations have many algebraic properties. We list some of the ones we encounter frequently below:
\begin{eqnarray}
  %A \cup %B & = & %B \cup %A & %~ & (commutativity of \cup) \\
  (%A \cup %B) \cup %C & = & %A \cup (%B \cup %C) & %~ & (associativity of \cup) \\
  %A \cup \emptyset & = & %A & %~ & (identity of \cup) \\
  %A \cap %B & = & %B \cap %A & %~ & (commutativity of \cap) \\
  (%A \cap %B) \cap %C & = & %A \cap (%B \cap %C) & %~ & (associativity of \cap) \\
  %A \cap \U & = & %A & %~ & (identity of \cap) \\
  %A \cap (%B \cup %C) & = & (%A \cap %B) \cup (%A \cap %C) & %~ & (distributivity of \cap across \cup)
\end{eqnarray}
The \cup and \cap operations can be expressed in terms of one another with the help of the set complement operation:
\begin{eqnarray}
  %{^%A \cap %B}% & = & %{^%A}% \cup %{^%B}% & %~ & (<a href="http://en.wikipedia.org/wiki/De_Morgan's_laws">De Morgan's Law</a>)
\end{eqnarray}
      ]]></fact>
    </subsection>
    <subsection title="Sets of models">
      <paragraph hooks="math"><![CDATA[
In this section we introduce a way to interpret (or, equivalently, understand, represent, or think of the meaning of) formulas as sets, and particularly <i>sets of models</i>. For the purposes of this discussion, we assume that the number of variables that can appear in our formulas is finite and fixed (i.e., it never changes once we agree on what the variables are). Having a finite, fixed number of variables immediately puts an upper bound on the number of distinct <i>models</i> that can exist, because each model is just a distinct way to assign a value (i.e., \top or \bot) to every one of the variables.
      ]]></paragraph>
      <definition required="true" hooks="math" id="84e95e858e8e4f0396c9cb12b3bdbd63"><![CDATA[
Suppose that we have a collection of %k different models %m_1,...,%m_{%k} (remember that each model is an assignment of variables to values that looks something like {%x \mapsto \top, %y \mapsto \bot, ...}). Suppose also that each model satisfies some formula %f, so that we can write:
\begin{eqnarray}
  %m_1 & \models & %f \\
  %m_2 & \models & %f \\
  %m_3 & \models & %f \\
   & \vdots & \\
  %m_{%k-1} & \models & %f \\
  %m_{%k} & \models & %f
\end{eqnarray}
Then we say that the <i>set</i> of models {%m_1,...,%m_{%k}} <i>satisfies</i> %f, and we denote this using the following notation:
\begin{eqnarray}
  {%m_1,...,%m_{%k}} & \models & %f
\end{eqnarray}
      ]]></definition>
      <example required="true" hooks="math" id="f68ef53cd6884e5da9d93327c0b6de22"><![CDATA[
Suppose that we have only two variables: %x and %y. There are 2^2 = 4 distinct models if there are only two variables:
\begin{eqnarray}
  %m_1 & = & {%x \mapsto \top, %y \mapsto \top} \\
  %m_2 & = & {%x \mapsto \top, %y \mapsto \bot} \\
  %m_3 & = & {%x \mapsto \bot, %y \mapsto \top} \\
  %m_4 & = & {%x \mapsto \bot, %y \mapsto \bot}
\end{eqnarray}
Suppose we set our universe \U to be the set of models {%m_1, %m_2, %m_3, %m_4}. Then consider the following three formulas contianing %x and %y:
\begin{eqnarray}
  %f & \equiv & %x \vee %y \\
  %g & \equiv & %x \wedge %y \\
  %h & \equiv & %x \Leftrightarrow %y
\end{eqnarray}
Notice that %m_1, %m_2, and %m_3 all satisfy %f, but only %m_1 satisfies %g, and only %m_1 and %m_4 satisfy %h. We could write the following:
\begin{eqnarray}
  {%m_1, %m_2, %m_3} & \models & %x \vee %y \\
  {%m_1} & \models & %x \wedge %y \\
  {%m_1, %m_4} & \models & %x \Leftrightarrow %y
\end{eqnarray}
But this means that we could <i>interpret</i> %x \vee %y as the set of models {%m_1, %m_2, %m_3}, we could interpret %x \wedge %y as the set of models {%m_1}, and we could interpret %x \Leftrightarrow %y as the set of models {%m_1, %m_4}. In other words, each formula gives us a way to specify <i>which</i> models we want to include in a set.
      ]]></example>
      <!--<example required="true" hooks="math" id="f0cf988d896d44cd8cb20303fe209b2e"><![CDATA[

      ]]></example>-->
    </subsection>
    <subsection title="Set algebra of model sets and boolean algebra">
      <fact required="true" hooks="math" id="9e7a019d05154ba0b8e71ad59d57ad0a"><![CDATA[
Assume we are only working with models and formulas that contain a certain set of variables %x_1,...,%x_{%k}. Suppose we have two model sets %A and %B that satisfy the two formulas %f and %g, respectively. In other words:
\begin{eqnarray}
  %A & \models & %f \\
  %B & \models & %g
\end{eqnarray}
Then all of the following are true:
\begin{eqnarray}
  %A \cup %B & \models & %f \vee %g \\
  %A \cap %B & \models & %f \wedge %g \\
  %{^%A}% & \models & \neg %f
\end{eqnarray}
In other words:
<ul>
  <li>the union of two model sets satisfies the disjunction (<i>or</i>) of two corresponding formulas;</i>
  <li>the intersection of two model sets satisfies the conjunction (<i>and</i>) of two corresponding formulas;</i>
  <li>the complement of a model set satisfies the negation (<i>not</i>) of a corresponding formula.</i>
</ul>
      ]]></fact>
      <example required="true" id="9794908a9ba144cbbca796ebd917a9f4">
        <text hooks="math"><![CDATA[
Suppose we have the following sets of models:
\begin{eqnarray}
  %A & = & {{%x \mapsto \top, %y \mapsto \bot}, {%x \mapsto \bot, %y \mapsto \top}} \\
  %B & = & {{%x \mapsto \top, %y \mapsto \top}} 
\end{eqnarray}
Use %A, %B, and set operations (union, intersection, difference, and compelement, but <i>not</i> \emptyset or \U) to build the largest model set you can that satisfies each of the following formulas:
<ol style="list-style-type:lower-alpha; margin-left:-12px; line-height:30px;">
  <li>
%x \oplus %y
  </li>
  <li>
%x \wedge %y
  </li>
  <li>
\neg(%x \wedge %y)
  </li>
  <li>
%x
  </li>
  <li>
\bot
  </li>
  <li>
\top
  </li>
</ol>
        ]]></text>
        <solution hooks="math"><![CDATA[
There is exactly one possible set for each part, because there is always a largest set of models that satisfy the formula (if there were two largest sets that both satisfy a formula, they could be combined into a larger set that still satisfies the formula, since every model found in either set satisfies the formula). However, there may be more than one way to build that set using %A and %B. For each part below, we provide one or two of the ways to build that set.
<ol style="list-style-type:lower-alpha; margin-left:-12px; margin-top:0px;">
  <li>
The set %A satisfies %x \oplus %y.
  </li>
  <li>
The set %B satisfies %x \wedge %y.
  </li>
  <li>
The set %{^%B}% satisfies \neg(%x \wedge %y). We could also say %A \cup %{^%B}% satisfies it (since it refers to the same set of models).
  </li>
  <li>
The set can only contain models in which %x is assigned \top. However, there is no way to isolate the model in %A where %x \mapsto \top, so the best we can do is the set %B, which contains one of the two models in which %x is assigned \top.
  </li>
  <li>
No models can satisfy \bot, so we need to build the empty set. One example of an empty set is %A \cap %B.
  </li>
  <li>
All models satisfy \top, so we can obtain all the model sets using %A \cup %{^%A}%, or %B \cup %{^%B}%, among others.
  </li>
</ol>
        ]]></solution>
      </example>
      <example required="true" id="4c0a77440550429bbd24c730e18bf62b">
        <text hooks="math"><![CDATA[
Suppose we are considering formulas with two variables %x and %y, and we have the following sets of models:
\begin{eqnarray}
  %A & = & {{%x \mapsto \top, %y \mapsto \bot}, {%x \mapsto \bot, %y \mapsto \bot}} \\
  %B & = & {{%x \mapsto \top, %y \mapsto \top}} \\
  %C & = & {{%x \mapsto \top, %y \mapsto \bot}, {%x \mapsto \bot, %y \mapsto \top}}
\end{eqnarray}
Find a formula that corresponds to each of the following model sets.
<ol style="list-style-type:lower-alpha; margin-left:-12px; line-height:30px;">
  <li>
%B
  </li>
  <li>
%{^%B}%
  </li>
  <li>
%B \cup %C
  </li>
  <li>
%A \cup %B \cup %C
  </li>
  <li>
\emptyset
  </li>
  <li>
%{^%A \cap %C}% \cup %B
  </li>
</ol>
        ]]></text>
        <solution hooks="math"><![CDATA[
There are multiple solutions to each of the parts above. Below, we provide a few for each.
<ol style="list-style-type:lower-alpha; margin-left:-12px; margin-top:0px;">
  <li>
Since both %x and %y are \top, some formulas that are satisfied include %x \wedge %y, as well as (%x \Leftrightarrow \top) \wedge (%y \Leftrightarrow \top).
  </li>
  <li>
One formula is \neg(%x \wedge %y), and another is \neg(%x) \vee \neg(%y).
  </li>
  <li>
One formula is (%x \wedge %y) \vee (%x \oplus %y) because %x \wedge %y is satisfied by %B and %x \oplus %y is satisfied by %C. Another formula is %x \vee %y, since at least one of the two variables is always true in %B or %C.
  </li>
  <li>
Since %A \cup %B \cup %C contains all possible models, one formula that is satisfied is \top (all models satisfy \top because any assignment of values to variables results in \top being true). Another formula could be %x \vee %y \vee \neg(%x) \vee \neg(%y).
  </li>
  <li>
A formula that is always false is not satisfied by any models. This can include formulas such as \bot, as well as %x \Leftrightarrow (\neg(%x)) because a variable must always be equal to itself.
  </li>
  <li>
First, we can break down the notation to determine what set it describes:
\begin{eqnarray}
  %A \cap %C & = & {{%x \mapsto \top, %y \mapsto \bot}} \\
  %{^%A \cap %C}% & = & {{%x \mapsto \bot, %y \mapsto \top}, {%x \mapsto \top, %y \mapsto \top}, {%x \mapsto \bot, %y \mapsto \bot}} \\
  %{^%A \cap %C}% \cup %B & = & {{%x \mapsto \bot, %y \mapsto \top}, {%x \mapsto \top, %y \mapsto \top}, {%x \mapsto \bot, %y \mapsto \bot}}
\end{eqnarray}
At this point, we see the set only omits {%x \mapsto \top, %y \mapsto \bot}, so possible formulas include %x \Rightarrow %y, as well as \neg(%x) \vee %y.
  </li>
</ol>
        ]]></solution>
      </example>
      <fact required="true" hooks="math" id="8ce00ef2e3444949928e4d3d6b80b58b">
        <text><![CDATA[
Given a formula %f, there is a unique (i.e., single) largest set %S of models that satisfies %f.
        ]]></text>
        <paragraph><![CDATA[
To understand why, let us assume that this is not true. Then there is some formula %f for which there exist two sets %A and %B that are distinct, and yet we have:
\begin{eqnarray}
  %A & \models & %f \\
  %B & \models & %f \\
\end{eqnarray}
But because all the models in %A and %B satisfy %f, the above implies that:
\begin{eqnarray}
  %A \cup %B & \models & %f
\end{eqnarray}
Thus, either %A and %B are the same set, or %A \cup %B is larger than both of them, contradicting our assumption that %A and %B are each as large as any other set of models that satisfies %f.
        ]]></paragraph>
      </fact>
      <paragraph hooks="math"><![CDATA[
The <a href="#5b5e038221fb4c589a88692a761645a8">boolean satisfiability problem</a> is solved by finding <i>any one model</i> that can satisfy a formula, and the <a href="#6afb8e78ab444513990059ce160838fe">maximum boolean satisfiability problem</a> is solved by finding any model that satisfies a formula, and has as many variables mapped to \top as any other formula that satisfies a formula. What if we are interested in knowing the <i>number</i> of models that satisfy a formula?
      ]]></paragraph>
      <definition required="true" hooks="math" id="3f68d9df05b74802a58f84afd44cb855"><![CDATA[
The size of a set %S is the number of elements in that set, and is denoted using |%S|, where |%S| is always an integer that is 0 or greater.
      ]]></definition>
      <example required="true" hooks="math" id="98e414f845984b04b504fa45ea44d142"><![CDATA[
Below, we show the sizes of some sets:
\begin{eqnarray}
  |{@a, @b, @c, @d, @e}| & = & 5 \\
  |\emptyset| & = & 0
\end{eqnarray}
      ]]></example>
      <fact required="true" hooks="math" id="1db96c6ca531409d929a479f34374d97">
        <text><![CDATA[
Given a formula %f, there is a unique (i.e., single) largest set %S of models that satisfies %f.
        ]]></text>
        <paragraph><![CDATA[
To understand why, let us assume that this is not true. Then there is some formula %f for which there exist two sets %A and %B that are distinct, and yet we have:
\begin{eqnarray}
  %A & \models & %f \\
  %B & \models & %f \\
\end{eqnarray}
But because all the models in %A and %B satisfy %f, the above implies that:
\begin{eqnarray}
  %A \cup %B & \models & %f
\end{eqnarray}
Thus, either %A and %B are the same set, or %A \cup %B is larger than both of them, contradicting our assumption that %A and %B are each as large as any other set of models that satisfies %f.
        ]]></paragraph>
      </fact>
      <definition required="true" hooks="math" id="d47f419c427a4f378d8c05d7caf4c801"><![CDATA[
We define an instance of the <i>counting boolean satisfiability problem</i> as follows: given a formula %f, find the total number of models that satisfy %f. In other words, find the size |%S| of the unique largest set %S that satisfies the formula:
\begin{eqnarray}
  %S & \models & %f
\end{eqnarray}
      ]]></definition>
      <paragraph hooks="math"><![CDATA[
Knowing the number of models that satisfy a formula can be useful. It can allow us to get a better idea of how easy it might be to find a model that satisfies (i.e., solves) the formula, or how restrictive a formula is.
      ]]></paragraph>
      <fact required="true" hooks="math" id="6afd0eee519d4c4d9eeab086750b08e4"><![CDATA[
Suppose that we are working with formulas that can only contain any of the variables %x_1, ..., %x_{%k} (so there are %k distinct variables). Then, the size of the universe \U of models that may or may not satisfy a formula has size 2^{%k}:
\begin{eqnarray}
  |\U| & = & 2^{%k}
\end{eqnarray}
      ]]></fact>
      <paragraph hooks="math"><![CDATA[
Recall that for a given number of variables, we can determine the number of rows a truth table may have for a formula. We also know that the number of rows is equivalent to the largest possible set \U that may satisfy a formula for that number of variables. But what about the number of <i>formulas</i> that only use variables from a collection of variables %x_1, ..., %x_{%k}?
      ]]></paragraph>
      <paragraph hooks="math"><![CDATA[
The number of well-formed formulas is infinite, because we can always build a larger formula. But for a given collection of variables %x_1, ..., %x_{%k}, the number of distinct truth tables is finite. This is because all truth tables are of size 2^{%k}, so they are finite, and there is only a finite number of ways that we can assign a value to the formula for every one of those 2^{%k} rows in the truth table.
      ]]></paragraph>
      <example required="true" hooks="math" id="3c3c2d6c7a434691a2b8d20c46ea14db"><![CDATA[
Suppose we are working with the variables %x and %y. How many truth tables are there involving these two variables? We can list them all (there are two variables, so there are 2^2 = 4 rows in each table, and so there are 2<sup># rows</sup> = 2<sup>(2<sup>2</sup>)</sup> = 2<sup>2<sup>2</sup></sup> = 2^4 = 16 truth tables).
<table>
  <tr>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
    </td>
  </tr>
  <tr>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
    </td>
  </tr>
</table>
Notice that no matter what well-formed formula we assemble that uses the variables %x and %y, we can <i>always</i> evaluate that formula to determine its meaning for each of the 2^2 = 4 possible assignments of values to variables (i.e., models), and since the meaning of the formula must be either \top or \bot, we will in the end have one of the truth tables above.
      ]]></example>
      <paragraph hooks="math"><![CDATA[
How can we compute the number of truth tables for a given number of variables? Notice that each truth table corresponds to a particular set of models that satisfy the formula (each row for which the formula is \top corresponds to a model in the set of satisfying models).
      ]]></paragraph>
      <definition required="true" hooks="math" id="c54fe8559c3c4560bb2eb07742736fe0"><![CDATA[
Given a set %B, we say that %A is a <i>subset</i> of %B if every element in %A is also in %B. In other words, if %A - %B = \emptyset, or if %A \cap %B = %A, then %A is a subset of %B. We denote this as follows:
\begin{eqnarray}
  %A & \subset & %B
\end{eqnarray}
      ]]></definition>
      <example required="true" hooks="math" id="6ed49c59d3914eaa80ca0972f1da2d21"><![CDATA[
Below are some examples of subset relationships:
\begin{eqnarray}
  {@b, @c, @d} & \subset & {@a, @b, @c, @d, @e, @f} \\
  \emptyset & \subset & {@a, @b, @c, @d, @e, @f} \\
  \emptyset & \subset & \emptyset \\
  %A & \subset & %A \cup %B \\
  %A \cap %B & \subset & %A\\
  %A \cap %B & \subset & %B
\end{eqnarray}
      ]]></example>
      <definition required="true" hooks="math" id="803f22dc576b44fc89ec3e3199a87712"><![CDATA[
Given a set %S, the <i>power set</i> of %S, which we denote as \powerset(%S), is the <i>set of subsets</i> of %S. In other words, every possible subset of %S is inside the set \powerset(%S), and each element in \powerset(%S) is a set.
      ]]></definition>
      <fact required="true" hooks="math" id="b5f74e307d49416e9a1b4e8c3cb17d13"><![CDATA[
Given a set %S of size |%S|, the size of the powerset is denoted |\powerset(%S)|, where:
\begin{eqnarray}
  |\powerset(%S)| & = & 2<sup>|%S|</sup>
\end{eqnarray}
This is because each possible element inside %S is either in a subset, or it is not in a subset. Thus, since each of the |%S| elements have two possible states (in and out), there are 2 \cdot 2 \cdot ... \cdot 2 states in total (where we have |%S| factors of 2 in the product).
      ]]></fact>
      <example required="true" hooks="math" id="a676d303bc31495e94ed45b2d9b1e8ae"><![CDATA[
Below are some examples of power sets of specific sets:
\begin{eqnarray}
  \powerset({@a, @b, @c}) & = & {\emptyset, {@a}, {@b}, {@c}, {@a,@b}, {@b,@c}, {@a,@c}, {@a,@b,@c}} \\
  \powerset({@a, @b}) & = & {\emptyset, {@a}, {@b}, {@a,@b}} \\
  \powerset(\emptyset) & = & {\emptyset}
\end{eqnarray}
Notice that the empty set is a subset of the empty set, so the power set of the empty set is 2^0 = 1.
      ]]></example>
      <fact required="true" hooks="math" id="0a51dc20a5ad44f79e5e03e38a81f0f3"><![CDATA[
Suppose we are working with formulas that contain the variables %x_1, ..., %x_{%k}. Every truth table for these variables corresponds to a particular set of models (i.e., those that satisfy the formula and correspond to rows in the table for which the formula is \top). Every set of models must be a subset of the universe \U for this collection of variables. Thus, all the possible sets of models correspond exactly to the elements of \powerset(\U), the power set of the universe \U:
\begin{eqnarray}
  row in a truth table & %~ & <b>corresp. to</b> & %~ & a model (assignment of values to variables) \\
  all rows in a truth table & %~ & <b>corresp. to</b> & %~ & the universe of models \U \\
  a particular truth table & %~ & <b>corresp. to</b> & %~ & a set of models, subset of \U (rows for which formula is \top) \\
  set of all truth tables & %~ & <b>corresp. to</b> & %~ & set of all sets of models, power set of \U
\end{eqnarray}
Thus, the number of truth tables is exactly the size of \powerset(\U):
\begin{eqnarray}
  # truth tables & = & |\powerset(\U)| & = & 2<sup>|\U|</sup> & = & 2<sup># rows</sup> & = & 2<sup>(2^{%k})</sup> & = & 2<sup>2^{%k}</sup>.
\end{eqnarray}
      ]]></fact>
      <example required="true" hooks="math" id="cd9c822d816f40c896e331559114f02a"><![CDATA[
Suppose we are working with the variables %x and %y. Each possible truth table for these variables corresponds to a particular subset of the rows (i.e., the rows that have a value of \top in the formula column), and thus it corresponds to a particular subset of the universe. We can pair each truth table with the subset of the universe to which it corresponds.
<table>
  <tr>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \top, %y \mapsto \top},<br/>{%x \mapsto \top, %y \mapsto \bot},<br/>{%x \mapsto \bot, %y \mapsto \top},<br/>{%x \mapsto \bot, %y \mapsto \bot}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \top, %y \mapsto \top},<br/>{%x \mapsto \top, %y \mapsto \bot},<br/>{%x \mapsto \bot, %y \mapsto \top}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \top, %y \mapsto \top},<br/>{%x \mapsto \top, %y \mapsto \bot},<br/>{%x \mapsto \bot, %y \mapsto \bot}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \top, %y \mapsto \top},<br/>{%x \mapsto \top, %y \mapsto \bot}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \top, %y \mapsto \top},<br/>{%x \mapsto \bot, %y \mapsto \top},<br/>{%x \mapsto \bot, %y \mapsto \bot}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \top, %y \mapsto \top},<br/>{%x \mapsto \bot, %y \mapsto \top}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \top, %y \mapsto \top},<br/>{%x \mapsto \bot, %y \mapsto \bot}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\top</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \top, %y \mapsto \top}}</span>
    </td>
  </tr>
  <tr>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \top, %y \mapsto \bot},<br/>{%x \mapsto \bot, %y \mapsto \top},<br/>{%x \mapsto \bot, %y \mapsto \bot}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \top, %y \mapsto \bot},<br/>{%x \mapsto \bot, %y \mapsto \top}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \top, %y \mapsto \bot},<br/>{%x \mapsto \bot, %y \mapsto \bot}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \top, %y \mapsto \bot}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \bot, %y \mapsto \top},<br/>{%x \mapsto \bot, %y \mapsto \bot}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\top</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \bot, %y \mapsto \top}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\top</td></tr>
      </table>
      <span style="font-size:12px;">{{%x \mapsto \bot, %y \mapsto \bot}}</span>
    </td>
    <td>
      <table class="fig_table truthtable" style="font-size:8px;">
        <tr><td><b>%x</b></td><td><b>%y</b></td><td></td></tr>
        <tr><td>\top</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
        <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
      </table>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:12px;">\emptyset</span>
    </td>
  </tr>
</table>
      ]]></example>
      <example required="true" hooks="math" id="c5b9096fe8954e97897fe30414df14ba"><![CDATA[
Suppose we want to know the number of truth tables for the set of formulas that have up to 4 variables. We can compute it:
\begin{eqnarray}
  # truth tables & = & 2<sup># rows</sup> & = & 2<sup>(2^4)</sup> & = & 2<sup>2^4</sup> & = & 2<sup>16</sup> & = & 65536.
\end{eqnarray}
      ]]></example>
      <example required="true" hooks="math" id="5aa3dc1edbed4422b77ac051dff6f3b2">
        <text><![CDATA[
Suppose you are implementing or maintaining a small social networking application with five members: Alice, Bob, Carl, Dan, and Eve. For any given instance (i.e., session) of the application <i>running in a single browser window</i>, the following constraints must be satisfied:
<ul>
  <li>if Alice is logged in, Bob is visible and Dan is visible;</li>
  <li>if Bob is logged in, Alice is visible and Dan is visible;</li>
  <li>if Carl is logged in, Eve is visible;</li>
  <li>if Dan is logged in, Alice is visible and Bob is visible;</li>
  <li>if Eve is logged in, Carl is visible;</li>
  <li>only one person can be logged in at a time.</li>
</ul>
Answer each of the following.
        ]]></text>        
        <text><![CDATA[
<ol style="list-style-type:lower-alpha; margin-left:-12px; margin-top:0px;">
  <li>
How can we represent the above constraints using a formula? What is the formula?
  </li>
  <li>
How many distinct models should satisfy the formula? In other words, in how many rows in the truth table should the formula column contain \top?
  </li>
  <li>
Suppose you are running the server and database for this application, and the members are all allowed to either make themselves visible or not visible to one another. From your perspective, at any given time, any of the members might be logged in or logged out, and the visibility properties between the members might have different settings depending on their current preferences. The database keeps track of everything: whether each member is logged in, and what the visibility preferences are. How many different database configurations can exist?
  </li>
  <li>
The above constraints suggest a particular set of relationships between the members: Alice, Bob, and Dan are all friends, and Carl and Eve are friends with each other, but no one else is a friend with anyone else. Suppose we wanted to use a single variable to represent each pair-wise relationship between members. How many variables would we need?
  </li>
</ol>
        ]]></text>
        <solution hooks="math"><![CDATA[
We know that each user must be either logged in or not logged in, and each user must be either visible or not visible. Since there are five users and two states to track for each user, we will use 2 \cdot 5 variables: %[Alice logged in]%, %[Bob logged in]%, %[Carl logged in]%, %[Dan logged in]%, %[Eve logged in]%, %[Alice visible]%, %[Bob visible]%, %[Carl visible]%, %[Dan visible]%, and %[Eve visible]%. Thus, the size of our universe is 2<sup>10</sup> = 1024. We answer each part, with some discussion (there is sometimes more than one right answer).
<ol style="list-style-type:lower-alpha; margin-left:-12px; margin-top:10px;">
  <li>
How we represent the constraints using a formula depends on what the unspecified constraints might be. If we assume that anything that is not mentioned explicitly in the constraints should not be restricted, then the above constraints would allow for the possibility that everyone can be visible to, e.g., Alice, it is just <i>required</i> that Bob and Dan <i>must</i> be visible. Then, we can represent each of the first five constraints as follows using a formula:
<ul style="font-size:12px;">
  <li>%[Alice logged in]% \Rightarrow (%[Bob visible]% \wedge %[Dan visible]%)</li>
  <li>%[Bob logged in]% \Rightarrow (%[Alice visible]% \wedge %[Dan visible]%)</li>
  <li>%[Carl logged in]% \Rightarrow %[Eve visible]%</li>
  <li>%[Dan logged in]% \Rightarrow (%[Alice visible]% \wedge %[Bob visible]%)</li>
  <li>%[Eve logged in]% \Rightarrow %[Carl visible]%</li>
</ul>
On the other hand, this is not necessarily what the person who wrote the constraints meant. Maybe by saying "Bob and Dan are visible", the person implied that the others should not be visible. Then we would need to write the constraints as follows:
<ul style="font-size:12px;">
  <li>%[Alice logged in]% \Rightarrow (%[Bob visible]% \wedge \neg(%[Carl visible]%) \wedge %[Dan visible]% \wedge \neg(%[Eve visible]%))</li>
  <li>%[Bob logged in]% \Rightarrow (%[Alice visible]% \wedge \neg(%[Carl visible]%) \wedge %[Dan visible]% \wedge \neg(%[Eve visible]%))</li>
  <li>%[Carl logged in]% \Rightarrow (\neg(%[Alice visible]%) \wedge \neg(%[Bob visible]%) \wedge \neg(%[Dan visible]%) \wedge %[Eve visible]%)</li>
  <li>%[Dan logged in]% \Rightarrow (%[Alice visible]% \wedge %[Bob visible]% \wedge \neg(%[Carl visible]%) \wedge \neg(%[Eve visible]%))</li>
  <li>%[Eve logged in]% \Rightarrow (\neg(%[Alice visible]%) \wedge \neg(%[Bob visible]%) \wedge %[Carl visible]% \wedge \neg(%[Dan visible]%))</li>
</ul>
The only way to determine which of the above is the "correct" interpretation of the constraints written in English is to ask the original author of the constraints. If we imagine an application in which everyone can set their own privacy settings, we might imagine the first interpretation is more correct, because we want everyone to be able to make their profile public if they wish (e.g., Alice <i>must</i> be able to see her friends Bob and Dan, but she <i>might also</i> be able to see Eve if Eve made her profile public).
<br/><br/>
The last constraint is difficult to represent using only the well-formed formulas we have seen so far; we must do so by enumerating all the possibilities:
<ul style="font-size:12px;">
  <li>%[Alice logged in]% \Rightarrow (\neg(%[Bob logged in]%) \wedge \neg(%[Carl logged in]%) \wedge \neg(%[Dan logged in]%) \wedge \neg(%[Eve logged in]%))</li>
  <li>%[Bob logged in]% \Rightarrow (\neg(%[Alice logged in]%) \wedge \neg(%[Carl logged in]%) \wedge \neg(%[Dan logged in]%) \wedge \neg(%[Eve logged in]%))</li>
  <li>%[Carl logged in]% \Rightarrow (\neg(%[Alice logged in]%) \wedge \neg(%[Bob logged in]%) \wedge \neg(%[Dan logged in]%) \wedge \neg(%[Eve logged in]%))</li>
  <li>%[Dan logged in]% \Rightarrow (\neg(%[Alice logged in]%) \wedge \neg(%[Bob logged in]%) \wedge \neg(%[Carl logged in]%) \wedge \neg(%[Eve logged in]%))</li>
  <li>%[Eve logged in]% \Rightarrow (\neg(%[Alice logged in]%) \wedge \neg(%[Bob logged in]%) \wedge \neg(%[Carl logged in]%) \wedge \neg(%[Dan logged in]%))</li>
</ul>
  </li>
  <li>
If users are not allowed to make their profile public, the only possibilities are that one of the five users is logged in, or that no one is logged in. In that case, there are 5 + 1 = 6 possible rows in the truth table.
<br/><br/>
However, if users are allowed to set their profiles to be public or private, then computing the number of rows that satisfy the formula is more complicated (unless we do it automatically by simply submitting the appropriate formula to a solver for the <a href="#d47f419c427a4f378d8c05d7caf4c801">counting boolean satisfiability problem</a>).
<br/><br/>
If no one is logged in but everyone controls their own public profile privacy settings independently, then there are actually 2^5 = 32 possible combinations (there are five users, and the profile for each user is either public or private). Then, if any of the users are logged in, it must be that there are a number of valid configurations. For example, consider the case in which Alice is logged in: Carl and Eve may or may not be visible to Alice, and all of these are allowed:
<table class="fig_table truthtable">
  <tr>
    <td><b>%[Alice logged in]%</b></td>
    <td><b>%[Bob visible]%</b></td>
    <td><b>%[Carl visible]%</b></td>
    <td><b>%[Dan visible]%</b></td>
    <td><b>%[Eve visible]%</b></td>
  </tr>
  <tr><td>\top</td><td>\top</td><td>\bot</td><td>\top</td><td>\bot</td></tr>
  <tr><td>\top</td><td>\top</td><td>\top</td><td>\top</td><td>\bot</td></tr>
  <tr><td>\top</td><td>\top</td><td>\bot</td><td>\top</td><td>\top</td></tr>
  <tr><td>\top</td><td>\top</td><td>\top</td><td>\top</td><td>\top</td></tr>
</table>
Thus, for Alice, Bob, and Dan, there are 2^2 = 4 possible configurations of Carl's and Eve's profile privacy settings. From Carl and Eve's perspective, there are 2^3 = 8 possible configurations for Alice's, Bob's, and Dan's profile privacy settings. If we add up all the possibilities, we get:
\begin{eqnarray}
1 \cdot 2^5 + 3 \cdot 2^2 + 2 \cdot 2^3 & = & 32 + 12 + 16 \\
                                        & = & 60
\end{eqnarray}
Thus, there would be 60 rows in the table in which the column corresponding to the overall formula has the value \top.
  </li>
  <li>
This question is simply asking about the number of possible configurations of the ten variables we have considered, which is the same as the size of the universe. We know that in this problem, the size of the universe is 2<sup>10</sup> = 1024, so there are 1024 database configurations.
  </li>
  <li>
Since there are five users, we would have 4 + 3 + 2 + 1 = 10 pair-wise relationships: four relationships between Alice and the others, three more between Bob and the others (excluding his relationship with Alice, which we already counted), two more between Carl and the others (excluding relationships with Alice and Bob, which we already counted), and so on. Thus, we would need 10 variables if we had one variable for each pair-wise relationship.
  </li>
</ol>
        ]]></solution>
      </example>
    </subsection>
    <assignment title="Algebraic Properties of Formulas and Sets">
      <instructions><![CDATA[
In this assignment you will define a collection of Python variables and functions involving formulas and sets.
<br/><br/>
<b style="color:firebrick;">Your solution may not import any modules or employ any external library functions (unless the problem statement explicitly permits this).</b> The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
      ]]></instructions>
      <problems>
        <problem>
          <text hooks="math"><![CDATA[
For each of the following formula definitions, use <a href="#abd9f8f2a89b44018970dffc4732b77b">De Morgan's Law</a> and <a href="#2954df01e1e84156bbdfd8563217a66f">other algebraic properties</a> of boolean operators to convert it into an <a href="8d3f9ceeda1945c78cbb9c6a24c4f4ba">equivalent</a> formula that uses <b>only</b> \wedge and \neg, and no other operators. You only need to include the new versions of these definitions (that use only \wedge and \neg); you do not need to include the original definitions.
          ]]></text>
          <parts>
            <part>
              <code hooks="Python"><![CDATA[
@def oneA(x, y):
  @return (x @or (@not y))
              ]]></code>
            </part>
            <part>
              <code hooks="Python"><![CDATA[
@def oneB(x, y):
  @return ((@not x) <= (@not y))
              ]]></code>
            </part>
            <part>
              <code hooks="Python"><![CDATA[
@def oneC(x, y, z):
  @return ((x @and y) <= z)
              ]]></code>
            </part>
            <part>
              <code hooks="Python"><![CDATA[
@def oneD(w, x, y, z):
  @return (x @or y) @and (w @or z)
              ]]></code>
            </part>
            <part>
              <code hooks="Python"><![CDATA[
@def oneE(w, x, y, z):
  @return ((@not w) @or (@not x)) @or (@not (y @and z))
              ]]></code>
            </part>
            <part>
              <code hooks="Python"><![CDATA[
@def oneF(v, w, x, y, z):
  @return (((v <= (@not w)) @and x) <= (y <= z))
              ]]></code>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
Include the following set definitions in your Python file:
          ]]></text>
          <code hooks="Python"><![CDATA[
U = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'}
X = {'a', 'b', 'c'}
Y = {'c', 'd', 'e', 'f'}
Z = {'f', 'g'}
          ]]></code>
          <text hooks="math"><![CDATA[
For each of the following sets, use some number of set intersection, union, and difference operations to build the specified set using <code>U</code>, <code>X</code>, <code>Y</code>, and <code>Z</code>. You can <b>only use set operations and the four provided set variables</b>; you may <b>not</b> include any sets built using the brace notation <code>{ ... }</code>. There may be more than one correct solution to each part; you only need to supply one correct solution for each part.
          ]]></text>
          <parts>
            <part>
              <text><![CDATA[
Define a set <code>twoA</code> in your Python file that is equivalent to the set <code>{ 'f' }</code>.
              ]]></text>
              <code hooks="Python"><![CDATA[
twoA = ?
              ]]></code>
              <text><![CDATA[
Your definition cannot contain any explicit sets; it must use set operations to build the set <code>{ 'f' }</code> using  <code>U</code>,  <code>X</code>,  <code>Y</code>, <code>Z</code>. It should then be possible to test your definition as follows:
              ]]></text>
              <code hooks="Python"><![CDATA[
>>> twoA == { 'f' }
@True
              ]]></code>
            </part>
            <part>
              <text><![CDATA[
Define a set <code>twoB</code> in your Python file that is equivalent to the set <code>{'a', 'b'}</code>.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Define a set <code>twoC</code> in your Python file that is equivalent to the set <code>{'d', 'e'}</code>.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Define a set <code>twoD</code> in your Python file that is equivalent to the set <code>{'a', 'b', 'g', 'h'}</code>.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Define a set <code>twoE</code> in your Python file that is equivalent to the set <code>{'c', 'd', 'e', 'h'}</code>.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Define a set <code>twoF</code> in your Python file that is equivalent to the set <code>{'a', 'b', 'd', 'e', 'g', 'h'}</code>.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Define a set <code>twoG</code> in your Python file that is equivalent to the empty set <code>set()</code>.
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
For each of the following functions, use <a href="#a0b1c66107bf49ada80fa6092dedfa1f">De Morgan's Law</a> for sets to convert each function on sets into a function that returns the same result, but uses <b>only set union and set difference</b> operations, and <b>does not use set intersection</b>. You only need to include the new versions of these definitions (that use only set union and set <b style="color:green;">difference</b>); you do not need to include the original definitions. You may assume that <code>U</code> is always the set corresponding to the universe from which the elements in all the other sets are drawn.
          ]]></text>
          <parts>
            <part>
              <code hooks="Python"><![CDATA[
@def threeA(U, X, Y):
  @return X & Y
              ]]></code>
            </part>
            <part>
              <code hooks="Python"><![CDATA[
@def threeB(U, X, Y):
  @return (U - X) & (U - Y)
              ]]></code>
            </part>
            <part>
              <code hooks="Python"><![CDATA[
@def threeC(U, X, Y, Z):
  @return U - ((U - X) & (Y & Z))
              ]]></code>
            </part>
            <part>
              <code hooks="Python"><![CDATA[
@def threeD(U, X, Y, Z):
  @return (X & Y) | (Y & Z)
              ]]></code>
            </part>
          </parts>
        </problem>
        <problem>
          <text><![CDATA[
In this problem, you will implement Python functions for working with sets of models that satisfy particular formulas. You may include the following functions in your Python file: <code>variables(f)</code> returns the list of variables in the definition of a formula <code>f</code>, and <code>universe(n)</code> returns the set of all boolean value tuples of a certain length <code>n</code>.
          ]]></text>
          <code hooks="Python"><![CDATA[
@def variables(f):
    @return @list(f.__code__.co_varnames)
    
@def universe(n, values = @tuple()):
    @if @len(values) == n:
        @return {values}
    @else:
        @return universe(n, values + (@True,)) | universe(n, values + (@False,))
          ]]></code>
          <parts>
            <part>
              <text><![CDATA[
Implement a function <code>models(f)</code> that takes as its input a single function <code>f</code> (i.e., a Python function corresponding to a formula). The function should return a set containing all the tuples that satisfy <code>f</code>. <b>Hint:</b> you could define a local variable <code>M</code> to be an empty set, then use a <code>for</code> loop to look through all the formulas in an appropriate universe, and add each tuple that satisfies the formula to the set using <code>M.add()</code>.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>satisfies(S, f)</code> that takes as its input a set of tuples <code>S</code> and a function <code>f</code> that represents a formula. The function should return <code>True</code> if every tuple in <code>S</code> satisfies <code>f</code>, and <code>False</code>, otherwise.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>equivalent(f, g)</code> that takes as its inputs two functions <code>f</code> and <code>g</code> that represent formulas. If both formulas <b style="color:green;">take the same number of variables</b> and are <a href="#8d3f9ceeda1945c78cbb9c6a24c4f4ba">equivalent</a> (i.e., they have the same truth tables), then <code>equivalent(f, g)</code> should return <code>True</code>; otherwise, it should return <code>False</code>. <b>Hint</b>: use <code>models()</code> to write a one- or two-line definition for this function.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>both(f, g)</code> that takes as its inputs two functions <code>f</code> and <code>g</code> that represent formulas. It should return a set of tuples that contains only those tuples that satisfy <b>both</b> <code>f</code> <b>and</b> <code>g</code>. <b>Your implementation must be at most two lines.</b>
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>either(f, g)</code> that takes as its inputs two functions <code>f</code> and <code>g</code> that represent formulas. It should return a set of tuples that contains only those tuples that satisfy <b>either</b> <code>f</code> <b>or</b> <code>g</code>. <b>Your implementation must be at most two lines.</b>
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>neither(f, g)</code> that takes as its inputs two functions <code>f</code> and <code>g</code> that represent formulas. It should return a set of tuples that contains only those tuples that <b>do not</b> satisfy either <code>f</code> or <code>g</code>. <b>Your implementation must be at most two lines.</b>
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
Suppose that Alice, Bob, Carl, Dan, and Eve are all trying to schedule a one-hour appointment with you. They each have one of two possible times that they can meet:
<ul>
  <li>Alice can meet at 2 PM or 4 PM;</li>
  <li>Bob can meet at 1 PM or 3 PM;</li>
  <li>Carl can meet at 1 PM or 5 PM;</li>
  <li>Dan can meet at 2 PM or 3 PM;</li>
  <li>Eve can meet at 4 PM or 5 PM.</li>
</ul>
How many different schedules exist in which everyone is scheduled for an appointment, and no appointments overlap? Define a single variable <code>schedules</code> to be an integer that corresponds to the number of different schedules that will satisfy everyone:
          ]]></text>
          <code hooks="Python"><![CDATA[
schedules = ?   # Replace ? with appropriate function calls.
          ]]></code>
          <text hooks="math"><![CDATA[
<b>Hints:</b>
<ul>
  <li>define a new formula function that takes ten arguments (one for each possible time and person) and uses logical operations (you only need \oplus and \wedge) to determine whether a schedule is possible by returning <code>True</code> or <code>False</code>;</li>
  <li>by calling the functions you implemented in <b>Problem #4</b> above, compute the set of tuples that satisfies the formula you assembled and use this to determine the number of possible schedules.</li>
</ul>
          ]]></text>
        </problem>
      </problems>
    </assignment>
  </section>
  <section title="Logic and Formulas as Proofs">
    <paragraph><![CDATA[
In this section we will formally define the notion of a <i>proof</i> and a <i>theorem</i> (a.k.a., a fact, lemma, and so on) using concepts that have been introduced in previous sections. In particular, we will define these as a certain kind of formula: a formula that is <i>always</i> true. We will also introduce <i>logical</i> rules that allow us to build such formulas.
    ]]></paragraph>
    <subsection title="Building true formulas">
      <paragraph hooks="math"><![CDATA[
Suppose we are interested in building boolean formulas that are <i>always</i> true. In other words, we want to build formulas that are true under every possible assignment of the variables to truth values. We could say that such formulas %f are satisfied by the universe (i.e., %U \models %f); that is, these formulas can accurately model the properties of the universe of assignments.
      ]]></paragraph>
      <paragraph><![CDATA[
One naive, brute force strategy might be to begin listing all possible well-formed formulas, and then checking their truth tables. We could throw away formulas that are not always true, and keep those that are always true. However, this process would be extremely inefficient.
      ]]></paragraph>
      <paragraph hooks="math"><![CDATA[
Another approach might be to assemble a particular collection of <a href="#abd9f8f2a89b44018970dffc4732b77b">algebraic laws</a> that identify exactly those algebraic manipulations that can grow a formula but keep the formula's meaning <i>true</i>. In other words, we might want algebraic laws that explain to us how we can expand the simplest true formulas, such as \top, into larger and larger true formulas. We can then use these laws as building blocks to build larger and larger formulas that are always true, or even to more efficiently check if a particular formula is always true.
      ]]></paragraph>
      <paragraph><![CDATA[
We will call these particular algebraic rules for formulas <i>logical rules</i>, or just <i>logic</i>. We can begin by introducing two formulas that are always guaranteed to be true.
      ]]></paragraph>
      <fact required="true" hooks="math" id="00b5aa4aa094475e9ebaaf499df13806"><![CDATA[
The formula \top  is always true.
      ]]></fact>
      <fact required="true" hooks="math" id="ae2ced1a893748108285eb41075b824a"><![CDATA[
For any variable %x, the following formula is always true:
\begin{eqnarray}
  %x \Rightarrow %x
\end{eqnarray}
We can confirm this by consulting the truth table for this formula:
<table class="fig_table truthtable">
  <tr>
    <td><b>%x</b></td>
    <td><b>%x \Rightarrow %x</b></td>
  </tr>
  <tr><td>\top</td><td>\top</td></tr>
  <tr><td>\bot</td><td>\top</td></tr>
</table>
In fact, for any <i>formula</i> %f, the following formula must be true:
\begin{eqnarray}
  %f \Rightarrow %f
\end{eqnarray}
We can confirm this by observing that no matter what assignment of variables we consider, the meaning of %f is the same on both the left and right side of the \Rightarrow operator:
<table class="fig_table truthtable">
  <tr>
    <td><b>%x_1</b></td>
    <td><b>%x_2</b></td>
    <td><b>...</b></td>
    <td><b>%x_{%k}</b></td>
    <td><b>%f</b></td>
    <td><b>%f \Rightarrow %f</b></td>
  </tr>
  <tr><td>\top</td><td>\top</td><td>...</td><td>\top</td><td>?</td><td>\top</td></tr>
  <tr><td>\top</td><td>\top</td><td>...</td><td>\bot</td><td>?</td><td>\top</td></tr>
  <tr><td>\vdots</td><td>\vdots</td><td></td><td>\vdots</td><td>\vdots</td><td>\vdots</td></tr>
</table>
Regardless of what the meaning of %f is in a particular row, %f \Rightarrow %f will always be true.
      ]]></fact>
      <paragraph hooks="math"><![CDATA[
Once we have a way to build simple formulas that are always true, we can expand these into larger formulas that are always true by converting them into formulas using transformations that are guaranteed not to make a formula that is already true into a formula that is false. Note that any transformation of the formula into an <i><a href="8d3f9ceeda1945c78cbb9c6a24c4f4ba">equivalent</a></i> formula using algebraic laws satisfies this condition, but there are other transformations that can satisfy this condition, as well.
      ]]></paragraph>
      <definition required="true" hooks="math" id="746017a8f7794a1faa55259cbea101ff">
        <text><![CDATA[
A <i>logical inference rule</i> (or simply <i>inference rule</i>) is a generalization of the notion of an algebraic law for <a href="8d3f9ceeda1945c78cbb9c6a24c4f4ba">equivalent</a> formulas. Instead of requiring that the truth table for two formulas %f and %g must be the same, an inference rule only requires that for any row in the truth table for %f in which %f has a meaning of \top, the same row in the truth table for %g must also be true. An inference rule is written using the following notation:
        ]]></text>
        <inferences>
          <inference>
            <premises><![CDATA[%f]]></premises>
            <conclusion><![CDATA[%g]]></conclusion>
          </inference>
        </inferences>
        <text><![CDATA[
The formula %f above the line is called the <i>premise</i>, and the formula %g below the line is called the <i>conclusion</i>.
        ]]></text>
      </definition>
      <example required="true" hooks="math" id="455f548cda0e4c2a95fb40003567f49c">
        <text><![CDATA[
The following is a valid inference rule:
        ]]></text>
        <inferences>
          <inference>
            <premises><![CDATA[%x \wedge %y]]></premises>
            <conclusion><![CDATA[%x \vee %y]]></conclusion>
          </inference>
        </inferences>
        <text><![CDATA[
We can confirm it is a valid inference rule by consulting the truth tables for the two formulas:
<table class="fig_table truthtable">
  <tr>
    <td><b>%x</b></td>
    <td><b>%y</b></td>
    <td><b>%x \wedge %y</b></td>
    <td><b>%x \vee %y</b></td>
  </tr>
  <tr><td>\top</td><td>\top</td><td>\top</td><td>\top</td></tr>
  <tr><td>\top</td><td>\bot</td><td>\bot</td><td>\top</td></tr>
  <tr><td>\bot</td><td>\top</td><td>\bot</td><td>\top</td></tr>
  <tr><td>\bot</td><td>\bot</td><td>\bot</td><td>\bot</td></tr>
</table>
Notice that in some rows, if the premise has the meaning \bot, the conclusion has the meaning \top. But there is no row in which a premise has the meaning \top but the conclusion has the meaning \bot.
        ]]></text>
      </example>
      <paragraph hooks="math"><![CDATA[
Note that if an inference rule holds in both directions for two formulas, then the formulas are equivalent.
      ]]></paragraph>
      <fact required="true" hooks="math" id="bbef2f7d583f472ebce24a4991756e0f">
        <text><![CDATA[
Suppose that for two formulas %f and %g, both of the following inference rules are true:
        ]]></text>
        <inferences>
          <inference>
            <premises><![CDATA[%f]]></premises>
            <conclusion><![CDATA[%g]]></conclusion>
          </inference>
          <inference>
            <premises><![CDATA[%g]]></premises>
            <conclusion><![CDATA[%f]]></conclusion>
          </inference>
        </inferences>
        <text><![CDATA[
Then we can be certain that:
\begin{eqnarray}
  %f & \equiv & %g
\end{eqnarray}
This is because in any row in which %f has meaning \top, %g must also have the meaning \top (according to the first inference rule), and in any row in which %g has meaning \top, %f must have the meaning top (according to the second inference rule):
<table class="fig_table truthtable">
  <tr>
    <td><b>%f</b></td>
    <td><b>%g</b></td>
    <td></td>
  </tr>
  <tr><td>\top</td><td>\top</td><td>allowed by both inference rules</td></tr>
  <tr><td>\top</td><td><b style="color:firebrick;">\bot</b></td><td><b style="color:firebrick;">violates first inference rule</b></td></tr>
  <tr><td><b style="color:firebrick;">\bot</b></td><td>\top</td><td><b style="color:firebrick;">violates second inference rule</b></td></tr>
  <tr><td>\bot</td><td>\bot</td><td>allowed by both inference rules</td></tr>
</table>
        ]]></text>
      </fact>
      <paragraph hooks="math"><![CDATA[
We introduce inference rules in addition to equivalence of formulas because we are working with special formulas in this section: formulas that are always true. For these kinds of formulas, what seems like a weaker restriction imposed by an inference rule is actually <i>not</i> weaker.
      ]]></paragraph>
      <fact required="true" hooks="math" id="df132af12acf4713b83f762ef6b8a493">
        <text><![CDATA[
Suppose we have two formulas %f and %g and %f is always true, and suppose that the following inference rule holds:
        ]]></text>
        <inferences>
          <inference>
            <premises><![CDATA[%f]]></premises>
            <conclusion><![CDATA[%g]]></conclusion>
          </inference>
        </inferences>
        <text><![CDATA[
Then we can be certain that:
\begin{eqnarray}
  %f & \equiv & %g
\end{eqnarray}
This is because %f has the meaning \top in all of the rows in its truth table, which means %g must also have the meaning \top (according to the inference rule) in all of its rows:
<table class="fig_table truthtable">
  <tr>
    <td><b>%f</b></td>
    <td><b>%g</b></td>
    <td></td>
  </tr>
  <tr><td>\top</td><td>\top</td><td>allowed</td></tr>
  <tr><td>\top</td><td><b style="color:firebrick;">\bot</b></td><td><b style="color:firebrick;">violates the inference rule</b></td></tr>
  <tr><td><b style="color:firebrick;">\bot</b></td><td>\top</td><td><b style="color:firebrick;">violates condition that %f is always true</b></td></tr>
  <tr><td><b style="color:firebrick;">\bot</b></td><td>\bot</td><td><b style="color:firebrick;">violates condition that %f is always true</b></td></tr>
</table>
        ]]></text>
      </fact>
      <paragraph hooks="math"><![CDATA[
We can now introduce some additional logical inference rules that can be useful for converting formulas that are always true into larger formulas that are always true.
      ]]></paragraph>
      <!--Recall that two formulas are equivalent if they have exactly the same truth table. Thus, converting a formula for which the truth table has \top for every row into an equivalent formula will result in a new formula that also has a truth table with \top in every row.-->
      <fact required="true" hooks="math" id="a9831f10979c4c669cf393f765025977">
        <text><![CDATA[
For any three formulas %f, %g, and %h, we have:
        ]]></text>
        <inferences>
          <inference>
            <premises><![CDATA[%f \Rightarrow %h]]></premises>
            <conclusion><![CDATA[(%f \wedge %g) \Rightarrow %h]]></conclusion>
          </inference>
        </inferences>
        <text><![CDATA[
We can confirm this by consulting the truth table for the two formulas above:
<table class="fig_table truthtable">
  <tr>
    <td><b>%f</b></td>
    <td><b>%g</b></td>
    <td><b>%h</b></td>
    <td><b>%f \Rightarrow %h</b></td>
    <td><b>(%f \wedge %g) \Rightarrow %h</b></td>
  </tr>
  <tr style="color:green; font-weight:bold;"><td>\top</td><td>\top</td><td>\top</td><td>\top</td><td>\top</td></tr>
  <tr><td>\top</td><td>\top</td><td>\bot</td><td>\bot</td><td>\bot</td></tr>
  <tr style="color:green; font-weight:bold;"><td>\top</td><td>\bot</td><td>\top</td><td>\top</td><td>\top</td></tr>
  <tr><td>\top</td><td>\bot</td><td>\bot</td><td>\bot</td><td>\top</td></tr>
  <tr style="color:green; font-weight:bold;"><td>\bot</td><td>\top</td><td>\top</td><td>\top</td><td>\top</td></tr>
  <tr style="color:green; font-weight:bold;"><td>\bot</td><td>\top</td><td>\bot</td><td>\top</td><td>\top</td></tr>
  <tr style="color:green; font-weight:bold;"><td>\bot</td><td>\bot</td><td>\top</td><td>\top</td><td>\top</td></tr>
  <tr style="color:green; font-weight:bold;"><td>\bot</td><td>\bot</td><td>\bot</td><td>\top</td><td>\top</td></tr>
</table>
Note that because \wedge is <a href="#abd9f8f2a89b44018970dffc4732b77b">commutative</a>, this inference rule can be combined with algebraic laws to yield:
        ]]></text>
        <inferences>
          <inference>
            <premises><![CDATA[%f \Rightarrow %h]]></premises>
            <conclusion><![CDATA[(%g \wedge %f) \Rightarrow %h]]></conclusion>
          </inference>
        </inferences>
        <text><![CDATA[
Furthermore, because \wedge is <a href="#abd9f8f2a89b44018970dffc4732b77b">associative</a>, this inference rule means that we can always introduce any number of formulas into a conjunction on the left-hand side of the \Rightarrow operator:
        ]]></text>
        <inferences>
          <inference>
            <premises><![CDATA[(%f_1 \wedge ... \wedge %f_{%m}) \Rightarrow %h]]></premises>
            <conclusion><![CDATA[(%f_1 \wedge ... \wedge %f_{%m} \wedge %g_1 \wedge ... \wedge %g_{%n}) \Rightarrow %h]]></conclusion>
          </inference>
        </inferences>
      </fact>
      <example required="true" hooks="math" id="fab4cff77a1b425ea2d32260ab0c5b03">
        <text><![CDATA[
Suppose that we believe the following relationships to hold between a light source and the time:
<ul style="list-style-type:none;">
  <li>if the %[sun is in the sky]%, then %[it is daytime]%.</li>
</ul>
We can represent the relationship above using the formula:
\begin{eqnarray}
   %[sun is in the sky]% & \Rightarrow & %[it is daytime]%
\end{eqnarray}
Notice that if the meaning of the above formula is true, introducing additional constraints on the left-hand side of the \Rightarrow operator can never make new formula false. In some cases, it would just be additional, irrelevant information:
\begin{eqnarray}
   (%[giraffes are yellow]% \wedge %[sun is in the sky]%) & \Rightarrow & %[it is daytime]%
\end{eqnarray}
What if the additional formula is false? This does not matter, either, because then the left-hand side of the \Rightarrow operator is false, which automatically makes the whole formula true (i.e., \bot \Rightarrow \top and \bot \Rightarrow \bot are always true):
\begin{eqnarray}
   (%[giraffes are red]% \wedge %[sun is in the sky]%) & \Rightarrow & %[it is daytime]%
\end{eqnarray}
This holds even in the following extreme example, where the left-hand side becomes contradictory because of what we introduce:
\begin{eqnarray}
   (\neg(%[sun is in the sky]%) \wedge %[sun is in the sky]%) & \Rightarrow & %[it is daytime]%
\end{eqnarray}
        ]]></text>
      </example>
      <fact required="true" hooks="math" id="88a7b2dffd2e4e82af39f39a5e4ab48b">
        <text><![CDATA[
For any three formulas %f, %g, and %h, we have:
\begin{eqnarray}
   (%f \wedge %g) \Rightarrow %h %~ & \equiv & %~ (%f \wedge %g) \Rightarrow (%h \wedge %g)
\end{eqnarray}
In the form of inference rules, this would be:
        ]]></text>
        <inferences>
          <inference>
            <premises><![CDATA[(%f \wedge %g) \Rightarrow %h]]></premises>
            <conclusion><![CDATA[(%f \wedge %g) \Rightarrow (%h \wedge %g)]]></conclusion>
          </inference>
          <inference>
            <premises><![CDATA[(%f \wedge %g) \Rightarrow (%h \wedge %g)]]></premises>
            <conclusion><![CDATA[(%f \wedge %g) \Rightarrow %h]]></conclusion>
          </inference>
        </inferences>
        <text><![CDATA[
We can confirm this by consulting the truth table for the two formulas above:
<table class="fig_table truthtable">
  <tr>
    <td><b>%f</b></td>
    <td><b>%g</b></td>
    <td><b>%h</b></td>
    <td><b>(%f \wedge %g) \Rightarrow %h</b></td>
    <td><b>(%f \wedge %g) \Rightarrow (%h \wedge %g)</b></td>
  </tr>
  <tr><td>\top</td><td>\top</td><td>\top</td><td>\top</td><td>\top</td></tr>
  <tr><td>\top</td><td>\top</td><td>\bot</td><td>\bot</td><td>\bot</td></tr>
  <tr><td>\top</td><td>\bot</td><td>\top</td><td>\top</td><td>\top</td></tr>
  <tr><td>\top</td><td>\bot</td><td>\bot</td><td>\top</td><td>\top</td></tr>
  <tr><td>\bot</td><td>\top</td><td>\top</td><td>\top</td><td>\top</td></tr>
  <tr><td>\bot</td><td>\top</td><td>\bot</td><td>\top</td><td>\top</td></tr>
  <tr><td>\bot</td><td>\bot</td><td>\top</td><td>\top</td><td>\top</td></tr>
  <tr><td>\bot</td><td>\bot</td><td>\bot</td><td>\top</td><td>\top</td></tr>
</table>
Intuitively, this means that as long as a subformula appears on the left-hand side of the \Rightarrow operator, we are free to remove or add it to the right-hand side of the \Rightarrow operator. In other words, "we can always conclude that what we assumed is true, and we are also free to remove that conclusion".
        ]]></text>
      </fact>
      <example required="true" hooks="math" id="ab5f308cef944c1bb98cb83820da697f">
        <text><![CDATA[
Suppose that we believe the following relationships to hold between a light source and the time:
\begin{eqnarray}
   (%[sun is in the sky]% \Rightarrow %[it is daytime]%) \wedge %[sun is in the sky]% & \Rightarrow & %[it is daytime]%
\end{eqnarray}
Then we can add the fact that the sun is in the sky on the right-hand side of the outermost \Rightarrow operator without changing the meaning of the formula:
\begin{eqnarray}
   (%[sun is in the sky]% \Rightarrow %[it is daytime]%) \wedge %[sun is in the sky]% & \Rightarrow & %[it is daytime]% \wedge %[sun is in the sky]%
\end{eqnarray}
        ]]></text>
      </example>
      <fact  title="modus ponens" required="true" hooks="math" id="e534a612329d40999f89b656270c704c">
        <text><![CDATA[
For any two formulas %f and %g, we have:
        ]]></text>
        <inferences>
          <inference>
            <premises><![CDATA[(%f \Rightarrow %g) \wedge %f]]></premises>
            <conclusion><![CDATA[(%f \Rightarrow %g) \wedge %f \wedge %g]]></conclusion>
          </inference>
        </inferences>
        <text><![CDATA[
The above can be simplified further into either or both of the following:
        ]]></text>
        <inferences>
          <inference>
            <premises><![CDATA[(%f \Rightarrow %g) \wedge %f]]></premises>
            <conclusion><![CDATA[%f \wedge %g]]></conclusion>
          </inference>
          <inference>
            <premises><![CDATA[(%f \Rightarrow %g) \wedge %f]]></premises>
            <conclusion><![CDATA[%g]]></conclusion>
          </inference>
        </inferences>
        <text><![CDATA[
We can confirm this by consulting the truth table for the two formulas above:
<table class="fig_table truthtable">
  <tr>
    <td><b>%f</b></td>
    <td><b>%g</b></td>
    <td><b>(%f \Rightarrow %g) \wedge %f</b></td>
    <td><b>(%f \Rightarrow %g) \wedge %f \wedge %g</b></td>
    <td><b>%f \wedge %g</b></td>
    <td><b>%g</b> (as conclusion)</td>
  </tr>
  <tr style="color:green; font-weight:bold;"><td>\top</td><td>\top</td><td>\top</td><td>\top</td><td>\top</td><td>\top</td></tr>
  <tr><td>\top</td><td>\bot</td><td>\bot</td><td>\bot</td><td>\bot</td><td>\bot</td></tr>
  <tr><td>\bot</td><td>\top</td><td>\bot</td><td>\bot</td><td>\bot</td><td>\top</td></tr>
  <tr><td>\bot</td><td>\bot</td><td>\bot</td><td>\bot</td><td>\bot</td><td>\bot</td></tr>
</table>
In fact, after inspecting the truth table, we may notice that in this case, we can make a more restrictive claim:
\begin{eqnarray}
  (%f \Rightarrow %g) \wedge %f & \equiv & (%f \Rightarrow %g) \wedge %f \wedge %g & \equiv & %f \wedge %g
\end{eqnarray}
        ]]></text>
      </fact>
      <example required="true" hooks="math" id="a671232550f449d69410a854aaca527a">
        <text><![CDATA[
Suppose that we believe the following relationships to hold between a light source and the time:
<ul style="list-style-type:none;">
  <li>if the %[sun is in the sky]%, then %[it is daytime]%.</li>
</ul>
Then we intuitively know that if %[sun is in the sky]%, it must be daytime. The <a href="#e534a612329d40999f89b656270c704c">modus ponens</a> inference rule captures this intuition (we introduce wider in this instance spacing for legibility):
<br/><br/>
        ]]></text>
        <inferences>
          <inference>
            <premises><![CDATA[(%[sun is in the sky]% \Rightarrow %[it is daytime]%) \wedge %[sun is in the sky]%<br/>]]></premises>
            <conclusion><![CDATA[<br/>(%[sun is in the sky]% \Rightarrow %[it is daytime]%) \wedge %[sun is in the sky]% \wedge <b style="color:firebrick;">%[it is daytime]%</b>]]></conclusion>
          </inference>
        </inferences>
        <text><![CDATA[
<br/>
Below are the variants of the rule with more concise conclusions:
        ]]></text>
        <inferences>
          <inference>
            <premises><![CDATA[(%[sun is in the sky]% \Rightarrow %[it is daytime]%) \wedge %[sun is in the sky]%]]></premises>
            <conclusion><![CDATA[%[sun is in the sky]% \wedge <b style="color:firebrick;">%[it is daytime]%</b>]]></conclusion>
          </inference>
          <inference>
            <premises><![CDATA[(%[sun is in the sky]% \Rightarrow %[it is daytime]%) \wedge %[sun is in the sky]%]]></premises>
            <conclusion><![CDATA[<b style="color:firebrick;">%[it is daytime]%</b>]]></conclusion>
          </inference>
        </inferences>
      </example>
      <example required="true" hooks="math" id="4adc40c197a14973a323e2a49ff9b4d8">
        <text><![CDATA[
Suppose that we believe the following relationships to hold between a light sensor, a light source, and the time:
<ul>
  <li>if the %[light sensor is activated]%, the %[sun is in the sky]%;</li>
  <li>if the %[sun is in the sky]%, then %[it is daytime]%.</li>
</ul>
We can represent the two relationships above using two formulas:
\begin{eqnarray}
   %[sensor]% & \Rightarrow & %[sun]% \\
   %[sun]% & \Rightarrow & %[daytime]%
\end{eqnarray}
We can use the facts we introduced in this subsection to build a formula that is always true, no matter what values we assign to the three variables in this formula. We can start with a formula that must always be true:
\begin{eqnarray}
   %[daytime]% & \Rightarrow & %[daytime]%
\end{eqnarray}
Using a <a href="#a9831f10979c4c669cf393f765025977">known fact</a>, we can introduce our two assumptions about the world into our formula, as well as %[sun]%, all on the left-hand side of the \Rightarrow operator:
\begin{eqnarray}
   ((%[sensor]% \Rightarrow %[sun]%) \wedge (%[sun]% \Rightarrow %[daytime]%) \wedge %[sun]% \wedge %[daytime]%) & \Rightarrow & %[daytime]%
\end{eqnarray}
<a href="#e534a612329d40999f89b656270c704c">Modus ponens</a> and associativity of \wedge tell us that we can simplify a subformula in the above:
\begin{eqnarray}
   (%[sun]% \Rightarrow %[daytime]%) \wedge %[sun]% \wedge %[daytime]% & \equiv & (%[sun]% \Rightarrow %[daytime]%) \wedge %[sun]%
\end{eqnarray}
Then we have the following formula, which is still always true:
\begin{eqnarray}
   ((%[sensor]% \Rightarrow %[sun]%) \wedge (%[sun]% \Rightarrow %[daytime]%) \wedge %[sun]%) & \Rightarrow & %[daytime]%
\end{eqnarray}
Using a <a href="#a9831f10979c4c669cf393f765025977">fact</a> once more, we can introduce one more subformula on the left-hand side of the \Rightarrow operator:
\begin{eqnarray}
   ((%[sensor]% \Rightarrow %[sun]%) \wedge %[sensor]% \wedge %[sun]% \wedge (%[sun]% \Rightarrow %[daytime]%)) & \Rightarrow & %[daytime]%
\end{eqnarray}
Using <a href="#e534a612329d40999f89b656270c704c">modus ponens</a> and associativity of \wedge once again, we get:
\begin{eqnarray}
   ((%[sensor]% \Rightarrow %[sun]%) \wedge (%[sun]% \Rightarrow %[daytime]%) \wedge %[sensor]%) & \Rightarrow & %[daytime]%
\end{eqnarray}
We have now built a formula that is still always true, but it expresses a relationship that is not as direct. In English, the above formula says: "given our two assumptions about the relationship between the light sensor, the sun, and the time of day, <b>if the sensor is activated, it must be daytime</b>". This formula is always true; there is no condition under which it can be false. This formula can be called a <i>theorem</i>. We can confirm this by building the truth table:
<table class="fig_table truthtable">
  <tr>
    <td><b>%[sensor]%</b></td>
    <td><b>%[sun]%</b></td>
    <td><b>%[daytime]%</b></td>
    <td><b>((%[sensor]% \Rightarrow %[sun]%) \wedge (%[sun]% \Rightarrow %[daytime]%) \wedge %[sensor]%) \Rightarrow %[daytime]%</b></td>
  </tr>
  <tr><td>\top</td><td>\top</td><td>\top</td><td>\top</td></tr>
  <tr><td>\top</td><td>\top</td><td>\bot</td><td>\top</td></tr>
  <tr><td>\top</td><td>\bot</td><td>\top</td><td>\top</td></tr>
  <tr><td>\top</td><td>\bot</td><td>\bot</td><td>\top</td></tr>
  <tr><td>\bot</td><td>\top</td><td>\top</td><td>\top</td></tr>
  <tr><td>\bot</td><td>\top</td><td>\bot</td><td>\top</td></tr>
  <tr><td>\bot</td><td>\bot</td><td>\top</td><td>\top</td></tr>
  <tr><td>\bot</td><td>\bot</td><td>\bot</td><td>\top</td></tr>
</table>
Notice that in the rows where %[daytime]% is true, the overall formula is true, as expected. If %[daytime]% is false, then either %[sensor]% does not imply %[sun]%, or %[sun]% does not imply %[daytime]%, so the left-hand side of the \Rightarrow operator is false, making the overall formula true.
        ]]></text>
      </example>
      <paragraph hooks="math"><![CDATA[
In the example above, we used inference rules to ensure that the formula we were constructing would always be true. However, our approach might seem "backwards" in that particular example because the order of the transformations we performed on the formula do not correspond to the order in which we might intuitively reason about the relationships being modeled. Furthermore, copying the entire formula at every stop is burdensome. To address this, we will need to use a slightly different notation that can keep track of how our formula grows without requiring that we copy the entire formula over each time.
      ]]></paragraph>
    </subsection>
    <subsection title="Proofs and theorems">
      <paragraph hooks="math"><![CDATA[
In the previous subsection, we saw that proofs and theorems are both formulas. The distinction between a <i>proof</i> and a <i>theorem</i> is that it is possible to efficiently verify that a proof is indeed always true, while it may not be possible to verify a theorem is true without building the entire truth table for it (i.e., solving the <a href="#d47f419c427a4f378d8c05d7caf4c801">counting boolean satisfiability problem</a> and confirming that the total count is equal to the size of the universe).
      ]]></paragraph>
      <paragraph hooks="math"><![CDATA[
We will introduce a slightly different notation for formulas that are proofs. This notation will make it easier to think of proofs as something we can "build" in a step-by-step manner.
      ]]></paragraph>
      <definition required="true" id="4c6cc4b3d9d543f4a4287e147123971a">
        <text hooks="math"><![CDATA[
A <i>proof</i> is a well-formed formula written as a vertical list of subformulas %f_1,...,%f_{%k} where that looks as follows:
\begin{eqnarray}
%f_1 \\
%f_2 \\
 \vdots \\
%f_{%k}
\end{eqnarray}
This notation is equivalent to the following notations (note that these are all algebraically equivalent):
\begin{eqnarray}
(%f_1 \wedge %f_2 \wedge ... \wedge %f_{%k-1}) & \Rightarrow & %f_{%k} \\
%f_1 \Rightarrow (%f_2 \Rightarrow (%f_3 \Rightarrow ( ... ( %f_{%k-1} & \Rightarrow & %f_{%k}) ... )))
\end{eqnarray}
If the above formula is always true (i.e., all rows in its truth table have the value \top in the column corresponding to the overall formula), then we say the sequence of formulas constitutes a <i>valid proof</i>.
        ]]></text>
        <paragraph hooks="math"><![CDATA[
Typically, in a proof sequence %f_1,...,%f_{%k}, it is required that after some point, each subformula %f_{%j} must be derived using a simple inference rule from the formulas %f_1, ..., %f<sub>%j-1</sub> that come before it. Effectively, this all means that the following formulas must <i>also</i> all be true. For example, the following might be the case for a proof:
\begin{eqnarray}
%f_1 & \Rightarrow & %f_2 \\
(%f_1 \wedge %f_2) & \Rightarrow & %f_3 \\
(%f_1 \wedge %f_2 \wedge %f_3) & \Rightarrow & %f_4 \\
& \vdots & \\
(%f_1 \wedge %f_2 \wedge ... \wedge %f_{%k-1}) & \Rightarrow & %f_{%k}
\end{eqnarray}
 Sometimes, this is restricted even further: every %f_{%j} must either be exactly the same as some previous %f_{%i} where %i < %j, or it must be the direct conclusion of an inference rule for which the premises are the one, two, or three preceding formulas %f<sub>%j-1</sub>, %f<sub>%j-2</sub>, and %f<sub>%j-3</sub>. Effectively, this means all the following formulas might also be true:
 \begin{eqnarray}
(%f_1 \wedge %f_2) & \Rightarrow & %f_3 \\
(%f_2 \wedge %f_3) & \Rightarrow & %f_4 \\
(%f_3 \wedge %f_4) & \Rightarrow & %f_5 \\
& \vdots & \\
(%f<sub>%k-2</sub> \wedge %f_{%k-1}) & \Rightarrow & %f_{%k}
\end{eqnarray}
If either of the above collections of formulas are true, we can be certain the proof is <i>efficiently verifiable</i>.
        ]]></paragraph>
      </definition>
      <paragraph hooks="math"><![CDATA[
To see how each "subsequence" of formulas can correspond to a true formula in this way, we can consider the following. Suppose we have formula %f, %g, and %h, and we are sure that the following is true (e.g., due to modus ponens):
\begin{eqnarray}
%f \wedge %g & \equiv & (%f \wedge %g) \wedge %h
\end{eqnarray}
The following series of logical and algebraic manipulations ensures the formula being manipulated (found on the first line) remains true all the way to the end:
\begin{eqnarray}
%f & \Rightarrow & %g \\
%f <b style="color:firebrick;">\wedge %g</b> & \Rightarrow & %g & %~ & using & %~ & <a href="#a9831f10979c4c669cf393f765025977">a known fact</a> \\
<b style="color:firebrick;">(%f \wedge %g) \wedge %h</b> & \Rightarrow & %g & %~ & because & %~ & %f \wedge %g \equiv (%f \wedge %g) \wedge %h\\
(%f \wedge %g) \wedge %h & \Rightarrow & %g <b style="color:firebrick;">\wedge %h</b> & %~ & using & %~ & <a href="#88a7b2dffd2e4e82af39f39a5e4ab48b">a known fact</a> \\
(%f \wedge %g) \wedge %h & \Rightarrow & <b style="color:firebrick;">%h</b> & %~ & using & %~ & associativity of \wedge and <a href="#88a7b2dffd2e4e82af39f39a5e4ab48b">a known fact</a> \\
<b style="color:firebrick;">%f \wedge %g</b> & \Rightarrow & %h & %~ & because & %~ & %f \wedge %g \equiv (%f \wedge %g) \wedge %h
\end{eqnarray}
Notice that we can summarize this as follows in English: "if %f and %g can be used to derive %h, then the proof %f \Rightarrow %g can be extended into the proof %f \wedge %g \Rightarrow %h".
      ]]></paragraph>
      <definition required="true" id="e32e6d5608884d66bc70a1c2f2067f72">
        <text hooks="math"><![CDATA[
An <i>axiom</i> is any subformula within a proof that we <i>assume</i> to be true. In other words, we do not require that the axiom is always true. For example, suppose we have three axioms %a_1, %a_2, and %a_3 in the following proof:
\begin{eqnarray}
%a_1 \\
%a_2 \\
%a_3 \\
%f_1 \\
%f_2 \\
 \vdots \\
%f_{%k}
\end{eqnarray}
This means that we do not require that %a_1, %a_2, or %a_3 must always be true; they will only ever appear on the left-hand side of the \Rightarrow operator. All the following would be required to be true, however:
\begin{eqnarray}
%a_1 \wedge %a_2 \wedge %a_3 & \Rightarrow & %f_1 \\
(%a_1 \wedge %a_2 \wedge %a_3 \wedge %f_1) & \Rightarrow & %f_2 \\
(%a_1 \wedge %a_2 \wedge %a_3 \wedge %f_1 \wedge %f_2) & \Rightarrow & %f_3 \\
& \vdots & \\
(%a_1 \wedge %a_2 \wedge %a_3  %f_1 \wedge %f_2 \wedge ... \wedge %f_{%k-1}) & \Rightarrow & %f_{%k}
\end{eqnarray}
Notice that because %a_1, %a_2, and %a_3 always appear on the left-hand side of \Rightarrow, they do not necessarily need to always be true. If they are false, then all of the above formulas are true, because \bot \Rightarrow \top is always true.
        ]]></text>
      </definition>
      <example required="true" id="e6b10fd86b08477893c79e90f4e454fb">
        <text hooks="math"><![CDATA[
Suppose we have the following axioms governing several components on a Mars rover:
\begin{eqnarray}
  %[light sensor]% & \Rightarrow & %[sun is visible]% \\
  %[sun is visible]% & \Rightarrow & %[battery charging]% \\
  %[battery charging]% & \Rightarrow & %[communications work]% \\
  %[battery charging]% & \Rightarrow & %[motors work]% \\
  %[motors work]% & \Rightarrow & %[antenna can turn]% \\
  ((%[antenna can turn]% \wedge %[communications work]%) & \Rightarrow & %[can call Earth]%)
\end{eqnarray}
Because these are axioms, we will assume they are always true and will not require that they be proven. Equivalently, we can say we simply will ignore any rows in a truth table in which any of the above are false.
        ]]></text>
        <paragraph hooks="math"><![CDATA[
Suppose we encode all of the above axioms within a single formula %a (that is, %f is a conjunction of all the axioms). Then we can begin to assemble some simple proofs.
\begin{eqnarray}
%a \\
%[light sensor]% \\
%[light sensor]%
\end{eqnarray}
The above is a simple proof corresponding to the formula (%a \wedge %[light sensor]%) \Rightarrow %[light sensor]%. It is true because of <a href="#ae2ced1a893748108285eb41075b824a">this fact</a> and <a href="#a9831f10979c4c669cf393f765025977">this fact</a>. We can keep adding more to the proof:
\begin{eqnarray}
%a & %~ & axioms (no proof necessary, assumed to be true) \\
%[light sensor]% & %~ & \\
%[light sensor]% \Rightarrow %[sun is visible]% & %~ & exactly the same as one of the axioms \\
%[sun is visible]% & %~ & by <a href="#e534a612329d40999f89b656270c704c">modus ponens</a> of the two subformulas immediately above \\
%[sun is visible]% \Rightarrow %[battery charging]% & %~ & exactly the same as one of the axioms \\
%[battery charging]% & %~ & by <a href="#e534a612329d40999f89b656270c704c">modus ponens</a> of the two subformulas immediately above \\
\end{eqnarray}
The above, slightly longer proof represents a formula that is always true. We note that each formula along the way (i.e., each subsequence of steps in the list) is also a true formula:
\begin{eqnarray}
& %~ & %a \wedge %[sensor]% %~ \Rightarrow %~ (%[sensor]% \Rightarrow %[sun]%) \\
& %~ & %a \wedge %[sensor]% \wedge (%[sensor]% \Rightarrow %[sun]%) %~ \Rightarrow %~ %[sun]% \\
& %~ & %a \wedge %[sensor]% \wedge (%[sensor]% \Rightarrow %[sun]%) \wedge %[sun]% %~ \Rightarrow %~ (%[sun]% \Rightarrow %[battery]%) \\
& %~ & %a \wedge %[sensor]% \wedge (%[sensor]% \Rightarrow %[sun]%) \wedge %[sun]% \wedge (%[sun]% \Rightarrow  %[battery]%) %~ \Rightarrow %~ %[battery]%
\end{eqnarray}
What is interesting about such proofs is that we can then use the equivalence version of modus ponens (i.e., (%f \Rightarrow %g) \wedge %f \wedge %g \equiv (%f \Rightarrow %g) \wedge %f) along with the fact that a lot of things repeat (i.e., %f \wedge %f is equivalent to %f) to get rid of steps while keeping the formula true. Suppose we have the following very long proof:
\begin{eqnarray}
%a & %~ & axioms (no proof necessary, assumed to be true) \\
%[light sensor]% & %~ & \\
%[light sensor]% \Rightarrow %[sun is visible]% & %~ & exactly the same as one of the axioms \\
%[sun is visible]% & %~ & by <a href="#e534a612329d40999f89b656270c704c">modus ponens</a> of the two subformulas immediately above \\
%[sun is visible]% \Rightarrow %[battery charging]% & %~ & exactly the same as one of the axioms \\
%[battery charging]% & %~ & by <a href="#e534a612329d40999f89b656270c704c">modus ponens</a> of the two subformulas immediately above \\
%[battery charging]% \Rightarrow %[motors work]%  & %~ & exactly the same as one of the axioms \\
%[motors work]% & %~ & by <a href="#e534a612329d40999f89b656270c704c">modus ponens</a> of the two subformulas immediately above \\
%[motors work]% \Rightarrow %[antenna can turn]% & %~ & exactly the same as one of the axioms \\
%[antenna can turn]% & %~ & by <a href="#e534a612329d40999f89b656270c704c">modus ponens</a> of the two subformulas immediately above \\
\end{eqnarray}
We can eliminate many of the steps above because they are redundant, or because they do not change the meaning of the formula:
\begin{eqnarray}
%a & %~ & \\
%[light sensor]% & %~ & \\
%[antenna can turn]% & %~ & \\
\end{eqnarray}
This is very interesting, because it means that the formula represented by the above proof has the same meaning as the original proof, so like the proof, it must always be true. Thus, the following formula is always true:
\begin{eqnarray}
(%a \wedge %[light sensor]%) & \Rightarrow & %[antenna can turn]%
\end{eqnarray}
However, it is not immediately obvious that the above formula is always true. In fact, we would need to either rebuild the proof and check that each step was a valid logical or algebraic manipulation, or we would need to build the entire truth table and check all 2^7 = 128 rows (i.e., solve the <a href="#d47f419c427a4f378d8c05d7caf4c801">counting boolean satisfiability problem</a> for this proof). Thus, the above formula is a <i>theorem</i> (because it is always true), but it is not necessarily a <i>proof</i>, anymore (depending on what we consider to be an <i>efficiently verifiable</i> proof).
        ]]></paragraph>
      </example>
      <fact required="true" id="aa0b37b93e9d4e55b24ef0787b0f7ac8">
        <text hooks="math"><![CDATA[
We can provide <i>sufficient</i> conditions for an efficiently verifiable proof as follows: a formula %f is an <i>efficiently verifiable proof</i> if it can be converted into a vertical list in which each non-axiom step is either (1) an exact duplicate of an axiom or another step above it, or (2) a direct conclusion of applying modus ponens to the two steps immediately before it.
        ]]></text>
      </fact>
      <example required="true" id="c74b7e400739467c8d8e107326a578dd">
        <text hooks="math"><![CDATA[
For each of the following formulas, determine if it conforms to the definition of a <i>proof</i>:
<ol style="list-style-type:lower-alpha; margin-left:-12px; line-height:30px;">
  <li>(%a \wedge %b \wedge %c \wedge %d \wedge %e) \Rightarrow %c</li>
  <li>(%a \wedge (%b \Rightarrow %c) \wedge %b) \Rightarrow %c</li>
  <li>((%b \Rightarrow %c) \wedge (%a \Rightarrow %b) \wedge %a) \Rightarrow %c</li>
</ol>
        ]]></text>
        <solution hooks="math"><![CDATA[
We discuss each of the formulas.
<ol style="list-style-type:lower-alpha; margin-left:-12px; margin-top:0px;">
  <li>
Since %c is an exact duplicate of a formula on the left-hand side of the \Rightarrow operator, if the formulas on the left-hand side of \Rightarrow are axioms then this is a proof.
  </li>
  <li>
By modus ponens, we can obtain %c from (%b \Rightarrow %c) \wedge %b (because (%b \Rightarrow %c) \wedge %b \equiv (%b \Rightarrow %c) \wedge %b \wedge %c is an algebraic law). Thus, %c is a direct conclusion of applying modus ponens to the two steps immediately before %c, so this formula is a proof.
  </li>
  <li>
This formula is a theorem, but it is not a proof. The final step %c cannot be derived directly from the two previous steps using modus ponens, and it does not appear on the left-hand side of the \Rightarrow operator.
  </li>
</ol>
        ]]></solution>
      </example>
      <example required="true" id="d7f3184d6de04ae6b98b78f7d3a270dd">
        <text hooks="math"><![CDATA[
Suppose we adopt the same collection of axioms %a is in the <a href="#e6b10fd86b08477893c79e90f4e454fb">example above</a>. However, suppose we are given a <i>theorem</i> and are asked to assemble a <i>proof</i> for it. For example, suppose we are given the following theorem:
\begin{eqnarray}
(%a \wedge %[light sensor]%) & \Rightarrow & %[communications work]%
\end{eqnarray}
In the form of a vertical list, this theorem would look as follows:
\begin{eqnarray}
%a & %~ &  \\
%[light sensor]% & %~ &  \\
%[communications work]% & %~ & \\
\end{eqnarray}
Our task is to find a list of subformulas that conforms to our definition of a proof: each step is either an axiom, a duplicate of a previous step, or the consequence of applying modus ponens to the two previous steps.
        ]]></text>
        <paragraph hooks="math"><![CDATA[
Under these circumstances, one strategy we can employ is to work backwards. In particular, we know that because there is no exact duplicate of %[communications work]% anywhere in the theorem, this must be derived using modus ponens. Thus, we know that whatever the proof might contain, it must at least contain the following;
\begin{eqnarray}
  %a & %~ & \\
  %[light sensor]% & %~ &  \\
  \vdots & %~ & \\
  %[battery charging]% \Rightarrow %[communications work]% & %~ & exactly the same as one of the axioms \\
  %[communications work]% & %~ & by modus ponens
\end{eqnarray}
However, the above tells us that we also need %[battery charging]% for modus ponens to work:
\begin{eqnarray}
  %a & %~ &  \\
  %[light sensor]% & %~ &  \\
  \vdots & %~ & \\
  %[battery charging]% & %~ &  \\
  %[battery charging]% \Rightarrow %[communications work]% & %~ & exactly the same as one of the axioms \\
  %[communications work]% & %~ & by modus ponens of the two subformulas immediately above
\end{eqnarray}
But where can we get %[battery charging]%? Also from modus ponens, since it is again not an axiom or anywhere else in the vertical list of subformulas:
\begin{eqnarray}
  %a & %~ &  \\
  %[light sensor]% & %~ &  \\
  \vdots & %~ & \\
  %[sun is visible]% \Rightarrow %[battery charging]% & %~ & exactly the same as one of the axioms \\
  %[battery charging]% & %~ & by modus ponens of the two subformulas immediately above \\
  %[battery charging]% \Rightarrow %[communications work]% & %~ & exactly the same as one of the axioms \\
  %[communications work]% & %~ & by modus ponens of the two subformulas immediately above
\end{eqnarray}
At this point, we again notice that %[sun is visible]% can only be obtained using modus ponens:
\begin{eqnarray}
  %a & %~ &  \\
  %[light sensor]% & %~ & \\
  %[light sensor]% \Rightarrow %[sun is visible]% & %~ & exactly the same as one of the axioms \\
  %[sun is visible]% & %~ & by modus ponens of the two subformulas immediately above \\
  %[sun is visible]% \Rightarrow %[battery charging]% & %~ & exactly the same as one of the axioms \\
  %[battery charging]% & %~ & by modus ponens of the two subformulas immediately above \\
  %[battery charging]% \Rightarrow %[communications work]% & %~ & exactly the same as one of the axioms \\
  %[communications work]% & %~ & by modus ponens of the two subformulas immediately above
\end{eqnarray}

        ]]></paragraph>
      </example>
    </subsection>
    <assignment title="Theorems, Proofs, and Modus Ponens">
      <instructions><![CDATA[
In this assignment you will assemble a simple proof verifier and a short proof.
<br/><br/>
<b style="color:firebrick;">Your solution may not import any modules or employ any external library functions (unless the problem statement explicitly permits this).</b> The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
      ]]></instructions>
      <problems>
        <problem>
          <text hooks="math"><![CDATA[
For each of the following formulas, determine whether it is a theorem, an <i>efficiently verifiable</i> proof, or neither. In your Python file, define the variables <code>oneA</code>, <code>oneB</code>, <code>oneC</code>, <code>oneD</code>, <code>oneE</code>, <code>oneF</code>, and <code>oneG</code> to be either <code>'Theorem'</code>, <code>'Proof'</code>, or <code>'Neither'</code>. For example, if the question had a part (h) and the formula for that part were a proof, you would include in your Python file the following line:
          ]]></text>
          <code hooks="Python"><![CDATA[
oneH = 'Proof'
          ]]></code>
          <text hooks="math"><![CDATA[
In the above manner, answer the following.
          ]]></text>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
                (%x \wedge %y) \Rightarrow %x
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                ((%y \Rightarrow %z) \wedge (%x \Rightarrow %y) \wedge (%w \Rightarrow %x) \wedge %w) \Rightarrow %z
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                %x \Rightarrow %x
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                (%u \wedge %v \wedge %w \wedge %x \wedge %y) \Rightarrow %z
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                ((%u \Rightarrow %v) \wedge (%w \Rightarrow %x) \wedge %u \wedge (%u \Rightarrow %v) \wedge %v) \Rightarrow (%w \Rightarrow %x)
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                (%x \oplus %y) \Rightarrow (%x \vee %y)
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                \neg(%x) \vee (%y \vee %z)
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
For the remainder of this assignment, we will represent proofs in Python usings lists. Each step in the proof will either be a list such as <code>['x', 'y']</code> containing two items (representing an implication such as %x \Rightarrow %y), or a single string such as <code>'z'</code> (representing a predicate or variable such as %z). For example, suppose we have the following proof:
\begin{eqnarray}
  (%z \wedge %x \wedge (%x \Rightarrow %y)) \Rightarrow %y
\end{eqnarray}
We would represent this as the following Python list:
          ]]></text>
          <code hooks="Python"><![CDATA[
['z', 'x', ['x', 'y'], 'y']
          ]]></code>
          <text hooks="math"><![CDATA[
In this problem, you will implement a Python function that can verify that a proof supplied using the above representation is actually valid (i.e., that the proof represents a formula that is always true). Implement a Python function <code>valid(axioms, proof)</code> that takes two lists are arguments: <code>axioms</code> is a list of implications that are assumed to be true, while <code>proof</code> is a list of implications and predicates where each entry is:
<ul>
  <li>an exact copy of something that appears in <code>axioms</code> or earlier in the list <code>proof</code>, or</li>
  <li>a conclusion of modus ponens where the two entries in the list immediately before it are the two premises of modus ponens (the order of the two premises does not need to matter).</li>
</ul>
If the input <code>proofs</code> satisfies the above conditions, then <code>valid(axioms, proofs)</code> should return <code>True</code>. Othewise, it should return <code>False</code>. Some example inputs and outputs are found below:
          ]]></text>
          <code hooks="Python"><![CDATA[
>>> valid(['a'], ['a', 'a'])
@True
>>> valid(['a', 'b'], ['c', 'd'])
@False
>>> valid(['x', ['x', 'y']], ['x', ['x', 'y'], 'y'])
@True
>>> valid([['a', 'b'], ['b', 'c'], 'a'], ['a', ['a', 'b'], 'b', ['b', 'c'], 'c'])
@True
>>> valid([['a', 'b'], ['b', 'c'], 'a'], ['a', 'c'])
@False
          ]]></code>
          <text hooks="math"><![CDATA[
<b>Hint:</b> You can write a <code>for</code> loop that traverses a list <code>xs</code> as follows:
          ]]></text>
          <code hooks="Python"><![CDATA[
@for i @in @range(0, @len(xs)):
  @print(xs[i])
          ]]></code>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
You may include the following axiom list in your Python file:
          ]]></text>
          <code hooks="Python"><![CDATA[
axiomsThree = [\
    ['user can log in as admin', 'user can change admin password'],\
    ['user can own files', 'user can delete files'],\
    ['user can log in as admin', 'user can set security policy'],\
    ['user can log in as admin', 'user can see files'],\
    ['user can set security policy', 'user can set file ownership'],\
    ['user knows admin password', 'user can log in as admin'],\
    ['user can set file ownership', 'user can own files'],\
    'user knows admin password'\
  ]
          ]]></code>
          <text hooks="math"><![CDATA[
Define a proof (i.e., a Python list) called <code>proofThree</code> in your file that concludes with the predicate <code>'user can delete files'</code>:
          ]]></text>
          <code hooks="Python"><![CDATA[
proofThree = [\

    # Fill this in with valid proof steps.

    'user can delete files'\
  ]
          ]]></code>
          <text hooks="math"><![CDATA[
Your proof should be valid according to <code>valid()</code>:
          ]]></text>
          <code hooks="Python"><![CDATA[
>>> valid(axiomsThree, proofThree)
@True
          ]]></code>
        </problem>
      </problems>
    </assignment>
    <subsection title="Predicates, constants, and universal quantification">
      <paragraph><![CDATA[
In this subsection, we generalize the notion of a predicate in order to make it possible to describe many properties of a system more concisely using logical formulas.
      ]]></paragraph>
      <paragraph><![CDATA[
Recall that we can treat variables as <i>predicates</i> that represent particular binary (true or false) states of a system, object, or other entity being modelled. This is particularly reasonable within the context of proofs: proofs and theorems are formulas that are <i>always</i> true, no matter how we assign truth values to predicates. Thus, while a predicate might still technically "vary" in terms of its meaning (true or false), we might also work with it (e.g., in assembling proofs) without ever considering its meaning. In that case, the proofs would encode relationships between predicates, and not constraints on what values they can be assigned.
      ]]></paragraph>
      <definition required="true" id="ce8e562193224de1bf820a74277f8713">
        <text hooks="math"><![CDATA[
A <i>domain of discourse</i>, or simply <i>domain</i> (which we usually denote using \D) is a set of distinct objects. Usually, predicates represent relationships between or properties of elements of the domain of discourse. We sometimes call the elements in the domain of discourse <i>constants</i>.
        ]]></text>
      </definition>
      <paragraph hooks="math"><![CDATA[
So far, we have used variables to represent particular states of a system whose properties we might be modelling using formulas. However, we often had variable names that shared structure. For example, %[Alice has an appointment at 1 PM]% and %[Bob has an appointment at 2 PM]% are two variables that have a common structure: %[... has an appointment at ...]%. We can make our reuse of such patterns within our formula variables more explicit by introducing <i>predicates</i>.
      ]]></paragraph>
      <definition required="true" hooks="math" id="e29b100676bf4e1f906b0c5f4e62b2d2"><![CDATA[
We can extend our definition of a well-formed boolean formula to also allow predicates that talk about elements in a domain of discourse. When elements from a domain of discourse appear inside a predicate, we usually call them <i>terms</i>.
<table class="fig_table">
 <tr>
  <td><b>boolean formula</b></td>
  <td><b>comments</b></td>
 </tr>
 <tr>
  <td>\vdots</td>
  <td>\vdots</td>
 </tr>
 <tr> 
  <td>%[example]%</td>
  <td>a predicate without any terms</td>
 </tr>
 <tr> 
  <td>%[example @x example]%</td>
  <td>a predicate with one term %x from \D</td>
 </tr>
 <tr> 
  <td>%[@x example @y]%</td>
  <td>a predicate with two terms %x, %y from \D</td>
 </tr>
 <tr>
  <td>\vdots</td>
  <td>\vdots</td>
 </tr>
</table>
Typically, <i>predicate</i>, <i>predicate instance</i>, and <i>predicate instantiation</i> will refer to a predicate in which the slots are occupied by particular terms. We can think of each predicate instance as a distinct variable that may have the meaning \top or \bot.
      ]]></definition>
      <example required="true" id="bc786546e65d479a91eacf5f518770c9">
        <text hooks="math"><![CDATA[
Suppose our domain of discourse is \D = {1 PM, 2 PM, Alice, Bob} and we have as predicates %[@x has appointment at @y]% and %[@x is busy]% where %x and %y are from the domain of discourse. We can build well-formed formulas such as the following (each of the examples below is a formula consisting of a predicate instance):
\begin{eqnarray}
%[<b>Alice</b> has appointment at <b>2 PM</b>]% \\
%[<b>Bob</b> has appointment at <b>1 PM</b>]% \\
%[<b>Bob</b> is busy]%
\end{eqnarray}
However, notice that the following are also <i>well-formed</i> formulas given our definitions so far:
\begin{eqnarray}
%[<b>2 PM</b> has appointment at <b>1 PM</b>]% \\
%[<b>1 PM</b> has appointment at <b>Bob</b>]% \\
%[<b>1 PM</b> is busy]%
\end{eqnarray}
The above is not a flaw in our definitions. It is perfectly valid to ask whether %[<b>1 PM</b> has appointment at <b>Bob</b>]% is a true formula; it is just desirable in this particular example to ensure that %[<b>1 PM</b> has appointment at <b>Bob</b>]% must have the meaning \bot under any circumstances that we might consider to be an accurate model of a possible state of reality.
        ]]></text>
      </example>
      <fact required="true" id="f63264a87ee34c65a086344166e37432">
        <text hooks="math"><![CDATA[
If we know the number of elements in the domain of discourse \D and the predicates that are available, we can compute the total number of predicate instantiations (i.e., variables) that can be constructed. For example, for each predicate that has one slot, there are |\D| possible instantiations; for each predicate that has two slots, there are |\D| \cdot |\D| different predicate instantiations, and so on.
        ]]></text>
        <paragraph hooks="math"><![CDATA[
In general, of %p_{%i} represents the number of distinct predicates with %i slots, then we can say that the total number of predicate instantiations is:
\begin{eqnarray}
# variables & = & %p_0 + (|\D| \cdot %p_1) + (|\D|^2 \cdot %p_2) + (|\D|^3 \cdot %p_3) + ... + (|\D|^{%i} \cdot %p_{%i}) + ...
\end{eqnarray}
We could write the above using summation notation:
\begin{eqnarray}
# variables & = & \Sigma<sup>&infin;</sup><sub>%i = 0</sub> (|\D|^{%i} \cdot %p_{%i})
\end{eqnarray}
We can go further and say that there are 2<sup># variables</sup> possible <i>models</i> (i.e., rows in a truth table) for a given \D and collection of predicates.
        ]]></paragraph>
      </fact>
      <example required="true" id="eb44c81bef5f4c7c94efc2d7b3e77733">
        <text hooks="math"><![CDATA[
Suppose our domain of discourse is \D = {2 PM, Alice, Bob} and we have as predicates %[... has appointment at ...]%, %[... is a person]%, and %[... is a time]%. That means there is one predicate that has two slots, and two predicates that have one slot. Thus, the total number of predicate instantiations (a.k.a., variables) we can have is:
\begin{eqnarray}
# variables & = & (|\D| \cdot 2) + (|\D|^2 \cdot 1) & = & 3 \cdot 2 + 9 \cdot 1 = 15
\end{eqnarray}
We can confirm this by listing all the instantiations:
\begin{eqnarray}
%[<b>2 PM</b> is a person]% \\
%[<b>Alice</b> is a person]% \\
%[<b>Bob</b> is a person]% \\
%[<b>2 PM</b> is a time]% \\
%[<b>Alice</b> is a time]% \\
%[<b>Bob</b> is a time]% \\
%[<b>2 PM</b> has appointment at <b>2 PM</b>]% \\
%[<b>2 PM</b> has appointment at <b>Alice</b>]% \\
%[<b>2 PM</b> has appointment at <b>Bob</b>]% \\
%[<b>Alice</b> has appointment at <b>2 PM</b>]% \\
%[<b>Alice</b> has appointment at <b>Alice</b>]% \\
%[<b>Alice</b> has appointment at <b>Bob</b>]% \\
%[<b>Bob</b> has appointment at <b>2 PM</b>]% \\
%[<b>Bob</b> has appointment at <b>Alice</b>]% \\
%[<b>Bob</b> has appointment at <b>Bob</b>]%
\end{eqnarray}
We also know that there are 2<sup># variables</sup> = 2<sup>15</sup> possible <i>models</i> (i.e., rows in a truth table) for any formula involving the above variables.
        ]]></text>
      </example>
      <paragraph hooks="math"><![CDATA[
By introducing predicates, we see that a <i>model</i> (i.e., a particular assignment of values to instantiated predicates) becomes a way to specify the properties and relationships between the constants in a domain of discourse. Thus, models become a way to represent <i>knowledge</i> (i.e., concepts and their relationships), or <i>information</i>. For example, a database consisting of one or more tables can be represented mathematically as a collection of predicates, and a given <i>model</i> can represent which entries actually appear in a database (thus, each individual model would be one possible state of the database).
      ]]></paragraph>
      <example required="true" id="47d7681351364218a701ba523dd85277">
        <text hooks="math"><![CDATA[
Suppose our domain of discourse is \D = {1 PM, 2 PM, Alice, Bob} and we have as predicates %[ @x is a person ]%, %[ @x is a time ]% and %[@x has appointment at @y]% where %x and %y are from the domain of discourse. We can use universal quantification to encode the fact that the predicate %[ @x has appointment at @y ]% can only be true for some %x and %y from \D if it is also true that %[@x is a person]% and that %[ @y is a time ]% by requiring that the following universally quantified formula must always be true:
\begin{eqnarray}
\forall %x, %y from \D, %~ %[@x has appointment at @y]% \Rightarrow (%[@x is a person]% \wedge %[@y is a time]%)
\end{eqnarray}
If we call the above formula %f, we have the following truth table:
<table class="fig_table truthtable">
 <tr>
  <td><b>%[ @x has appointment at @y ]%</b></td>
  <td><b>%[ @x is a person ]%</b></td>
  <td><b>%[ @y is a time ]%</b></td>
  <td><b>%f</b></td>
  <td><b>meaning</b></td>
 </tr>
 <tr><td>\top</td><td>\top</td><td>\top</td><td>\top</td><td>a person with an appointment</td></tr>
 <tr><td>\top</td><td>\top</td><td>\bot</td><td>\bot</td><td>meaningless in context, so false</td></tr>
 <tr><td>\top</td><td>\bot</td><td>\top</td><td>\bot</td><td>meaningless in context, so false</td></tr>
 <tr><td>\top</td><td>\bot</td><td>\bot</td><td>\bot</td><td>meaningless in context, so false</td></tr>
 <tr><td>\bot</td><td>\top</td><td>\top</td><td>\top</td><td>a person without an appointment</td></tr>
 <tr><td>\bot</td><td>\top</td><td>\bot</td><td>\top</td><td>meaningless in context, so false</td></tr>
 <tr><td>\bot</td><td>\bot</td><td>\top</td><td>\top</td><td>meaningless in context, so false</td></tr>
 <tr><td>\bot</td><td>\bot</td><td>\bot</td><td>\top</td><td>meaningless in context, so false</td></tr>
</table>
Notice that in the cases in which the formula %f is true, it is certain that in order for %[@x has appointment at @y]% to be true, %[@x is a person]% and %[@y is a time]% must both be true.
        ]]></text>
      </example>
      <definition required="true" hooks="math" id="ea69a884752745d994369b5f63bea206"><![CDATA[
We can extend our definition of a well-formed boolean formula to also include <i>univerally quantified</i> formulas in which a variable appears that can be substituted with any element in the domain of discourse \D.
<table class="fig_table">
 <tr>
  <td><b>boolean formula</b></td>
  <td><b>comments</b></td>
 </tr>
 <tr>
  <td>\vdots</td>
  <td>\vdots</td>
 </tr>
 <tr> 
  <td>\forall %x, %f</td>
  <td>%f is a formula with predicates in<br/>which %x can appear as a term</td>
 </tr>
</table>
We read the \forall symbol as "<i>forall</i>", and if a formula or subformula begins with \forall, we say the formula is <i>universally quantified</i>. The meaning of a universally quantified formula can be defined using conjunction. Suppose that \D = {%a, %b, %c, ...} is the domain of discourse. Then we have that:
\begin{eqnarray}
  %f where %x is substituted with %a \wedge %f where %x is substituted with %b \wedge ... & \equiv & \forall %x, %f
\end{eqnarray}
      ]]></definition>
      <fact title="&amp;forall;-instantiation" required="true" hooks="math" id="0467ef4673fb434d8bdb8b8649f887fa">
        <text><![CDATA[
For any domain of discourse \D, any element in the domain of discourse %a, and any formula %f that might contain some predicates in which %x is a term, we have the following inference rule:
        ]]></text>
        <inferences>
          <inference>
            <premises><![CDATA[\forall %x, %f]]></premises>
            <conclusion><![CDATA[%f with all occurrences of %x substituted with %a]]></conclusion>
          </inference>
        </inferences>
      </fact>
      <example required="true" id="ff63bd193552447c9e29e7fde1971ade">
        <text hooks="math"><![CDATA[
Suppose our domain of discourse is \D = {crow, pigeon} and we have as predicate %[... is a bird]%. The the following are two examples of the \forall-instantiation inference rule being used:
        ]]></text>
        <inferences hooks="math">
          <inference>
            <premises><![CDATA[\forall %x, %[@x is a bird]%]]></premises>
            <conclusion><![CDATA[%[<b>crow</b> is a bird]%]]></conclusion>
          </inference>
          <inference>
            <premises><![CDATA[\forall %x, %[@x is a bird]%]]></premises>
            <conclusion><![CDATA[%[<b>pigeon</b> is a bird]%]]></conclusion>
          </inference>
        </inferences>
        <text hooks="math"><![CDATA[
Notice that the meaning of \forall %x, %[@x is a bird]% is determined by the value assigned to the two possible variables that can be built: %[<b>crow</b> is a bird]% and %[<b>pigeon</b> is a bird]%:
<table class="fig_table truthtable">
  <tr>
    <td><b>%[<b>pigeon</b> is a bird]%</b></td>
    <td><b>%[<b>crow</b> is a bird]%</b></td>
    <td><b>\forall %x, %[@x is a bird]%</b></td>
  </tr>
  <tr><td>\top</td><td>\top</td><td>\top</td></tr>
  <tr><td>\top</td><td>\bot</td><td>\bot</td></tr>
  <tr><td>\bot</td><td>\top</td><td>\bot</td></tr>
  <tr><td>\bot</td><td>\bot</td><td>\bot</td></tr>
</table>
The above suggests that we can simply view \forall %x, %[@x is a bird]% as a short way of writing a conjunction of every possible instantiation of the predicate %[... is a bird]%:
\begin{eqnarray}
 %[<b>pigeon</b> is a bird]% \wedge %[<b>crow</b> is a bird]% & \equiv & \forall %x, %[@x is a bird]%
\end{eqnarray}
        ]]></text>
      </example>
      <example required="true" id="7c0f8a0234194c6297aa7c34d97d0ee3">
        <text hooks="math"><![CDATA[
Suppose our domain of discourse is \D = {crow, pigeon, wug, ...} and we have the predicates %[... is a bird]% and %[... has wings]%. Suppose we have the following formula as an axiom:
\begin{eqnarray}
 & %~ & \forall %x, %[@x is a bird]% \Rightarrow %[@x has wings]% \\
 & %~ & %[<b>wug</b> is a bird]%
\end{eqnarray}
We can use \forall-instantiation together with modus ponens to assemble a proof stating that <i>wugs</i> have wings.
\begin{eqnarray}
 \forall %x, %[@x is a bird]% \Rightarrow %[@x has wings]% & %~ & axiom \\
 %[<b>wug</b> is a bird]% & %~ & axiom \\
 %[<b>wug</b> is a bird]% \Rightarrow %[<b>wug</b> has wings]% & %~ & by \forall-instantiation \\
 %[<b>wug</b> has wings]% & %~ & by modus ponens
\end{eqnarray}
        ]]></text>
      </example>
      <paragraph hooks="math"><![CDATA[
Predicates, universal quantification, and implication can allow us to represent category relationships in a more abstract (and a more concise) manner. Instead of having separate predicates such as %[... is a bird]% or %[... is an animal]% for each category, we can include the category names in the domain of discourse and use a single universally quantified formula that makes it possible to use category relationships to derive conclusions.
      ]]></paragraph>
      <example required="true" id="6d2ea43cfe924bdcb7a46210a539051f">
        <text hooks="math"><![CDATA[
Suppose our domain of discourse is \D = {crow, pigeon, wug, animal, bird, ...} and we have as predicates %[all ... are ...]% and %[... is a ...]%. Suppose we have the following formula as an axiom:
\begin{eqnarray}
 & %~ & \forall %x, %a, %b, (%[all @a are @b]% \wedge %[@x is a @a]%) \Rightarrow %[@x is a @b]% \\
 & %~ & %[all <b>bird</b> are <b>animal</b>]% \\
 & %~ & %[<b>wug</b> is a <b>bird</b>]% \\
\end{eqnarray}
We can use \forall-instantiation, modus ponens, and associativity of \wedge to assemble a proof stating that wugs are animals.
\begin{eqnarray}
 \forall %x, %a, %b, (%[all @a are @b]% \wedge %[@x is a @a]%) \Rightarrow %[@x is a @b]% & %~ & axiom \\
 %[<b>wug</b> is a <b>bird</b>]% & %~ & axiom \\
 %[all <b>bird</b> are <b>animal</b>]%  & %~ & axiom \\
 %[all <b>bird</b> are <b>animal</b>]% \wedge %[<b>wug</b> is a <b>bird</b>]% & %~ & exact duplicates of axioms, grouped using associativity of \wedge \\
 (%[all <b>bird</b> are <b>animal</b>]% \wedge %[<b>wug</b> is a <b>bird</b>]%) \Rightarrow %[<b>wug</b> is a <b>animal</b>]% & %~ & \forall-instantiation \\
 %[<b>wug</b> is a <b>animal</b>]% & %~ & by modus ponens of the two steps immediately above
\end{eqnarray}
        ]]></text>
      </example>
    </subsection>
    <subsection title="Infinitely large domains and logical induction">
      <text><![CDATA[
In the subsection above, we have seen how a collection of predicates can be used to represent the properties and relationships between a set of entities (i.e., the domain of discourse). However, writing down formulas that capture all the assumptions we may want to make (e.g., in a theorem or proof) about all the elements in a very large (or even an infinitely large) domain of discourse can be impractical or impossible. In this subsection, we look at one way in which we can address this difficulty.
      ]]></text>
      
      
      
      
      
      
      
      

      
      
      <example required="true" id="37f1fb3c031044d2ad2066ec8f378cb6">
        <text hooks="math"><![CDATA[
Suppose the domain of discourse is a set of strings (where every string consists of some number of copies of the letter @a) and the set of all positive integers:
\begin{eqnarray}
  \D = {@a, @a@a, @a@a@a, ...} \cup {1, 2, 3, 4, 5, ...}
\end{eqnarray}
We introduce the predicates %[... is a number]% and %[... is a string]%. The following axioms allow us to derive that anything in the subset {@a, @a@a, @a@a@a, ...} is a string:
\begin{eqnarray}
 & %~ & %[@a is a string]% \\
 & %~ & \forall %s, %[@s is a string]% \Rightarrow %[@s@a is a string]% 
\end{eqnarray}
The following axioms allow us to derive that anything in the subset {1, 2, 3, 4, 5, ...} is a number:
\begin{eqnarray}
 & %~ & %[@1 is a number]%  \\
 & %~ & \forall %n, %[@n is a number]% \Rightarrow %[<b>n+1</b> is a number]%
\end{eqnarray}
We could now constrain what constants from the domain of discourse are allowed in each slot of a predicate that specifies the length of a string: %[... is of length ...]%. We can do so by requiring that the following formula must always be true:
\begin{eqnarray}
  \forall %s, %n, %[@s is of length @n]% \Rightarrow (%[@s is a string]% \wedge %[@n is a number]%)
\end{eqnarray}
        ]]></text>
      </example>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <example required="true" id="d007344e0df245c596be2edca0ff11fd">
        <text hooks="math"><![CDATA[
Suppose the domain of discourse is a set of strings (where every string consists of some number of copies of the letter @a) and the set of all positive integers:
\begin{eqnarray}
  \D = {@a, @a@a, @a@a@a, ...} \cup {1, 2, 3, 4, 5, ...}
\end{eqnarray}
We want to use the predicate %[... is of length ...]% to keep track of the sizes of strings. We can introduce two axioms that allow us to build up a proof about the length of any string:
\begin{eqnarray}
 %[@a is of length @1]% & %~ & \\
 \forall %s, %n, %[@s is of length @n]% \Rightarrow %[@s@a is of length <b>n+1</b>]% & %~ &
\end{eqnarray}
Notice that the above two cases actually correspond exactly to the two cases of a recursive implementation of a length function for strings:
        ]]></text>
        <code hooks="Python"><![CDATA[
@def length(s):
  @if s == 'a':
    @return 1
  @else:
    n = length(s[0:-1])
    @return n+1
        ]]></code>
        <text hooks="math"><![CDATA[
We can assemble a proof as follows to show that the particular string @a@a@a@a has the length @4:
\begin{eqnarray}
 %[@a is of length @1]% & %~ & axiom \\
 \forall %s, %n, %[@s is of length @n]% \Rightarrow %[@s@a is of length <b>n+1</b>]% & %~ & axiom \\
 %[@a is of length @1]% & %~ & duplicated step \\
 %[@a is of length @1]% \Rightarrow %[@a@a is of length @2]% & %~ & \forall-instantiation \\
 %[@a@a is of length @2]% & %~ & modus ponens \\
 %[@a@a is of length @2]% \Rightarrow %[@a@a@a is of length @3]% & %~ & \forall-instantiation \\
 %[@a@a@a is of length @3]% & %~ & modus ponens \\
 %[@a@a@a is of length @3]% \Rightarrow %[@a@a@a@a is of length @4]% & %~ & \forall-instantiation \\
 %[@a@a@a@a is of length @4]% & %~ & modus ponens
\end{eqnarray}
        ]]></text>
      </example>
    </subsection>
    <assignment title="Review of Boolean Algebra and Logic">
      <instructions hooks="math"><![CDATA[
In this assignment you will complete a variety of problems that review the material we have seen so far in the course.
<br/><br/>
There is no programming in this assignment. However, please <b style="color:firebrick;">use Python syntax</b> for boolean and set operations in order to make grading easier and to avoid any confusion or grading issues:
<ul>
  <li>use <code>and</code> for \wedge;</li>
  <li>use <code>or</code> for \vee;</li>
  <li>use <code>not</code> for&nbsp;&nbsp;\neg;</li>
  <li>use <code>&</code> for \cap;</li>
  <li>use <code>|</code> for \cup;</li>
  <li>use <code>U - X</code> for %{^%X}%.</li>
</ul>
You must show your work in your solutions.
      ]]></instructions>
      <problems>
        <problem>
          <text hooks="math"><![CDATA[
For each of the formulas in this problem, do the following:
<ul style="list-style-type:lower-roman;">
  <li>compute the minimum <a href="#6afd0eee519d4c4d9eeab086750b08e4">number of rows</a> in the truth table for the formula;</li>
  <li>solve the <a href="#5b5e038221fb4c589a88692a761645a8">boolean satisfiability problem</a> by finding one <a href="#0c347fffa8264600ba4945fadd51a409">model</a> that <a href="#78a1e0ed892346a396f55cd665904b0d">satisfies</a> the formula;</li>
  <li>solve the <a href="#6afb8e78ab444513990059ce160838fe">maximum boolean satisfiability problem</a> (one model is sufficient);</li>
  <li>solve the <a href="#d47f419c427a4f378d8c05d7caf4c801">counting boolean satisfiability problem</a>.</li>
</ul>
          ]]></text>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
                (%x \wedge %y) \Rightarrow %x
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                %x \oplus %y
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                %x \Rightarrow (\neg(%x))
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                (%x \wedge %y) \Leftrightarrow %z
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                \top \wedge (\neg(%x))
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                (%x \oplus %y) \Rightarrow (%x \vee %y)
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
For each of the algebraic laws and inference rules below, either indicate that the law <a href="#8d3f9ceeda1945c78cbb9c6a24c4f4ba">holds</a> or the rule <a href="#746017a8f7794a1faa55259cbea101ff">holds</a> and explain why by referring to known facts (e.g., <a href="#abd9f8f2a89b44018970dffc4732b77b">distributivity</a>, <a href="#abd9f8f2a89b44018970dffc4732b77b">De Morgan's laws</a>, <a href="#e534a612329d40999f89b656270c704c">modus ponens</a>, and so on), or find a single <a href="#0c347fffa8264600ba4945fadd51a409">model</a> that shows that the law or rule does not hold.
          ]]></text>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
                %x&nbsp;&nbsp;\equiv&nbsp;&nbsp;\neg(%x)
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                \neg(%x \wedge \neg(%y))&nbsp;&nbsp;\equiv&nbsp;&nbsp;%x \Rightarrow %y
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                %x \Rightarrow %y&nbsp;&nbsp;\equiv&nbsp;&nbsp;%y \Rightarrow %x
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
                (%x \wedge %y) \vee (%z \wedge %x)&nbsp;&nbsp;\equiv&nbsp;&nbsp;\neg(\neg(%x) \vee \neg(%y \vee %z))
              ]]></text>
            </part>
            <!--<part>
              <text>The following inference rule:</text>
              <inferences hooks="math">
                <inference>
                  <premises><![CDATA[\neg(\neg(%x) \vee \neg(%x \Rightarrow %y))]]></premises>
                  <conclusion><![CDATA[%y]]></conclusion>
                </inference>
              </inferences>
            </part>-->
            <part>
              <text>The following inference rule:</text>
              <inferences hooks="math">
                <inference>
                  <premises><![CDATA[(\neg(%x) \vee %y) \wedge %x]]></premises>
                  <conclusion><![CDATA[%y]]></conclusion>
                </inference>
              </inferences>
            </part>
          </parts>
        </problem>        
        <problem>
          <text hooks="math"><![CDATA[
Suppose tha %f, %g, and %h are well-formed formulas and that %A, %B, and %C are three sets of models (where \U is the universe) such that each set is the largest possible model set that satisfies its respective formula:
\begin{eqnarray}
  %A & \models & %f \\
  %B & \models & %g \\
  %C & \models & %h
\end{eqnarray}
Using %A, %B, %C, \U, and the set operations \cup, \cap, and %-, write out the largest <a href="#3.2">model set</a> that <a href="#84e95e858e8e4f0396c9cb12b3bdbd63">satisfies</a> each of the following formulas. <b>Hint:</b> in some cases, you may need to apply some algebraic laws for logical operations first.
          ]]></text>
          <parts>
            <part>
              <text hooks="math"><![CDATA[%f \vee \neg(%h)]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[%f \wedge (%g \vee %h)]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[\neg(%f \wedge %g \wedge %h)]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[%f \Rightarrow %g]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[%f \Leftrightarrow \neg(%f)]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[\top]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
Complete each of the following proofs so that each step in the proof is one of the following:
<ul style="list-style-type:lower-roman;">
  <li>an exact duplicate of an axiom or a previous step;</li>
  <li>an application of <a href="#e534a612329d40999f89b656270c704c">modus ponens</a> using the two steps immediately above it;</li>
  <li>a grouping of subformulas using associativity of \wedge;</li>
  <li>a <a href="#0467ef4673fb434d8bdb8b8649f887fa">\forall-instantiation</a>;</li>
  <li>a conversion of a base case and inductive step into a single universally quantified formula via the axiom of induction.</li>
</ul>
<b style="color:firebrick;">Label each step you add with one of the above</b> (you may use the roman numerals to make things more concise).
          ]]></text>
          <parts>
            <!-- basic example with modus ponens and forall using \neq -->
            <part>
              <text hooks="math"><![CDATA[
Complete the following proof:
\begin{eqnarray}
 & %~ & %[b]% \Rightarrow %[c]% \\
 & %~ & %[d]% \Rightarrow %[e]% \\
 & %~ & %[d]% \Rightarrow %[b]% \\
 & %~ & %[c]% \Rightarrow %[d]% \\
 & %~ & %[c]% \Rightarrow %[a]% \\
 & %~ & %[a]% \Rightarrow %[b]% \\
 & %~ & %[a]% \\
 & %~ & \vdots \\
 & %~ & %[e]%
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Suppose the domain of discourse is \D = {products, boxes, containers, warehouses}. Complete the following proof:
\begin{eqnarray}
 & %~ & \forall %x, %y, %z, (%[@x are in @y]% \wedge %[@y are in @z]%) \Rightarrow %[@x are in @z]% \\
 & %~ & %[<b>products</b> are in <b>boxes</b>]% \\
 & %~ & %[<b>boxes</b> are in <b>containers</b>]% \\
 & %~ & %[<b>containers</b> are in <b>warehouses</b>]% \\
 & %~ & \vdots \\
 & %~ & %[<b>products</b> are in <b>warehouses</b>]%
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Suppose the domain of discourse is the set of strings that are made using the two letters @a and @b. Complete the following proof:
\begin{eqnarray}
 & %~ & %[@a is a string]% \\
 & %~ & %[@b is a string]% \\
 & %~ & \forall %s, %[@s is a string]% \Rightarrow %[<b>%s@a</b> is a string]% \\
 & %~ & \forall %s, %[@s is a string]% \Rightarrow %[<b>%s@b</b> is a string]% \\
 & %~ & \vdots \\
 & %~ & %[@a@b@a@a is a string]%
\end{eqnarray}
              ]]></text>
            </part>            
            <part>
              <text hooks="math"><![CDATA[
Suppose the domain of discourse is the set of positive integers \D = {0, 0+1, 0+1+1, 0+1+1+1, ...}. Complete the following proof:
\begin{eqnarray}
 & %~ & %[@0 is less than or equal to @0]% \\
 & %~ & \forall %n, %[@0 is less than or equal to @n]% \Rightarrow %[@0 is less than or equal to <b>%n+1</b>]% \\
 & %~ & \vdots \\
 & %~ & %[@0 is less than or equal to <b>0+1+1+1+1</b>]%
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
<b>Extra credit:</b> Suppose the domain of discourse is the set of positive integers \D = {0, 0+1, 0+1+1, 0+1+1+1, ...}. Complete the following proof:
\begin{eqnarray}
 & %~ & \forall %k, %[@k is less than or equal to @k]% \\
 & %~ & \forall %m, %n, %[@m is less than or equal to @n]% \Rightarrow %[@m is less than or equal to <b>%n+1</b>]% \\
 & %~ & \vdots \\
 & %~ & %[<b>0+1+1+1+1</b> is less than or equal to <b>0+1+1+1+1+1+1+1+1</b>]%
\end{eqnarray}
              ]]></text>
            </part>            
          </parts>
        </problem>
      </problems>
    </assignment>
  </section>
  <review title="Boolean Algebra, Logic, and Induction">
    <!--<text><![CDATA[
This section contains a comprehensive collection of review problems going over the course material covered until this point. Many of these problems are an accurate representation of the kinds of problems you may see on an exam.
    ]]></text>-->
    <paragraph hooks="math"><![CDATA[
The following is a breakdown of what you should be able to do at this point in the course (and of what you may be tested on in an exam).
Notice that many of the tasks below can be composed. This also means that some problems can be solved in more than one way.
<ul>
  <li>boolean formulas, their meanings, and truth tables
    <ul>
      <li>determine whether a formula is a well-formed formula</li>
      <li>determine the meaning of a formula without variables</li>
      <li>solve for an assignment of values to variables that makes a formula true</li>
      <li>build a truth table for a formula with variables</li>
      <li>for a given model (assignment of variables to values), find the meaning of a formula</li>
    </ul>
  </li>
  <li>boolean algebra 
    <ul>
      <li>common algebraic laws, and applying algebraic laws
        <ul>
          <li>commutativity, associativity, and identity of \vee and \wedge</li>
          <li>distributivity of \wedge and invertibility of&nbsp;&nbsp;\neg</li>
          <li>De Morgan's laws</li>
          <li>representing \oplus, \Rightarrow, and \Leftrightarrow using \vee, \wedge, and&nbsp;&nbsp;\neg</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>models, model sets, satisfaction of formulas, and common problems involving formulas
    <ul>
      <li>determine whether a given model satisfies a given formula</li>
      <li>given a formula, find the set of all models that satisfy a formula</li>
      <li>given a formula, solve the boolean satisfiability problem</li>
      <li>given a formula, solve the maximum boolean satisfiability problem</li>
      <li>given a formula, solve the counting boolean satisfiability problem</li>
      <li>counting problems
        <ul>
          <li>determine the number of rows in a truth table for a formula, or a given number of variables</li>
          <li>determine the number of possible truth tables for a given number of variables</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>using formulas to represent properties of "real-world" systems and entities
    <ul>
      <li>representing states of a system using boolean variables</li>
      <li>representing constraints and relationships between system states using formulas</li>
      <li>answering questions about systems and entities being modeled
        <ul>
          <li>finding a system state that satisfies a formula</li>
          <li>finding a system state with the maximum number of variables assigned to \top</li>
          <li>counting the number of system states that satisfy a formula</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>set theory, algebra of sets, and relationships to boolean algebra
    <ul>
      <li>perform computations involving set union, intersection, difference, and complement</li>
      <li>find the size of a set</li>
      <li>find the power set (or the size of a power set) of a set</li>
      <li>apply algebraic laws of set operations</li>
      <li>convert logical operations on formulas into corresponding set operations on model sets (and vice versa)</li>
    </ul>
  </li>
  <li>theorems, proofs, predicates, universal quantification, and induction
    <ul>
      <li>given a domain of discourse and collection of predicates, count the number of predicate instantiations possible</li>
      <li>determine whether a well-formed formula is a theorem</li>
      <li>determine whether an inference rule holds (i.e., \bot rows can become \top, but \top rows must stay \top)</li>
      <li>identify or apply common inference rules and logical (algebraic) laws
        <ul>
          <li>modus ponens</li>
          <li>\forall-instantiation</li>
          <li>induction</li>
        </ul>
      </li>
      <li>assemble a proof given axioms and a goal (using the representation involving a vertical list of subformulas)</li>
      <li>determine whether a proof is valid</li>
    </ul>
  </li>  
</ul>
    ]]></paragraph>
    <exercise required="true" id="ed08032331144da8aa07c06e050d1c4d">
      <text hooks="math"><![CDATA[
Solve the maximum satisfiability and the counting satisfiability problem for the following formulas: 
<ol style="list-style-type:lower-alpha; margin-left:-12px; line-height:30px;">
  <li>%x \wedge (\neg(%y))</li>
  <li>\bot</li>
  <li>%x \Leftrightarrow (%y \oplus %z)</li>
</ol>
      ]]></text>
      <solution hooks="math"><![CDATA[
<ol style="list-style-type:lower-alpha; margin-left:-12px; margin-top:0px;">
  <li>
The model {%x \mapsto \top, %y \mapsto \bot} is the only model that satisfies this formula. Since this is the only satisfying model, this is also the one with the maximum number of variables assigned to \top, so it is the solution to the maximum satisfiability problem. Since there is only one satisfying formula, the solution to the counting satisfiability problem is 1.
  </li>
  <li>
There are no models that satisfy \bot, since \bot has the meaning false no matter what values are assigned to any collection of variables. Thus, there is no solution to the maximum satisfiability problem for this formula, and the solution to the counting satisfiability problem is 0.
  </li>
  <li>
We can write out the truth table for this formula:
<table class="fig_table truthtable">
 <tr>
  <td><b>%x</b></td>
  <td><b>%y</b></td>
  <td><b>%z</b></td>
  <td><b>%x \Leftrightarrow (%y \oplus %z)</b></td>
 </tr>
 <tr><td>\top</td><td>\top</td><td>\top</td><td>\bot</td></tr>
 <tr><td>\top</td><td>\top</td><td>\bot</td><td>\top</td></tr>
 <tr><td>\top</td><td>\bot</td><td>\top</td><td>\top</td></tr>
 <tr><td>\top</td><td>\bot</td><td>\bot</td><td>\bot</td></tr>
 <tr><td>\bot</td><td>\top</td><td>\top</td><td>\top</td></tr>
 <tr><td>\bot</td><td>\top</td><td>\bot</td><td>\bot</td></tr>
 <tr><td>\bot</td><td>\bot</td><td>\top</td><td>\bot</td></tr>
 <tr><td>\bot</td><td>\bot</td><td>\bot</td><td>\top</td></tr>
</table>
From the above, we see that any model that contains two variables with the value \top is a solution to the maximum satisfiability problem, such as {%x \mapsto \bot, %y \mapsto \top, %z \mapsto \top}, and we see that the solution to the counting satisfiability problem is the number of rows for which the formula's meaning is true, which is 4.
  </li>
</ol>
      ]]></solution>
    </exercise>
    <exercise required="true" id="eadc1a63b51c461089a85ae570f7efc1">
      <text hooks="math"><![CDATA[
Suppose the domain of discourse is \D = {Alewife, Kenmore, Park St.}. Complete the following proof:
\begin{eqnarray}
 & %~ & \forall %x, %y, %z, (%[@x can be reached from @y]% \wedge %[@y can be reached from @z]%) \Rightarrow %[@x can be reached from @z]% \\
 & %~ & %[<b>Park St.</b> can be reached from <b>Alewife</b>]% \\
 & %~ & %[<b>Kenmore</b> can be reached from <b>Park St.</b>]% \\
 & %~ & \vdots \\
 & %~ & %[<b>Kenmore</b> can be reached from <b>Alewife</b>]%
\end{eqnarray}
      ]]></text>
      <solution hooks="math"><![CDATA[
The complete proof is as follows:
\begin{eqnarray}
  \forall %x, %y, %z, (%[@x can be reached from @y]% \wedge %[@y can be reached from @z]%) \Rightarrow %[@x can be reached from @z]% & %~ & axiom \\
 %[<b>Park St.</b> can be reached from <b>Alewife</b>]% & %~ & axiom \\
 %[<b>Kenmore</b> can be reached from <b>Park St.</b>]% & %~ & axiom \\
 (%[<b>Kenmore</b> can be reached from <b>Park St.</b>]% \wedge %[<b>Park St.</b> can be reached from <b>Alewife</b>]%) & %~ & associativity of \wedge \\
 (%[<b>Kenmore</b> can be reached from <b>Park St.</b>]% \wedge %[<b>Park St.</b> can be reached from <b>Alewife</b>]%) \Rightarrow %[<b>Kenmore</b> can be reached from <b>Alewife</b>]% & %~ & \forall-instantiation \\
 %[<b>Kenmore</b> can be reached from <b>Alewife</b>]% & %~ &  modus ponens
\end{eqnarray}
For the sake of the exercise, we could extend the problem with an additional axiom that shows that the reachability predicate is symmetric and prove the relationship in the other direction:
\begin{eqnarray}
  \forall %x, %y, %[@x can be reached from @y]% \Rightarrow %[@y can be reached from @x]% & %~ & axiom \\
  \forall %x, %y, %z, (%[@x can be reached from @y]% \wedge %[@y can be reached from @z]%) \Rightarrow %[@x can be reached from @z]% & %~ & axiom \\
 %[<b>Park St.</b> can be reached from <b>Alewife</b>]% & %~ & axiom \\
 %[<b>Kenmore</b> can be reached from <b>Park St.</b>]% & %~ & axiom \\
 (%[<b>Kenmore</b> can be reached from <b>Park St.</b>]% \wedge %[<b>Park St.</b> can be reached from <b>Alewife</b>]%) & %~ & associativity of \wedge \\
 (%[<b>Kenmore</b> can be reached from <b>Park St.</b>]% \wedge %[<b>Park St.</b> can be reached from <b>Alewife</b>]%) \Rightarrow %[<b>Kenmore</b> can be reached from <b>Alewife</b>]% & %~ & \forall-instantiation \\
 %[<b>Kenmore</b> can be reached from <b>Alewife</b>]% & %~ &  modus ponens \\
 %[<b>Kenmore</b> can be reached from <b>Alewife</b>]% \Rightarrow %[<b>Alewife</b> can be reached from <b>Kenmore</b>]% & %~ & \forall-instantiation \\
 %[<b>Alewife</b> can be reached from <b>Kenmore</b>]% & %~ &  modus ponens \\
\end{eqnarray}
      ]]></solution>
    </exercise>
    <exercise required="true" id="c9b7f610163842bf8e5660610432d9a2">
      <text hooks="math"><![CDATA[
Suppose that we have the following relationships between two sets of models %A and %B (but subsets of the universe \U), and three formulas %f and %g:
\begin{eqnarray}
%A & \models & %f \\
%B & \models & %g
\end{eqnarray}
Determine what set of models satisfies the following formula:
\begin{eqnarray}
%f \oplus (\neg(%g))
\end{eqnarray}
      ]]></text>
      <solution hooks="math"><![CDATA[
To solve this problem, we must first convert the formula into a form that uses only the logical operators \wedge, \vee, and \neg, because there is no direct correspondence between \oplus and a set operation. Thus, using the algebraic law that relates \oplus to these three operators, we have:
\begin{eqnarray}
%f \oplus (\neg(%g)) & \equiv & (%f \vee (\neg(%g))) \wedge (\neg(%f \wedge (\neg(%g))))
\end{eqnarray}
We can now convert each of the logical operators in the new formula (%f \vee (\neg(%g))) \wedge (\neg(%f \wedge (\neg(%g)))) to the corresponding set operations, being careful to also use the corresponding model setss:
\begin{eqnarray}
(%A \cup (\U - %B)) \cap (\U - (%A \cap (\U - %B)))
\end{eqnarray}
Using the set complement notation, we could write:
\begin{eqnarray}
(%A \cup %{^%B}%) \cap (\U - (%A \cap %{^%B}%))
\end{eqnarray}
      ]]></solution>
    </exercise>
  </review>
  <section title="Trees, Graphs, Measurements, and Probabilities">
    <paragraph><![CDATA[
Trees and graphs are abstract concepts that are ubiquitous in computer science and applied mathematics (including many peripheral scientific disciplines that involve applied mathematics, such as engineering, biology, chemistry, physics, neuroscience, and so on). Trees and graphs allow us to represent networks of relationships that may exist between entities (whether they are neurons, computers, people, locations, abstract concepts, or other entities). They can also be used to represent flows (of materials, products, people, data, and so on) or other processes (such as growth of plants, how diseases propagate, how resources are allocated within an economy, or how algorithms explore a space of possibities to find a solution).  As a result of their general applicability, graphs and trees are commonly found as data structures within software applications.
    ]]></paragraph>
    <paragraph><![CDATA[
In this section we will use the concepts we have defined in previous sections on logic and induction to formally define the concept of a <i>tree</i> and a <i>graph</i>. We will also use logical induction to define different ways to <i>measure</i> trees and graphs along dimensions of interest (such as size, height, and so on). We will use recurrence relations to recursively define measurements of trees and graphs, and we will learn how to solve recurrence relations to obtain closed-form functions that can be used to compute these measurements.
    ]]></paragraph>
    <subsection title="Defining trees and their properties using logical induction">
      <paragraph hooks="math"><![CDATA[
In this subsection, we demonstrate how logical induction can be used to define trees, and we show how these definitions can be converted into corresponding Python code.
      ]]></paragraph>
      <definition required="true" hooks="math" id="bd906e6883324bf9bc1e56ed10d15690"><![CDATA[
We can define a <i>binary tree</i> using the following two induction axioms (one base case and one inductive step):
\begin{eqnarray}
 & %~ & <i>&bull; &nbsp; is a binary tree</i> \\
 & %~ & \forall %t_1, %t_2, %~  (<i>@t_1 is a binary tree</i> \wedge <i>@t_2 is a binary tree</i>) %~ \Rightarrow %~  <i><span style="font-size:24px;"><sub><sub>@t_1 </sub>/</sub><sup>&bull;</sup><sub>\<sub> @t_2</sub></sub></span> &nbsp;is a binary tree</i>
\end{eqnarray}
In the above, we omitted the usual underlined notation for predicates to improve legibility. Any tree that fits the above definition is called a binary tree because every <i>node</i> &bull; in the tree has exactly two <i>children</i>, which are also known as <i>subtrees</i>. The top node in the tree is called the <i>root node</i>.
      ]]></definition>
      <example required="true" id="312f3b1f899c400985e135bfbca0adaf">
        <text hooks="math"><![CDATA[
We can convert the <a href="#bd906e6883324bf9bc1e56ed10d15690">definition of a binary tree</a> into a Python function that checks whether a given Python value is a binary tree. Suppose we represent a tree node using a Python tuple <code>( ... )</code> and subtrees as nested tuples. Then the following function checks whether a value consisting of nested tuples is a binary tree:
        ]]></text>
        <code hooks="Python"><![CDATA[
@def is_binary_tree(t):
   @if @type(t) == @tuple @and @len(t) == 0:
     @return @True
   @elif @type(t) == @tuple @and @len(t) == 2:
     @return is_binary_tree(t[0]) @and is_binary_tree(t[1])
   @else:
     @return @False
        ]]></code>
      </example>
      <definition required="true" hooks="math" id="a3908f82ec6241ff9eddcd452127a13b"><![CDATA[
We can define a <i>perfect binary tree</i> using the following two induction axioms (one base case and one inductive step):
\begin{eqnarray}
 & %~ & <i>&bull; &nbsp; is a perfect binary tree</i> \\
 & %~ & \forall %t, %~ <i>@t is a perfect binary tree</i> %~ \Rightarrow %~  <i><span style="font-size:24px;"><sub><sub>@t </sub>/</sub><sup>&bull;</sup><sub>\<sub> @t</sub></sub></span> &nbsp;is a perfect binary tree</i>
\end{eqnarray}
Notice that in a perfect binary tree, every node has two subtrees that are exactly the same.
      ]]></definition>
      <definition required="true" hooks="math" id="83947578943e4a4b9286e40f10190f24"><![CDATA[
We can define a <i>degenerate binary tree</i> using the following three induction axioms (one base case and one inductive step):
\begin{eqnarray}
 & %~ & <i>&bull; &nbsp; is a degenerate binary tree</i> \\
 & %~ & \forall %t, %~ <i>@t is a degenerate binary tree</i> %~ \Rightarrow %~  <i><span style="font-size:24px;"><sub><sub>@t </sub>/</sub><sup>&bull;</sup><sub>\<sub> &bull;</sub></sub></span> &nbsp;is a degenerate binary tree</i> \\
 & %~ & \forall %t, %~ <i>@t is a degenerate binary tree</i> %~ \Rightarrow %~  <i><span style="font-size:24px;"><sub><sub>&bull; </sub>/</sub><sup>&bull;</sup><sub>\<sub> @t</sub></sub></span> &nbsp;is a degenerate binary tree</i>
\end{eqnarray}
Notice that in a degenerate binary tree, every node has at most one subtree child and one leaf child.
      ]]></definition>
    </subsection>
    <subsection title="Measurements of trees and recurrence relations">
      <paragraph hooks="math"><![CDATA[
Given a definition for a set of trees, we can use induction to define various ways to measure the trees in that set along certain dimensions, sugh as size, height, width, and so on.
      ]]></paragraph>
      <definition required="true" hooks="math" id="b0786681aef5473ab8179235a3dc12bd"><![CDATA[
The following is the definition of the <i>size</i> (i.e., number of nodes) of a binary tree:
\begin{eqnarray}
 & %~ & <i>&bull; &nbsp; has size @1</i> \\
 & %~ & \forall %t_1, %t_2, %n_1, %n_2 %~  (<i>@t_1 has size @n_1</i> \wedge <i>@t_2 has size @n_2</i>) %~ \Rightarrow %~  <i><span style="font-size:24px;"><sub><sub>@t_1 </sub>/</sub><sup>&bull;</sup><sub>\<sub> @t_2</sub></sub></span> has size <b>%n_1 + %n_2 + 1</b></i>
\end{eqnarray}
The following is the definition of the <i>height</i> of a binary tree:
\begin{eqnarray}
 & %~ & <i>&bull; &nbsp; has height @1</i> \\
 & %~ & \forall %t_1, %t_2, %n_1, %n_2 %~  (<i>@t_1 has height @n_1</i> \wedge <i>@t_2 has height @n_2</i>) %~ \Rightarrow %~  <i><span style="font-size:24px;"><sub><sub>@t_1 </sub>/</sub><sup>&bull;</sup><sub>\<sub> @t_2</sub></sub></span> has height <b>max(%n_1, %n_2) + 1</b></i>
\end{eqnarray}
The following is the definition of the <i>width</i> of a binary tree:
\begin{eqnarray}
 & %~ & <i>&bull; &nbsp; has width @1</i> \\
 & %~ & \forall %t_1, %t_2, %n_1, %n_2 %~  (<i>@t_1 has width @n_1</i> \wedge <i>@t_2 has width @n_2</i>) %~ \Rightarrow %~  <i><span style="font-size:24px;"><sub><sub>@t_1 </sub>/</sub><sup>&bull;</sup><sub>\<sub> @t_2</sub></sub></span> has width <b>%n_1 + %n_2</b></i>
\end{eqnarray}
      ]]></definition>
      <definition required="true" hooks="math" id="c4d5bb63e8424767b8a8a55a60bb9786"><![CDATA[
The following is the definition of the <i>size</i> (i.e., number of nodes) of a perfect binary tree:
\begin{eqnarray}
 & %~ & <i>&bull; &nbsp; has size @1</i> \\
 & %~ & \forall %t, %n %~  <i>@t has size @n</i> %~ \Rightarrow %~  <i><span style="font-size:24px;"><sub><sub>@t </sub>/</sub><sup>&bull;</sup><sub>\<sub> @t</sub></sub></span> has size <b>%n + %n + 1</b></i>
\end{eqnarray}
The following is the definition of the <i>height</i> of a perfect binary tree:
\begin{eqnarray}
 & %~ & <i>&bull; &nbsp; has height @1</i> \\
 & %~ & \forall %t, %n %~  <i>@t has height @n</i> %~ \Rightarrow %~  <i><span style="font-size:24px;"><sub><sub>@t </sub>/</sub><sup>&bull;</sup><sub>\<sub> @t</sub></sub></span> has height <b>%n + 1</b></i>
\end{eqnarray}
The following is the definition of the <i>width</i> of a perfect binary tree:
\begin{eqnarray}
 & %~ & <i>&bull; &nbsp; has width @1</i> \\
 & %~ & \forall %t, %n %~  <i>@t has width @n</i> %~ \Rightarrow %~  <i><span style="font-size:24px;"><sub><sub>@t </sub>/</sub><sup>&bull;</sup><sub>\<sub> @t</sub></sub></span> has width <b>%n + %n</b></i>
\end{eqnarray}
      ]]></definition>
      <definition required="true" hooks="math" id="a1222096ab894a0193795e633f2fc522"><![CDATA[
The following is a recursive definition (i.e., a recurrence relation) of the relationship between the height of a tree and its size:
\begin{eqnarray}
 <i>height_to_size</i>(1) & = & 1 \\
 <i>height_to_size</i>(%n) & = & <i>height_to_size</i>(%n-1) + <i>height_to_size</i>(%n-1) + 1
\end{eqnarray}
The above can be simplified as follows:
\begin{eqnarray}
 <i>height_to_size</i>(1) & = & 1 \\
 <i>height_to_size</i>(%n) & = & 2 \cdot <i>height_to_size</i>(%n-1) + 1
\end{eqnarray}
      ]]></definition>
      <example required="true" id="21d34879087246afb956f200a40f6dfc">
        <text  hooks="math"><![CDATA[
We can implement a Python function that computes the size of a binary tree (i.e, the number of nodes):
        ]]></text>
        <code hooks="Python" ><![CDATA[
@def size(t):
   @if @type(t) == @tuple and @len(t) == 0:
     @return 1
   @elif @type(t) == @tuple and @len(t) == 2:
     @return size(t[0]) + size(t[1]) + 1
        ]]></code>
      </example>
      <example required="true" id="d20c4f3ea8064ecbbcc5b316932a47ef">
        <text  hooks="math"><![CDATA[
We can implement a Python function that computes the height of a binary tree (the <code>max()</code> operator returns the larger of its two integer arguments):
        ]]></text>
        <code hooks="Python" ><![CDATA[
@def height(t):
   @if @type(t) == @tuple and @len(t) == 0:
     @return 1
   @elif @type(t) == @tuple and @len(t) == 2:
     @return @max(height(t[0]), height(t[1])) + 1
        ]]></code>
      </example>
      <example required="true" id="a350031762b44649b68193a69f817688">
        <text  hooks="math"><![CDATA[
We can implement a Python function that computes the size of a tree given its height:
        ]]></text>
        <code hooks="Python" ><![CDATA[
@def height_to_size(n):
   @if n == 1:
     @return 1
   @elif n > 1:
     @return 2 * height_to_size(n-1) + 1
        ]]></code>
      </example>
    </subsection>
    <subsection title="Solving recurrence relations for closed-form functions">
      <!--<paragraph hooks="math"><![CDATA[

      ]]></paragraph>-->
      <example required="true" hooks="math" id="1e7c955009bb4d7084fb914a3f9d6ea2"><![CDATA[
How can we find a closed-form function that defines the size of a degenerate binary tree in terms of its height? Recall that the relationship between height and size can be defined using the following recurrence relation:
\begin{eqnarray}
 %f(1) & = & 1 \\
 %f(%n) & = & %f(%n %- 1) + 2
\end{eqnarray}
Thus, we are looking for a non-recursive definition of a function %f that satisfies the above two equations for all positive integers %n. One such %f is:
\begin{eqnarray}
 %f(%x) & = & 2 \cdot %x %- 1
\end{eqnarray}
We can confirm this by substituting the above %f into the recurrence relation:
\begin{eqnarray}
 %f(1) & = & 2 \cdot 1 %- 1 \\
       & = & 1 \\
 %f(%n) & = & 2 \cdot %n %- 1 \\
        & = & 2 \cdot %n %- 2 %- 1 + 2 \\
        & = & (2 \cdot %n %- 2) %- 1 + 2 \\
        & = & (2 \cdot (%n %- 1) %- 1) + 2 \\
        & = & %f(%n %- 1) + 2
\end{eqnarray}
      ]]></example>

      <fact required="true" hooks="math" id="7100f76297bb41aea7b01e964011ec8b"><![CDATA[
Suppose we have a recurrence relation of the following form:
\begin{eqnarray}
 %f(1) & = & %b \\
 %f(%n) & = & %f(%n %- 1) + %a
\end{eqnarray}
The the closed-form function that satisfies the two equations above is:
\begin{eqnarray}
 %f(%x) & = & (%a \cdot %x) + (%b %- %a) 
\end{eqnarray}
      ]]></fact>
      <example required="true" hooks="math" id="177b8af9b61f4e048df979f090220d5b"><![CDATA[
How can we find a closed-form function that defines the size of a perfect binary tree in terms of its height? Recall that the relationship between height and size can be defined using the following recurrence relation:
\begin{eqnarray}
 %f(1) & = & 1 \\
 %f(%n) & = & 2 \cdot %f(%n %- 1) + 1
\end{eqnarray}
Thus, we are looking for a non-recursive definition of a function %f that satisfies the above two equations for all positive integers %n. One such %f is:
\begin{eqnarray}
 %f(%x) & = & 2<sup>%x</sup> %- 1
\end{eqnarray}
We can confirm this by substituting the above %f into the recurrence relation:
\begin{eqnarray}
 %f(1) & = & 2^1 - 1 \\
       & = & 1 \\
 %f(%n) & = & 2<sup>%n</sup> %- 1 \\
        & = & 2<sup>%n</sup> %- 2 + 1 \\
        & = & 2 \cdot (2<sup>%n-1</sup> %- 1) + 1 \\
        & = & 2 \cdot %f(%n %- 1) + 1 \\
\end{eqnarray}
      ]]></example>
      
      
      
      
      <example required="true" hooks="math" id="b9dd7afebe854f218a3943f8feaf61f3"><![CDATA[
How can we find a closed-form function that defines the size of a perfect ternary tree in terms of its height? For perfect ternary trees, the relationship between height and size can be defined using the following recurrence relation:
\begin{eqnarray}
 %f(1) & = & 1 \\
 %f(%n) & = & 3 \cdot %f(%n %- 1) + 1
\end{eqnarray}
Thus, we are looking for a non-recursive definition of a function %f that satisfies the above two equations for all positive integers %n. One such %f is:
\begin{eqnarray}
 %f(%x) & = & (1/2) \cdot (3<sup>%x</sup> %- 1)
\end{eqnarray}
We can confirm this by substituting the above %f into the recurrence relation:
\begin{eqnarray}
 %f(1) & = & (1/2) \cdot (3^1 - 1) \\
       & = & 1 \\
 %f(%n) & = & (1/2) \cdot (3<sup>%n</sup> %- 1) \\
        & = & (1/2) \cdot (3<sup>%n</sup> %- 3 + 2) \\
        & = & (1/2) \cdot (3<sup>%n</sup> %- 3) + 1 \\
        & = & 3 \cdot ((1/2) \cdot (3<sup>%n-1</sup> %- 1)) + 1\\
        & = & 3 \cdot %f(%n %- 1) + 1 \\
\end{eqnarray}
      ]]></example>
      <fact required="true" hooks="math" id="c67c59ed527343d5a047b3be51285fca"><![CDATA[
Suppose we have a recurrence relation of the following form:
\begin{eqnarray}
 %f(1) & = & 1 \\
 %f(%n) & = & %c \cdot %f(%n %- 1)
\end{eqnarray}
The the closed-form function that satisfies the two equations above is:
\begin{eqnarray}
 %f(%x) & = & %c<sup>%x %- 1</sup>
\end{eqnarray}
      ]]></fact>
      <fact required="true" hooks="math" id="bc59e90d48354ea7ba17306ea2c95ca7"><![CDATA[
Suppose we have a recurrence relation of the following form:
\begin{eqnarray}
 %f(1) & = & 1 \\
 %f(%n) & = & %c \cdot %f(%n %- 1) + 1
\end{eqnarray}
The the closed-form function that satisfies the two equations above is:
\begin{eqnarray}
 %f(%x) & = & (1/(%c %- 1)) \cdot (%c<sup>%x</sup> %- 1)
\end{eqnarray}
      ]]></fact>
      <fact required="true" hooks="math" id="0ccea89f06c7402cbe23d95e15e36a53"><![CDATA[
Suppose we have a recurrence relation of the following form:
\begin{eqnarray}
 %f(1) & = & 1 \\
 %f(%n) & = & %c \cdot %f(%n %- 1) + %k
\end{eqnarray}
The the closed-form function that satisfies the two equations above is:
\begin{eqnarray}
 %f(%x) & = & %c<sup>%x %- 1</sup> + %k \cdot (1/(%c %- 1)) \cdot (%c<sup>%x - 1</sup> %- 1)
\end{eqnarray}
      ]]></fact>
      <paragraph hooks="math"><![CDATA[
Recall that \log<sub>%b</sub>(%x/%y) = \log<sub>%b</sub>(%x) %- \log<sub>%b</sub>(%y), and that \log<sub>%b</sub>(1) = 0 because %b^0 = 1.
      ]]></paragraph>
       <example required="true" hooks="math" id="135ad791f7d2406db11b709d04f03f63"><![CDATA[
How can we find a closed-form function that defines the height of a perfect binary tree in terms of its width? The relationship between width and height can be defined using the following recurrence relation:
\begin{eqnarray}
 %f(1) & = & 1 \\
 %f(%n) & = & %f(%n/2) + 1
\end{eqnarray}
Thus, we are looking for a non-recursive definition of a function %f that satisfies the above two equations for all positive integers %n. The %f that satisfies this equation is:
\begin{eqnarray}
 %f(%x) & = & \log_2(%x) + 1
\end{eqnarray}
We can confirm this by substituting the above %f into the recurrence relation:
\begin{eqnarray}
 %f(1) & = & \log_2(1) + 1 \\
       & = & 0 + 1 \\
       & = & 1 \\
 %f(%n) & = & \log_2(%n) + 1 \\
        & = & (\log_2(%n) %- 1 + 1) + 1 \\
        & = & (\log_2(%n) %- \log_2(2) + 1) + 1 \\
        & = & (\log_2(%n/2) + 1) + 1
\end{eqnarray}
      ]]></example>
       <example required="true" hooks="math" id="e0ff1c992c6149df8a4c1f742bb55b00"><![CDATA[
How can we find a closed-form function that defines the height of a perfect ternary tree in terms of its width? The relationship between width and height can be defined using the following recurrence relation:
\begin{eqnarray}
 %f(1) & = & 1 \\
 %f(%n) & = & %f(%n/3) + 1
\end{eqnarray}
Thus, we are looking for a non-recursive definition of a function %f that satisfies the above two equations for all positive integers %n. The %f that satisfies this equation is:
\begin{eqnarray}
 %f(%x) & = & \log_3(%x) + 1
\end{eqnarray}
We can confirm this by substituting the above %f into the recurrence relation:
\begin{eqnarray}
 %f(1) & = & \log_3(1) + 1 \\
       & = & 0 + 1 \\
       & = & 1 \\
 %f(%n) & = & \log_3(%n) + 1 \\
        & = & (\log_3(%n) %- 1 + 1) + 1 \\
        & = & (\log_3(%n) %- \log_3(3) + 1) + 1 \\
        & = & (\log_3(%n/3) + 1) + 1
\end{eqnarray}
      ]]></example>
      <fact required="true" hooks="math" id="be03906292424f669c01365314341203"><![CDATA[
Suppose we have a recurrence relation of the following form:
\begin{eqnarray}
 %f(1) & = & 1 \\
 %f(%n) & = & %f(%n/%c) + 1
\end{eqnarray}
The the closed-form function that satisfies the two equations above is:
\begin{eqnarray}
 %f(%x) & = & \log<sub>%c</sub>(%x) + 1
\end{eqnarray}
      ]]></fact>
      <fact required="true" hooks="math" id="6215d7d7276b45b387de4009721aa3a8"><![CDATA[
Suppose we have a recurrence relation of the following form:
\begin{eqnarray}
 %f(1) & = & 1 \\
 %f(%n) & = & %a \cdot %f(%n/%c) + 1
\end{eqnarray}
The the closed-form function that satisfies the two equations above is:
\begin{eqnarray}
 %f(%x) & = & (1/(%a %- 1)) \cdot (%a<sup>1 + \log<sub>%c</sub> %x</sup> %- 1)
\end{eqnarray}
      ]]></fact>
      <fact required="true" hooks="math" id="f9711558b70c4e7c9d9fec11554976c1"><![CDATA[
Suppose we have a recurrence relation of the following form:
\begin{eqnarray}
 %f(1) & = & 0 \\
 %f(%n) & = & %c \cdot %f(%n/%c) + %n
\end{eqnarray}
The the closed-form function that satisfies the two equations above is:
\begin{eqnarray}
 %f(%x) & = & %n \cdot \log<sub>%c</sub> %n
\end{eqnarray}
      ]]></fact>
      <fact required="true" hooks="math" id="dca240f5099f413488473c5290c06f72"><![CDATA[
Suppose we have a recurrence relation of the following form:
\begin{eqnarray}
 %f(1) & = & 1 \\
 %f(%n) & = & %n \cdot %f(%n %- 1)
\end{eqnarray}
The the closed-form function that satisfies the two equations above is the factorial function:
\begin{eqnarray}
 %f(%x) & = & %x!
\end{eqnarray}
      ]]></fact>
      <paragraph hooks="math"><![CDATA[
The number of edges that can exist in a graph with a certain number of nodes can be determined by defining a recurrence relation, as well.
      ]]></paragraph>
      <fact required="true" hooks="math" id="5ed4e735301e4d148d18e217b44484c7"><![CDATA[
Suppose we have a recurrence relation of the following form:
\begin{eqnarray}
 %f(1) & = & 0 \\
 %f(%n) & = & %f(%n %- 1) + (%n %- 1)
\end{eqnarray}
The the closed-form function that satisfies the two equations above is:
\begin{eqnarray}
 %f(%x) & = & (%x \cdot (%x %- 1)) / 2
\end{eqnarray}
      ]]></fact>
      <fact required="true" hooks="math" id="c73bb6145aab47ceae1d498b27346674"><![CDATA[
Suppose we have a recurrence relation of the following form:
\begin{eqnarray}
 %f(1) & = & 1 \\
 %f(%n) & = & %f(%n %- 1) + 2 \cdot (%n %- 1) + 1
\end{eqnarray}
The the closed-form function that satisfies the two equations above is:
\begin{eqnarray}
 %f(%x) & = & %x^2
\end{eqnarray}
      ]]></fact>
      <fact required="true" hooks="math" id="47089d5c03f24bcbab42246cd30daa49"><![CDATA[
Suppose we have a recurrence relation of the following form:
\begin{eqnarray}
 %f(1) & = & %c \\
 %f(%n) & = & %f(%n %- 1) + (%a \cdot %n) + %b
\end{eqnarray}
The the closed-form function that satisfies the two equations above is:
\begin{eqnarray}
 %f(%x) & = & %a \cdot ((((%x + 1) \cdot %x)/2) %- 1) + (%b \cdot (%x %- 1)) + %c
\end{eqnarray}
      ]]></fact>
    </subsection>
    <subsection title="Summations and recurrence relations">
      <paragraph hooks="math"><![CDATA[
The mathematical notation for summation of terms parameterized by an integer index is a concise way to describe a mathematical term. It represents an algorithm (effectively, a loop) that can be run to obtain a result. Thus, it can be viewed as an alternative, iterative version of some recurrence relations. Any function defined using a summation over a finite range of integers can be converted into a recurrence relation.
      ]]></paragraph>
      <fact required="true" hooks="math" id="716de6730d364d9aaa244800f465f2ab"><![CDATA[
Suppose we have some function %g over the integers, and we also have a function %f defined in terms of %g in the following way:
\begin{eqnarray}
  %f(%x) & = & \Sigma<sup>%x</sup><sub>%i = 1</sub> %g(%i)
\end{eqnarray}
Then we can convert the above into the following recurrence relation:
\begin{eqnarray}
  %f(1) & = & %g(1) \\
  %f(%n) & = & %f(%n %- 1) + %g(%n)
\end{eqnarray}
      ]]></fact>
      <fact required="true" hooks="math" id="3330b6cc980449c58a6afce34c74bd0b"><![CDATA[
We have the following identity for any constant integer %c:
\begin{eqnarray}
  \Sigma<sup>%x</sup><sub>%i = 1</sub> %c & = & %c \cdot %x
\end{eqnarray}
      ]]></fact>
      <fact required="true" hooks="math" id="53cedeaee445494eaca43eccffe39027"><![CDATA[
We have the following identity:
\begin{eqnarray}
  \Sigma<sup>%x</sup><sub>%i = 1</sub> %i & = & (%x \cdot (%x + 1)) / 2
\end{eqnarray}
      ]]></fact>
      <fact required="true" hooks="math" id="710a9c44d1664350ae20609213d54e87"><![CDATA[
We have the following identity for any constant integer %c:
\begin{eqnarray}
  \Sigma<sup>%x</sup><sub>%i = 0</sub> %c<sup>%i</sup> & = & (1/(%c %- 1)) \cdot (%c<sup>%x+1</sup> %- 1)
\end{eqnarray}
We can see this is true by multiplying the sum 1 + %c + %c^2 + %c^3 + ... + %c<sup>%x</sup> by (%c %- 1):
\begin{eqnarray}
(%c %- 1) \cdot (1 + %c + %c^2 + %c^3 + ... + %c<sup>%x</sup>) & = & (%c + %c^2 + %c^3 + ... + %c<sup>%x</sup> + %c<sup>%x+1</sup>) %- (1 + %c + %c^2 + %c^3 + ... + %c<sup>%x</sup>) \\
                                             & = & %c<sup>%x + 1</sup> %- 1
\end{eqnarray}
      ]]></fact>
      <example required="true" id="d85e5c05e7e64beb81557e9bfea65d55">
        <text hooks="math"><![CDATA[
In the Python programming language, it is possible to write an expression that corresponds to mathematical summation notation. For example, suppose we have the following summation:
\begin{eqnarray}
  \Sigma<sup>%x</sup><sub>%i = 1</sub> %c^{%i}
\end{eqnarray}
The above summation corresponds to the following Python expression:
        ]]></text>
        <code hooks="Python"><![CDATA[
@sum(c**i @for i @in @range(1,x+1))
        ]]></code>
        <text hooks="math"><![CDATA[
For a particular instantiated example, suppose we have the following:
\begin{eqnarray}
  \Sigma<sup>10</sup><sub>%i = 1</sub> 2^{%i}
\end{eqnarray}
The above summation corresponds to the following Python expression:
        ]]></text>
        <code hooks="Python"><![CDATA[
>>> @sum(2**i @for i @in @range(1,11))
2046
>>> 2**1 + 2**2 + 2**3 + 2**4 + 2**5 + 2**6 + 2**7 + 2**8 + 2**9 + 2**10
2046
        ]]></code>
      </example>
    </subsection>
    <assignment title="Trees, Graphs, and Recurrence Relations">
      <instructions>
        <text><![CDATA[
In this assignment you will work with recurrence relations that describe measurements of trees and graphs.
<br/><br/>
You may import the following library function in your module:
        ]]></text>
        <code hooks="Python">
@from math @import log
        </code>
        <text hooks="math"><![CDATA[
<b style="color:firebrick;">Your solution may not import any other modules or employ any external library functions.</b> The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
        ]]></text>
      </instructions>
      <problems>
        <problem>
          <text hooks="math"><![CDATA[
Implement a Python function <code>check(f, g)</code> that takes two functions <code>f</code> and <code>g</code> as its two arguments. The function <code>check()</code> should return <code>True</code> if both <code>f</code> and <code>g</code> return exactly the same output on all integer inputs from <code>1</code> to <code>100</code> (inclusive). Otherwise, it should return <code>False</code>. You may use the <code>check()</code> function to check the correctness of your solutions to for the remaining problems.
          ]]></text>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
For each of the following recurrence relations, define a closed-form function using only variables, integers, <code>+</code>, <code>-</code>, <code>*</code>, <code>//</code> (integer division), <code>**</code> (exponentiation), and <code>log()</code> (logarithm). In your Python file, define the functions <code>twoA(x)</code>, <code>twoB(x)</code>, and so on. For example, if the solution to part (h) were the closed-form function %f(%x) = %x^2, you would include in your Python file the following definition:
          ]]></text>
          <code hooks="Python"><![CDATA[
@def twoH(x):
  @return x**2
          ]]></code>
          <text hooks="math"><![CDATA[
In the above manner, solve the following problem parts.
          ]]></text>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
The following recurrence relation:
\begin{eqnarray}
%f(1) & = & 7 \\
%f(%n) & = & %f(%n %- 1) + 4
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
The following recurrence relation:
\begin{eqnarray}
%f(1) & = & 4 \\
%f(%n) & = & %f(%n %- 1) + (6 \cdot %n) %- (3 \cdot %n)
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
The following recurrence relation:
\begin{eqnarray}
%f(1) & = & 1 \\
%f(%n) & = & 4 \cdot %f(%n/2) + 1
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
The following recurrence relation:
\begin{eqnarray}
%f(1) & = & 0 \\
%f(%n) & = & %f(%n %- 1) + 10
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
The following recurrence relation:
\begin{eqnarray}
%f(1) & = & 1 \\
%f(%n) & = & 5 \cdot %f(%n %- 1)
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
The following recurrence relation:
\begin{eqnarray}
%f(1) & = & 0 \\
%f(%n) & = & %f(%n %- 1) + 5 \cdot (%n + 1)
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
The following recurrence relation:
\begin{eqnarray}
%f(1) & = & 1 \\
%f(%n) & = & 3 \cdot %f(%n %- 1) + 2
\end{eqnarray}
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
For each of the following summations or descriptions, define a recurrence relation as a Python function. In your Python file, define the functions <code>threeA(n)</code>, <code>threeB(n)</code>, and so on. For example, if the solution to part (h) were the recurrence relation %f(1) = 1, %f(%n) = %f(%n-1) + 2, you would include in your Python file the following definition:
          ]]></text>
          <code hooks="Python"><![CDATA[
@def threeH(n):
  @if n == 1:
    @return 1
  @elif n > 1:
    @return threeH(n-1) + 2
          ]]></code>
          <text hooks="math"><![CDATA[
In the above manner, solve the following problem parts.
          ]]></text>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
The following summation:
\begin{eqnarray}
  %f(%x) & = & \Sigma<sup>%x</sup><sub>%i = 1</sub> 13
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
The following summation:
\begin{eqnarray}
  %f(%x) & = & \Sigma<sup>%x</sup><sub>%i = 1</sub> %i
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
The following summation:
\begin{eqnarray}
  %f(%x) & = & \Sigma<sup>%x</sup><sub>%i = 1</sub> (2 \cdot %i + 3)
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Suppose we have the following relationship between the height and size of a perfect 6-ary (or "senary") tree in which each non-leaf node has six children:
<ul>
  <li>
a perfect senary tree of height 1 has 1 node;
  </li>
  <li>
a perfect senary tree of height %n has six times as many nodes as a perfect senary tree of height %n %- 1, plus one more root node.
  </li>
</ul>
Define the recurrence relation that captures that size of a senary tree in terms of its height %n.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Suppose a username must start with the <code>@</code> character, but can contain some sequence of any of the 26 letters of the alphabet after that. Thus, <code>@abc</code> would be a username of length four. Define a recurrence relation that specifies how many possible usernames of length <i>n</i> are possible. Keep in mind your solution must be a <i>recurrence relation</i>, not a closed form function.
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Suppose we have the following relationship between the height and width of a perfect 3-ary (or "ternary") tree in which each non-leaf node has three children:
<ul>
  <li>
a perfect ternary tree of height 1 has width 1;
  </li>
  <li>
a perfect ternary tree of height %n has three times the width of a perfect ternary tree of height %n %- 1.
  </li>
</ul>
Define the recurrence relation that captures that width of a perfect ternary tree in terms of its height %n.
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Define a recurrence relation that specifies the size (i.e., number of nodes) of a perfect ternary tree in terms of its width (that is, for an input tree width %n, the value %f(%n) should be the size of the tree having that width).
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
For parts <b>(a)</b> to <b>(g)</b> of <b>Problem #3</b> above, determine the closed-form function that solves the recurrence relation you defined. Specify the function definitions in your Python module under the names <code>fourA(x)</code>, <code>fourB(x)</code>, <code>fourC(x)</code>, and so on.
          ]]></text>
        </problem>
      </problems>
    </assignment>
    <subsection title="Permutations with repetition, permutations, and combinations">
      <paragraph hooks="math"><![CDATA[
In this subsection we review a few common counting problems, and present algorithms that can be used to solve them.
      ]]></paragraph>
      <definition title="permutation with repetition" required="true" hooks="math" id="77caaa047b4a484a90c20614d5ba8f9d"><![CDATA[
A <i>permutation</i> of %n distinct objects is a particular ordering of these objects. Given %n distinct objects (e.g., characters or letters), if we are allowed to use any number of copies of each of those %n objects, then the number of distinct sequences of length %k consisting of these %n objects that can be built is %n<sup>%k</sup>. This is known as the number of <i>permutations with repetition</i>.
      ]]></definition>
      <example required="true" hooks="math" id="504c00c2b9e840268c48fe5db5ab5a5c">
        <text><![CDATA[
Suppose we are given an alphabet consisting of the characters @a, @b, and @c. How many passwords of length 5 can we make if we are allowed to use any number of copies of each character?
        ]]></text>
        <paragraph><![CDATA[
There are 5 possible positions in the password, and each position can be filled with one of three distinct characters. Thus, the total number of passwords is:
\begin{eqnarray}
3 \cdot 3 \cdot 3 \cdot 3 \cdot 3 & = & 3^5 & = & 243
\end{eqnarray}
        ]]></paragraph>
      </example>
      <example required="true" hooks="math" id="b7b386f44b2448f18f1b04e38865f9c0">
        <text><![CDATA[
Suppose we are given an alphabet consisting of the characters @a, @b, and @c. How many passwords of length <i>at least</i> 1 and <i>at most</i> 5 can we make if we are allowed to use any number of copies of each character?
        ]]></text>
        <paragraph><![CDATA[
We can take the sum of the number of 1-character passwords, the number of 2-character passwords, and so on:
\begin{eqnarray}
  3^1 + 3^2 + 3^3 + 3^4 + 3^5 & = & \Sigma<sup>5</sup><sub>i = 1</sub> 3^{%i}
\end{eqnarray}
Using a <a href="#710a9c44d1664350ae20609213d54e87">known fact</a> about summations, we can find a closed form expression for the above:
\begin{eqnarray}
  \Sigma<sup>5</sup><sub>i = 1</sub> 3^{%i} & = & (\Sigma<sup>5</sup><sub>i = 0</sub> 3^{%i}) %- 3^0 \\
                                            & = & ((1/(3 %- 1)) \cdot (3^6 %- 1)) %- 1 \\
                                            & = & (1/2) \cdot (729 %- 1) %- 1 \\
                                            & = & 363
\end{eqnarray}
Thus, we can use three distinct characters to make 363 distinct passwords between length 1 and length 5, inclusive. We can confirm this is true:
\begin{eqnarray}
  3^1 + 3^2 + 3^3 + 3^4 + 3^5 & = & 3 + 9 + 27 + 81 + 243 & = & 363
\end{eqnarray}
        ]]></paragraph>
      </example>
      <definition title="permutation" required="true" hooks="math" id="5217fb4ac40844169908881d3aa02841"><![CDATA[
A <i>permutation</i> of %n distinct objects is a particular ordering of these objects. There are %n! (read as "%n factorial") permutations of a collection of %n distinct objects, where:
\begin{eqnarray}
 %n! & = & %n \cdot (%n %- 1) \cdot (%n %- 2) \cdot (%n %- 3) \cdot ... \cdot 3 \cdot 2 \cdot 1
\end{eqnarray}
      ]]></definition>
      <example required="true" hooks="math" id="251f56cc9f624599a78f18f709b2f59b">
        <text><![CDATA[
Suppose we are given an alphabet consisting of the characters @a, @b, @c, and @d. How many passwords of length 4 can we make if each character must appear exactly once in the password?
        ]]></text>
        <paragraph><![CDATA[
We are in a situation where we must list all possible combinations, and we cannot reuse any character. Thus, if we have four possible character positions in our password, then the first position has one of four possible characters (that is, @a, @b, @c, or @d), and the next position has one of three characters (since we have used one up), and so on. Thus, the total number of passwords that we can build while satisfying this constraint is:
\begin{eqnarray}
4 \cdot 3 \cdot 2 \cdot 1 & = & 4!
\end{eqnarray}
        ]]></paragraph>
      </example>
      <example required="true" hooks="math" id="c119267ae3054120bafe394e6909268b">
        <text><![CDATA[
Suppose we are given an alphabet consisting of 26 characters. How many passwords of length 5 can we make if each character must appear at most once in the password?
        ]]></text>
        <paragraph><![CDATA[
We are in a situation where we must list all possible combinations, and we cannot reuse any character, but we are limited to 5 character positions. Thus, if we have 26 possible character positions in our password, then the first position has one of 26 possible characters, and the next position has one of 25 characters (since we have used one up), and so on. Thus, the total number of passwords that we can build while satisfying this constraint is:
\begin{eqnarray}
26 \cdot 25 \cdot 24 \cdot 23 \cdot 22 & = & @( 26 \cdot 25 \cdot 24 \cdot 23 \cdot 22 \cdot 21 \cdot ... \cdot 2 \cdot 1 @; %~ %~ %~ %~ 21 \cdot ... \cdot 2 \cdot 1 @) & = & @( 26! @; 21! @)
\end{eqnarray}
        ]]></paragraph>
      </example>
      <definition title="combination" required="true" hooks="math" id="558ee8f964954426a92b2c62fe2aeee6"><![CDATA[
A <i>combination</i> of %k distinct objects from a collection of %n distinct objects is a particular subset of %k objects (such that order does not matter). The number of of combinations of %k objects from a collection of %n objects is denoted and defined as:
\begin{eqnarray}
 #( %n #; %k #) & = & @( %~ %~ %n! @; (%n %- %k)! \cdot %k! @)
\end{eqnarray}
The above notation is read in English as "%n choose %k".
      ]]></definition>
      <example required="true" hooks="math" id="0f2066d489094750bbf82627951ad290">
        <text><![CDATA[
Given a set of objects {@A, @B, @C, @D}, how many different subsets of size 2 are there?
        ]]></text>
        <paragraph><![CDATA[
Here are all ordered sequences of two elements without repetition:
\begin{eqnarray}
 @A@B, @B@A, @A@C, @C@A, @A@D, @D@A, @B@C, @C@B, @B@D, @D@B, @C@D, @D@C
\end{eqnarray}
The number of ordered sequences of the above form is:
\begin{eqnarray}
 @( 4! @; 2! @) & = & 4 \cdot 3 & = & 12
\end{eqnarray}
Notice that we do not care about the order, so @A@B and @B@A should only count once. Thus, we divide the above by 2! to account for this (the number of ways to permute two elements) and get the distinct subsets:
\begin{eqnarray}
 {@A,@B}, {@A,@C}, {@A,@D}, {@B,@C}, {@B,@D}, {@C,@D}
\end{eqnarray}
The number of subsets is then:
\begin{eqnarray}
 @( 4! %~ @; (4-2)! \cdot 2! @) & = & #( 4 #; 2 #) \\
                                & = & @( 4 \cdot 3 \cdot 2 \cdot 1 @; (2 \cdot 1) \cdot (2 \cdot 1) @) \\
                                & = & 6
\end{eqnarray}
        ]]></paragraph>
      </example>
      <example required="true" hooks="math" id="3b08c9496a1342c3b48f0ac93d0867d3">
        <text><![CDATA[
Suppose we have a group of %n people. How many different subgroups of %k people can form? How many subgroups of people (including a group containing no people) form?
        ]]></text>
        <paragraph><![CDATA[
We know that the number of subgroups of size %k is:
\begin{eqnarray}
 #( %n #; %k #)
\end{eqnarray}
We also know that the number of subgroups is just the number of subsets of a set of size %n, which is 2^{%n}. This also tells us that the following identity must hold:
\begin{eqnarray}
 2^{%n} & = & \Sigma^{%n}<sub>%i = 0</sub> #( %n #; %i #)
\end{eqnarray}
        ]]></paragraph>
      </example>
      <example required="true" hooks="math" id="494914a0e0a649fbb8000154c20e9ade">
        <text><![CDATA[
Suppose we have a graph with %n nodes. How many different edges can be drawn between any two nodes in the graph if we are only allowed to draw one edge between each pair of nodes?
        ]]></text>
        <paragraph><![CDATA[
Since we can only draw one edge between each pair of nodes, we need to count the number of ways in which we can choose two nodes from a graph of %n nodes:
\begin{eqnarray}
 #( %n #; 2 #) & = & @( %~ %~ %n! @; (%n %- 2)! \cdot 2! @) \\
               & = & @( %n \cdot (%n %- 1) \cdot (%n %- 2) \cdot ... \cdot 1 @; %~%~ (%n %- 2)! \cdot 2! @) \\
               & = & @( %n \cdot (%n %- 1) @; %~  2! @) \\
               & = & @( %n \cdot (%n %- 1) @; %~ 2 @)
\end{eqnarray}
Notice that the above corresponds to a <a href="#5ed4e735301e4d148d18e217b44484c7">recurrence relation solution</a> and a <a href="#53cedeaee445494eaca43eccffe39027">summation identity</a> we saw earlier.
        ]]></paragraph>
      </example>
      <example required="true" hooks="math" id="dd163c67483e4b2f9462d1b3972f424d">
        <text><![CDATA[
Suppose we have a collection of characters with some duplicate characters: @a, @a, @a, @b, @b, @c, @d. If we do not distinguish between copies of the same character, how many distinct permutations (without repetition) are there of these 7 characters?
        ]]></text>
        <paragraph><![CDATA[
We know there are 7! permutations if we do distinguish between tha duplicate copies of @a and @b that we have. However, the total of 7! overcounts the actual number of distinct permutations. For example (if we relabel the @b copies as @b_1 and @b_2 for clarity), the following two sequences are counted as two distinct permutations:
\begin{eqnarray}
@a, @a, @a, @b_2, @b_1, @c, @d \\
@a, @a, @a, @b_1, @b_2, @c, @d
\end{eqnarray}
But the above is true for every possible sequence. Thus, we are counting 2! as many sequences (since there are 2! ways to arrange @b_1 and @b_2) as we want to count because we do not distinguish between the two copies of @b. Likewise for the three copies of @a, we are counting 3! as many sequences. Thus, we can divide these factors out of our overall computation:
\begin{eqnarray}
 @( 7! %~ @; 3! \cdot 2! @) & = & @( 7 \cdot 6 \cdot 5 \cdot 4 \cdot 3 \cdot 2 \cdot 1 @; %~ (3 \cdot 2 \cdot 1) \cdot (2 \cdot 1) @) & = & 7 \cdot 6 \cdot 5 \cdot 2 & = & 420
\end{eqnarray}
        ]]></paragraph>
      </example>
      <example required="true" id="2ab512c6313341309b81dc3e76175322">
        <text hooks="math" ><![CDATA[
Suppose we want to implement a Python function <code>groups(n, k, m)</code> that takes three integers %n, %k, and %m, and computes how many groups of people can be chosen from %n people, where the size of the group is between %k and %m (inclusive).
        ]]></text>
        <paragraph hooks="math" ><![CDATA[
Since a group of people always has some specific size (i.e., the number of people in the group), we know that we can simply add the counts for each possible size of group (e.g., the number of groups of size three plus the number of groups of size four, and so on). Thus, we can use the <code>sum(...)</code> function to implement our function as follows:
        ]]></paragraph>
        <!-- cmb(n, k)  + cmb(n, k+1)  + ... +  cmb(n, m) -->
        <code hooks="Python"><![CDATA[
@from math @import factorial

# Helper function for combinations, to make things more concise.
@def cmb(n, k):
  @return factorial(n) // (factorial(n-k) * factorial(k))

@def groups(n, k, m):
  @return @sum(cmb(n, i) @for i @in @range(k, m+1))
        ]]></code>
      </example>
    </subsection>
    <subsection title="Generating functions">
      <paragraph hooks="math"><![CDATA[
Generating functions are polynomials used for counting particular kinds of combinations. In order to solve a particular counting problem, we choose an appropriate collection of generating functions and multiply them so that the desired solution is a particular coefficient in the resulting polynomial.
      ]]></paragraph>
      <definition required="true" hooks="math" id="b829c596b71d4c119770d6b1d23d0181"><![CDATA[
Consider any polynomial of the following form for some particular collection of coefficients %a_0, %a_1, %a_2, ...:
\begin{eqnarray}
%a_0 \cdot %x^0 + %a_1 \cdot %x^1 + ... + %a_{%n} \cdot %x^{%n}
\end{eqnarray}
We can also consider a polynomial that is an infinite sum for some particular collection of coefficients %a_0, %a_1, %a_2, ...:
\begin{eqnarray}
%a_0 \cdot %x^0 + %a_1 \cdot %x^1 + ... + %a^{%n} \cdot %x^{%n} + ...
\end{eqnarray}
Any such polynomial is called a <i>generating function</i>.
      ]]></definition>
      <example required="true" hooks="math" id="8bd23811be6f40b382109ec3d44a3399"><![CDATA[
The following is a simple generating function in which all coefficients are 1:
\begin{eqnarray}
1 + %x + %x^2 + %x^3
\end{eqnarray}
      ]]></example>
      <example required="true" hooks="math" id="35694700854d4c2784c6e450506a01a9">
        <text><![CDATA[
Suppose you must are allowed to choose any three coins from an unlimited collection of quarters, nickels, and dimes. In how many different ways can you choose coins so that their total value is 40 cents?
        ]]></text>
        <paragraph><![CDATA[
The following generating function captures the values that a given coin can have:
\begin{eqnarray}
%x<sup>5</sup> + %x<sup>10</sup> + %x<sup>25</sup>
\end{eqnarray}
We are allowed to choose three coins, which means the coefficient of %x<sup>50</sup> in the following product of generating functions will represent our solution:
\begin{eqnarray}
(%x<sup>5</sup> + %x<sup>10</sup> + %x<sup>25</sup>)^3
\end{eqnarray}
We can compute the above explicitly:
\begin{eqnarray}
... & = & (%x<sup>10</sup> + 2%x<sup>15</sup> + %x<sup>20</sup> + 2%x<sup>30</sup> + 2%x<sup>35</sup> + %x<sup>50</sup>) \cdot (%x<sup>5</sup> + %x<sup>10</sup> + %x<sup>25</sup>) \\
... & = &  %x<sup>15</sup> + 3%x<sup>20</sup> + 3%x<sup>25</sup>  
 + %x<sup>30</sup> + 3%x<sup>35</sup> + <b>6%x<sup>40</sup></b> + 3%x<sup>45</sup> + 3%x<sup>55</sup> + 3%x<sup>60</sup>
 + %x<sup>75</sup>
\end{eqnarray}
Thus, there are 6 ways in which we can choose three coins from this collection so that their total value is 40.
        ]]></paragraph>
      </example>
      <example required="true" hooks="math" id="6aea8f7b600d47db92db8b6cb3ad483e">
        <text><![CDATA[
Suppose you throw two 6-sided dice (with labels 1, 2, 3, 4, 5, and 6). In how many different ways can the total from the dice be 9? If all possible rolls are equally likely (i.e., both dice are fair), what is the probability that the total is 9?
        ]]></text>
        <paragraph><![CDATA[
We can use the following generating function to represent each of the individual dice:
\begin{eqnarray}
%x + %x^2 + %x^3 + %x^4 + %x^5 + %x^6
\end{eqnarray}
Then, the coefficient of the %x^9 term in the following product would be our solution:
\begin{eqnarray}
(%x + %x^2 + %x^3 + %x^4 + %x^5 + %x^6)^2
\end{eqnarray}
We can compute the above product explicitly:
\begin{eqnarray}
 ... & = & (%x + %x^2 + %x^3 + %x^4 + %x^5 + %x^6) \cdot (%x + %x^2 + %x^3 + %x^4 + %x^5 + %x^6) \\
 ... & = & %x^2 + 2%x^3 + 3%x^4 + 4%x^5 + 5%x^6 + 6%x^7 + 5%x^8 + <b>4%x^9</b> + 3%x<sup>10</sup> + 2%x<sup>11</sup> + %x<sup>12</sup>
\end{eqnarray}
Thus, there are 4 different ways in which the resulting throw can add up to 9.
        ]]></paragraph>
        <paragraph><![CDATA[
The total number of possible rolls is permutation with repetition of length two using the six numbers in the range from 1 to 6. Thus, there are 6^2 = 36 distinct rolls of the dice. Out of these, 4 can add up to 9, so the probability of getting a 9 is 4/36 = 1/9.
        ]]></paragraph>
      </example>
      <fact title="binomial theorem" required="true" hooks="math" id="5d492542e8814412aa4d6599b08a7c04"><![CDATA[
The following identity holds:
\begin{eqnarray}
(1 + %x)^{%n} & = & #( %n #; 0 #) \cdot %x^0 &nbsp;&nbsp;+&nbsp;&nbsp; #( %n #; 1 #) \cdot %x^1 &nbsp;&nbsp;+&nbsp;&nbsp; #( %n #; 2 #) \cdot %x^2 &nbsp;&nbsp;+&nbsp;&nbsp; ... &nbsp;&nbsp;+&nbsp;&nbsp; #( %n #; %n #) \cdot %x^{%n} \\
              & = & \Sigma^{%n}<sub>%i = 0</sub> #( %n #; %i #) \cdot %x^{%i}
\end{eqnarray}
      ]]></fact>
      <example required="true" hooks="math" id="bc134e07010a453b89e14dfccb84e4c5">
        <text><![CDATA[
Suppose we want to count the number of ways in which we can choose any combination of two items from a set of three items.
        ]]></text>
        <paragraph><![CDATA[
Each item from the collection of three items can either be in the chosen combination (i.e., 1) or not in the chosen combination (i.e., 0). There are three such items. Thus, one way to restate the question is to say the following: suppose we must set three switches to either 0 or 1:
<ul>
  <li>switch <span style="color:red;">@A</span>: 0 or 1;</li>
  <li>switch <span style="color:green;"><b>@B</b></span>: 0 or 1;</li>
  <li>switch <span style="color:blue;">@C</span>: 0 or 1.</li>
</ul>
In how many different ways can we set the switches so that their total adds up to 2? We can model the possible switch settings using exponents in a generating function: %x^0 corresponds to 0, and %x^1 corresponds to 1. Then, note that %x^0 = 1 and %x^1 = %x and consider the following product of generating functions:
\begin{eqnarray}
  <span style="color:red;"><b>(1 + %x)</b></span> \cdot <span style="color:green;"><b>(1 + %x)</b></span> \cdot <span style="color:blue;"><b>(1 + %x)</b></span>
\end{eqnarray}
If we multiply the above out, we get:
\begin{eqnarray}
    <span style="color:red;"><b>1</b></span> \cdot <span style="color:green;"><b>1</b></span> \cdot <span style="color:blue;"><b>1</b></span>
  &nbsp;&nbsp;+&nbsp;&nbsp; <span style="color:red;"><b>1</b></span> \cdot <span style="color:green;"><b>1</b></span> \cdot <span style="color:blue;"><b>%x</b></span>
  &nbsp;&nbsp;+&nbsp;&nbsp; <span style="color:red;"><b>1</b></span> \cdot <span style="color:green;"><b>%x</b></span> \cdot <span style="color:blue;"><b>1</b></span>
  &nbsp;&nbsp;+&nbsp;&nbsp; <span style="color:red;"><b>1</b></span> \cdot <span style="color:green;"><b>%x</b></span> \cdot <span style="color:blue;"><b>%x</b></span>
  &nbsp;&nbsp;+&nbsp;&nbsp; <span style="color:red;"><b>%x</b></span> \cdot <span style="color:green;"><b>1</b></span> \cdot <span style="color:blue;"><b>1</b></span>
  &nbsp;&nbsp;+&nbsp;&nbsp; <span style="color:red;"><b>%x</b></span> \cdot <span style="color:green;"><b>1</b></span> \cdot <span style="color:blue;"><b>%x</b></span>
  &nbsp;&nbsp;+&nbsp;&nbsp; <span style="color:red;"><b>%x</b></span> \cdot <span style="color:green;"><b>%x</b></span> \cdot <span style="color:blue;"><b>1</b></span>
  &nbsp;&nbsp;+&nbsp;&nbsp; <span style="color:red;"><b>%x</b></span> \cdot <span style="color:green;"><b>%x</b></span> \cdot <span style="color:blue;"><b>%x</b></span>
\end{eqnarray}
Rewriting the above using exponents, we get:
\begin{eqnarray}
                             %x<sup><span style="color:red;"><b>0</b></span> + <span style="color:green;"><b>0</b></span> + <span style="color:blue;"><b>0</b></span></sup>
   &nbsp;&nbsp;+&nbsp;&nbsp; %x<sup><span style="color:red;"><b>0</b></span> + <span style="color:green;"><b>0</b></span> + <span style="color:blue;"><b>1</b></span></sup>
   &nbsp;&nbsp;+&nbsp;&nbsp; %x<sup><span style="color:red;"><b>0</b></span> + <span style="color:green;"><b>1</b></span> + <span style="color:blue;"><b>0</b></span></sup>
   &nbsp;&nbsp;+&nbsp;&nbsp; %x<sup><span style="color:red;"><b>0</b></span> + <span style="color:green;"><b>1</b></span> + <span style="color:blue;"><b>1</b></span></sup>
   &nbsp;&nbsp;+&nbsp;&nbsp; %x<sup><span style="color:red;"><b>1</b></span> + <span style="color:green;"><b>0</b></span> + <span style="color:blue;"><b>0</b></span></sup>
   &nbsp;&nbsp;+&nbsp;&nbsp; %x<sup><span style="color:red;"><b>1</b></span> + <span style="color:green;"><b>0</b></span> + <span style="color:blue;"><b>1</b></span></sup>
   &nbsp;&nbsp;+&nbsp;&nbsp; %x<sup><span style="color:red;"><b>1</b></span> + <span style="color:green;"><b>1</b></span> + <span style="color:blue;"><b>0</b></span></sup>
   &nbsp;&nbsp;+&nbsp;&nbsp; %x<sup><span style="color:red;"><b>1</b></span> + <span style="color:green;"><b>1</b></span> + <span style="color:blue;"><b>1</b></span></sup>
\end{eqnarray}
If we collect up %x^{%k} terms with the same powers (e.g., %x^2 + %x^2 + %x^2 = 3 %x^2), we get:
\begin{eqnarray}
1 + 3 %x + 3 %x^2 + %x^3
\end{eqnarray}
Notice that the fact that 3 is the coefficient of %x^2 means that there are three ways in which we can set the switches (i.e., exponents) so that they add up to 2. Thus, the coefficient of %x^2 is exactly the solution we wanted to our counting problem, which in this case is:
\begin{eqnarray}
 #( 3 #; 2 #) & = & 3
\end{eqnarray}
        ]]></paragraph>
      </example>
      <fact required="true" hooks="math" id="e576dc905d994019a6ee4692a2f1a4d5"><![CDATA[
The following identity holds:
\begin{eqnarray}
@( 1 %~ @; (1 %- %x) @) & = & 1 + %x + %x^2 + %x^3 + ... \\
                        & = & \Sigma<sup>&infin;</sup><sub>%i = 0</sub> %x^{%i}
\end{eqnarray}
We can see this is true by multiplying the infinite sum 1 + %x + %x^2 + %x^3 + ... by (1 %- %x):
\begin{eqnarray}
(1 %- %x) \cdot (1 + %x + %x^2 + %x^3 + ...) & = & (1 + %x + %x^2 + %x^3 + ...) %- %x \cdot (1 + %x + %x^2 + %x^3 + ...) \\
                                             & = & (1 + %x + %x^2 + %x^3 + ...) %- (%x + %x^2 + %x^3 + ...) \\
                                             & = & 1
\end{eqnarray}
Notice that this is just a variant of the <a href="#710a9c44d1664350ae20609213d54e87">summation identity</a> and <a href="#bc59e90d48354ea7ba17306ea2c95ca7">recurrence relation solution</a> we saw earlier.
      ]]></fact>
      <fact title="negative binomial theorem" required="true" hooks="math" id="392d1eb544234d65bfeda40c4bdea082"><![CDATA[
The following identity holds:
\begin{eqnarray}
@( 1 %~ @; (1 %- %x)^{%n} @) & = & \Sigma<sup>&infin;</sup><sub>%i = 0</sub> #( %n + %i %- 1 #; %~ %i #) \cdot %x^{%i} \\
                             & = & \Sigma<sup>&infin;</sup><sub>%i = 0</sub> #( %n + %i %- 1 #; %n %- 1 #) \cdot %x^{%i} \\
\end{eqnarray}
      ]]></fact>
      <example required="true" hooks="math" id="9644ad4d806a4e9a83c06d27b904f5c9">
        <text><![CDATA[
Consider the following equation involving three non-negative integer variables %a, %b, and %c:
\begin{eqnarray}
 %a + %b + %c & = & 120
\end{eqnarray}
For how many different assignments of non-negative integers to the variables %a, %b, and %c is the above equation true?
        ]]></text>
        <paragraph><![CDATA[
Suppose we model the possible values of %a using the exponents of the generating function 1 + %x + %x^2 + %x^3 + ..., and we do the same for %b and %c. Then this counting problem can be solved by finding the coefficient of the %x<sup>120</sup> term in the result of the following product of generating functions:
\begin{eqnarray}
 (1 + %x + %x^2 + %x^3 + ...)^3
\end{eqnarray}
Using <a href="#e576dc905d994019a6ee4692a2f1a4d5">an identity</a>, we can convert the above into:
\begin{eqnarray}
 (@( 1&nbsp; @; 1 %- %x @))^3 & = & @(  %~  1 @; (1 %- %x)^3 @)
\end{eqnarray}
Using the <a href="#392d1eb544234d65bfeda40c4bdea082">negative binomial theorem</a>, we then know that the coefficient of the %x<sup>120</sup> term is:
\begin{eqnarray}
 #( 3 + 120 %- 1 #; 3 %- 1 %~ #) & = & #( 122 #; 2 #) \\
                              & = & @( %~  122! @; (122 %- 2)! \cdot 2! @) \\
                              & = & @( 122 \cdot 121 @; %~ 2 \cdot 1 @) \\
                              & = & 61 \cdot 121 \\
                              & = & 7381
\end{eqnarray}
Thus, there are 7381 different ways to assign non-negative integers to %a, %b, and %c so that %a + %b + %c = 120.
        ]]></paragraph>
      </example>
      <example required="true" id="70b3ba0be7cf4a328b2e0523b853d233">
        <text hooks="math"><![CDATA[
Suppose you throw three 100-sided dice (with labels 0, 1, ..., 99). In how many different ways can the total from the dice be 150? If every outcome is equally likely (i.e., the dice are fair), what is the probability that the total is 150?
        ]]></text>
        <paragraph hooks="math"><![CDATA[
We can use the following generating function to represent each of the individual dice:
\begin{eqnarray}
1 + %x + %x^2 + ... + %x<sup>99</sup>
\end{eqnarray}
Writing out the above in its entirety is not practical, but we can use <a href="#e576dc905d994019a6ee4692a2f1a4d5">a known identity</a> to rewrite the above more concisely:
\begin{eqnarray}
1 + %x + %x^2 + ... + %x<sup>99</sup> & = & @( %~ 1  @; (1 %- %x) @) %- @( %~ %x<sup>100</sup> @; (1 %- %x) @) \\
                                      & = & (1 %- %x<sup>100</sup>) \cdot @( %~ 1 @; (1 %- %x) @)
\end{eqnarray}
If we want to count the number of ways in which the three dice can have a total of 150, we need to find the coefficient of %x<sup>150</sup> in the following product of generating functions:
\begin{eqnarray}
(1 + ... + %x<sup>99</sup>)^3 & = & (1 %- %x<sup>100</sup>)^3 \cdot @( %~ 1 @; (1 %- %x) @)^3
\end{eqnarray}
We can expand the first term:
\begin{eqnarray}
... & = & (1 %- 3%x<sup>100</sup> + 3%x<sup>200</sup> %- %x<sup>300</sup>) \cdot @( %~ 1 @; (1 %- %x) @)^3
\end{eqnarray}
We see that the only possible way to obtain %x<sup>150</sup> terms in the above is either when the 1 term or the -3%x<sup>100</sup> term is multiplied by an appropriate term in the right-hand side of the above product. Thus, we have the following coefficient:
\begin{eqnarray}
1 \cdot (<i>coefficient of %x<sup>150</sup> in</i> @(  1 %~ @; (1 %- %x) @)^3) %- 3 \cdot (<i>coefficient of %x<sup>50</sup> in</i> @(  1 %~ @; (1 %- %x) @)^3)
\end{eqnarray}
Using the <a href="#392d1eb544234d65bfeda40c4bdea082">negative binomial theorem</a> to fill in the above, we get:
\begin{eqnarray}
... & = & 1 \cdot #( 3 + 150 %- 1 #; 3 %- 1 #) %- 3 \cdot #( 3 + 50 %- 1 #; 3 %- 1 #) \\
    & = & 11476 %- 3 \cdot 1326 \\
    & = & 7498
\end{eqnarray}
        ]]></paragraph>
        <paragraph hooks="math"><![CDATA[
The total number of possible rolls is permutation with repetition of length two using the six numbers in the range from 0 to 99. Thus, there are 100^3 = 1,000,000 distinct rolls of the dice. Out of these, 7498 can add up to 150, so the probability of getting a 150 is 7498/1,000,000 \approx 0.007.
        ]]></paragraph>
      </example>
      <paragraph hooks="math"><![CDATA[
In the previous two examples, we used an infinite generating function in one case, but a finite generating function in the other case. Why did we make this distinction?
      ]]></paragraph>
      <fact required="true" id="c01f7bda72b14aa684df0fccc326e1bd">
        <text hooks="math"><![CDATA[
Suppose we have the following two generating functions (one is infinite, the other is finite and has a largest exponent of %k):
\begin{eqnarray}
 %f & = & 1 + %x + %x^2 + %x^3 + ... \\
 %g & = & 1 + %x + %x^2 + %x^3 + ... + %x^{%k}
\end{eqnarray}
Suppose we take some exponent %n of each of the two functions (that is, we compute %f^{%n} and %g^{%n}). Notice that for exponents less than or equal to %k, the coefficients for the two functions will actually be exactly the same. However, for any exponent greater than %k, the coefficients will be different (the coefficients in %f^{%n} will be larger). As an example, consider the following:
\begin{eqnarray}
(1 + %x + %x^2 + %x^3 + ...)^2 & = & 1 + 2%x + 3%x^2 + 4%x^3 + ... \\
                    (1 + %x)^2 & = & 1 + 2%x + %x^2
\end{eqnarray}
Notice that the coefficients diverge when the exponent is greater than the largest exponents of the finite generating function.
        ]]></text>
        <paragraph hooks="math"><![CDATA[
Thus, in situations in which we must model some choice of a number of integer values, we must ask: is the exponent corresponding to the coefficient we need greater than the largest possible integer we can choose? If it is, then we must use a finite generating function. If it is not, we can take a shortcut and just use the infinite generating function.
        ]]></paragraph>
      </fact>
      <example required="true" id="b3f148216a394ec89d77f95a9584a160">
        <text hooks="math"><![CDATA[
Suppose we have a tree in which each non-leaf can have either two or three branches. Given this constraint, how many possible trees of height 3 have width 6? We know that there are at least two such trees: (1) a root node with three branches, with a two-branch tree at the end of each branch, and (2) a root node with two branches, with a three-branch tree at the end of each branch. Is there a more systematic way for us to count the number of trees with a certain width?
        ]]></text>
        <paragraph hooks="math"><![CDATA[
We can use products of generating functions to keep track of how many trees there are of each width. For example, a tree of height 2 can have either width 2 or width 3, and we can represent this using the following generating function:
\begin{eqnarray}
%x^2 + %x^3
\end{eqnarray}
The above indicates that there is one tree having width 2 (the coefficient 1 of the term %x^2), and one tree having width 3 (the coefficient of the term %x^3). The number of trees having width 1 is represented using the following generating function:
\begin{eqnarray}
%x
\end{eqnarray}
Suppose we have a generating function %g that represents the number of trees of each width of some height %n. How can we build a generating function that represents the number of trees of each width having height %n+1? The following generating function will accomplish this:
\begin{eqnarray}
%g^2 + %g^3
\end{eqnarray}
In other words, we can introduce a new root node with two subtrees, or a new root node with three subtrees. Suppose we start with %x, which represents the number of trees having width 1:
\begin{eqnarray}
%g & = & %x
\end{eqnarray}
Then, using the formula %g^2 + %g^3, we obtain:
\begin{eqnarray}
%x^2 + %x^3
\end{eqnarray}
If we set %g = %x^2 + %x^3 and apply the same calculation again, we get:
\begin{eqnarray}
(%x^2 + %x^3)^2 + (%x^2 + %x^3)^3 & = & %x^4 + 2%x^5 + 2%x^6 + 3%x^7 + 3%x^8 + %x^9
\end{eqnarray}
Thus, we see that there are indeed only 2 trees of height 3 having width 6.
        ]]></paragraph>
        <paragraph hooks="math"><![CDATA[
If we want to implement a Python function that builds the appropriate generating function given some tree height %n, we can do so in the following way (using a <a href="#B.8">small Python class for representing generating functions</a>):
        ]]></paragraph>
        <code hooks="Python"><![CDATA[
@def treesOfHeight(n):
  g = x
  @for i @in @range(1, n):
    g = g**2 + g**3
  @return g
        ]]></code>
        <text hooks="math"><![CDATA[
To determine the number of trees of a certain height having a certain width, we can access the appropriate coefficient of the resulting generating function:
        ]]></text>
        <code hooks="Python"><![CDATA[
>>> treesOfHeight(3)
1*x**4 + 2*x**5 + 2*x**6 + 3*x**7 + 3*x**8 + 1*x**9
>>> g = treesOfHeight(3)
>>> g[6]
2
        ]]></code>
      </example>
    </subsection>
    <subsection title="Counting by measurements, and computing probability of measurements">
      <paragraph hooks="math"><![CDATA[
In the previous subsections we have seen how to count the number of possible ways that objects from a collection can be selected and assembled into a sequence or new collection, and how generating functions can be used to count the number of possible ways that integer quantities can be combined to yield a particular total. All of these techniques are tools for counting the number of <i>situations</i> (similar to system states) that have a certain <i>measurement</i> value along certain dimensions. In this section, we will use logic to explicitly model the problem of counting only those situations that have a certain measurement. We will then use this framework to define a notion of the probability of a given situation occurring (i.e., being true), and we will show how we can use the counting techniques we have presented in the previous subsections to compute such probabilities.
      ]]></paragraph>
      <example required="true" hooks="math" id="a6a6ece81ea74c43927543bb0327f684">
        <text><![CDATA[
Suppose we have a domain of discourse that consists of two sets: the objects {<b>elephant</b>, <b>hospital</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>, <b>hammer</b>} and the sizes {<b>small</b>, <b>medium</b>, <b>large</b>}. We also have the predicate %[... is of ... size]%, and the following are all predicate instantiations (i.e., variables) that map to true in our model (in the <a href="#0c347fffa8264600ba4945fadd51a409">technical sense</a> we have seen before) of the world, while all other instantiations map to false:
\begin{eqnarray}
%[<b>elephant</b> is of <b>medium</b> size]% \\
%[<b>hospital</b> is of <b>large</b> size]% \\
%[<b>car</b> is of <b>medium</b> size]% \\
%[<b>book</b> is of <b>small</b> size]% \\
%[<b>mouse</b> is of <b>small</b> size]% \\
%[<b>library</b> is of <b>large</b> size]% \\
%[<b>hammer</b> is of <b>small</b> size]%
\end{eqnarray}
Suppose we wish to count the number of objects in {<b>elephant</b>, <b>hospital</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>, <b>hammer</b>} that have each of the possible sizes {<b>small</b>, <b>medium</b>, <b>large</b>}. We could do so as follows:
\begin{eqnarray}
|{ %x | %[%x is of <b>small</b> size]% }| & = & |{<b>book</b>, <b>mouse</b>, <b>hammer</b>}| & = & 3 \\
|{ %x | %[%x is of <b>medium</b> size]% }| & = & |{<b>car</b>, <b>elephant</b>}| & = & 2 \\
|{ %x | %[%x is of <b>large</b> size]% }| & = & |{<b>hospital</b>, <b>library</b>}| & = & 2
\end{eqnarray}
Suppose we want to count for each possible size the <i>fraction</i> of all the objects that have that size. We can do so as follows:
\begin{eqnarray}
@( |{ %x | %[%x is of <b>small</b> size]% }| %~%~%~%~%~%~ @; |{<b>elephant</b>, <b>hospital</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>, <b>hammer</b>}| @) & = & @( 3 @; 7 @) \\
@( |{ %x | %[%x is of <b>medium</b> size]% }| %~%~%~%~%~%~ @; |{<b>elephant</b>, <b>hospital</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>, <b>hammer</b>}| @) & = & @( 2 @; 7 @) \\
@( |{ %x | %[%x is of <b>large</b> size]% }| %~%~%~%~%~%~ @; |{<b>elephant</b>, <b>hospital</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>, <b>hammer</b>}| @) & = & @( 2 @; 7 @)
\end{eqnarray}
        ]]></text>
      </example>
      <definition required="true" hooks="math" id="3914ea917fe14f65a369a023ef44ff16">
        <text><![CDATA[
We use the following notation to denote that the probability that a formula %f is true is %p, where %p is a real number in the range 0 \leq %p \leq 1:
\begin{eqnarray}
\Pr[&nbsp;%f&nbsp;] & = & %p
\end{eqnarray}
Suppose %f is a formula that contains a variable %x (such as "\neg(%x) \vee \top" or "%[%x is green]%"). Assuming that each possible assignment of a constant or value from a set %S to the variable %x is equally likely, we use the following notation to denote that when we choose an element of %S and assign it to %x, the probability of our choosing an replacement for %x that makes the formula %f true is %p:
\begin{eqnarray}
\Pr<sub>%x \in %S</sub>&nbsp;[&nbsp;%f&nbsp;] & = & %p
\end{eqnarray}
        ]]></text>
      </definition>
      <example required="true" hooks="math" id="466a5b3c65f24083b66637210a19c1ff">
        <text><![CDATA[
Suppose we have a domain of discourse that consists of three sets: the objects %O = {<b>elephant</b>, <b>whale</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>}, the sizes {<b>small</b>, <b>medium</b>, <b>large</b>}, and the descriptions {<b>animate</b>, <b>inanimate</b>}. We also have the predicates %[... is of ... size]% and %[... is ...]%, and the following are all predicate instantiations (i.e., variables) that map to true in our model (in the <a href="#0c347fffa8264600ba4945fadd51a409">technical sense</a> we have seen before) of the world, while all other instantiations map to false:
\begin{eqnarray}
%[<b>elephant</b> is of <b>medium</b> size]% & %~ & %[<b>elephant</b> is <b>animate</b>]% \\
%[<b>whale</b> is of <b>large</b> size]% & %~ & %[<b>whale</b> is <b>animate</b>]%\\
%[<b>car</b> is of <b>medium</b> size]% & %~ & %[<b>car</b> is <b>inanimate</b>]%\\
%[<b>book</b> is of <b>small</b> size]% & %~ & %[<b>book</b> is <b>inanimate</b>]%\\
%[<b>mouse</b> is of <b>small</b> size]% & %~ & %[<b>mouse</b> is <b>animate</b>]%\\
%[<b>library</b> is of <b>large</b> size]% & %~ & %[<b>library</b> is <b>inanimate</b>]%
\end{eqnarray}
The two dimensions along which we can measure objects are size and animacy. These dimensions are independent, so we can represent them using orthogonal axes (i.e., rows and columns), as in the diagram below:
<table class="fig_table" style="font-size:12px;">
 <tr>
  <td></td>
  <td></td>
  <td><b>animate</b></td>
  <td><b>inanimate</b></td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td><b>{elephant, mouse, whale}</b><br/><b style="color:firebrick;">3 / 6</b></td>
  <td><b>{book, car, library}</b><br/><b style="color:firebrick;">3 / 6</b></td>
 </tr>
 <tr>
  <td><b>small</b></td>
  <td><b>{book, mouse}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td>{mouse}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{book}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>medium</b></td>
  <td><b>{elephant, car}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td>{elephant}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{car}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>large</b></td>
  <td><b>{library, whale}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td>{whale}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{library}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
</table>
Assuming that the chances of choosing each of the objects in %O are equally likely, we can say the following:
\begin{eqnarray}
\Pr<sub>%x \in %O</sub>&nbsp;[ %[%x is of <b>small</b> size]% ] = @( 2 @; 6 @) \\
\Pr<sub>%x \in %O</sub>&nbsp;[ %[%x is of <b>medium</b> size]% ] = @( 2 @; 6 @) \\
\Pr<sub>%x \in %O</sub>&nbsp;[ %[%x is of <b>large</b> size]% ] = @( 2 @; 6 @) \\
\Pr<sub>%x \in %O</sub>&nbsp;[ %[%x is <b>animate</b>]% ] = @( 3 @; 6 @) \\
\Pr<sub>%x \in %O</sub>&nbsp;[ %[%x is <b>inanimate</b>]% ] = @( 3 @; 6 @)
\end{eqnarray}
        ]]></text>
      </example>
      <definition required="true" hooks="math" id="d6bb7bb2c0574f828f9caf17b6666d62">
        <text><![CDATA[
Suppose we know that for some logical formulas %f and %g, the following is true:
\begin{eqnarray}
\Pr[&nbsp;%f&nbsp;] & = & %p \\
\Pr[&nbsp;%g&nbsp;] & = & %q
\end{eqnarray}
The probabilities that %f and %g are true are <i>independent</i> if the following holds:
<ul>
  <li>if we restrict ourselves to the cases where %f is true, it is still the case that \Pr[&nbsp;%g&nbsp;] = %q;</li>
  <li>if we restrict ourselves to the cases where %f is false, it is still the case that \Pr[&nbsp;%g&nbsp;] = %q;</li>
  <li>if we restrict ourselves to the cases where %g is true, it is still the case that \Pr[&nbsp;%f&nbsp;] = %p;</li>
  <li>if we restrict ourselves to the cases where %g is false, it is still the case that \Pr[&nbsp;%f&nbsp;] = %p.</li>
</ul>
        ]]></text>
      </definition>
      <definition required="true" hooks="math" id="54abc3213f0e4fdcbded4c2eb55e0897">
        <text><![CDATA[
Two logical formulas %f and %g are <i>mutually exclusive</i> if the following holds:
<ul>
  <li>if we restrict ourselves to the cases where %f is true, it is still the case that %g is false;</li>
  <li>if we restrict ourselves to the cases where %g is true, it is still the case that %f is false.</li>
</ul>
        ]]></text>
      </definition>
      <example required="true" hooks="math" id="b3f0a17c3197407e8a3c35ae4cbf3bb2">
        <text><![CDATA[
Let the domain of discourse be %O = {<b>elephant</b>, <b>whale</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>}. Are the probabilities for the dimensions in the following table independent?
<table class="fig_table" style="font-size:12px;">
 <tr>
  <td></td>
  <td><b>animate</b><br/><b>{elephant, mouse, whale}</b></td>
  <td><b>inanimate<br/><b>{book, car, library}</b></td>
 </tr>
 <tr>
  <td><b>small</b><br/><b>{book, mouse}</b></td>
  <td>{mouse}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{book}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>medium</b><br/><b>{car, elephant}</b></td>
  <td>{elephant}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{car}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>large</b><br/><b>{whale, library}</b></td>
  <td>{whale}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{library}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
</table>
Yes. If we restrict ourselves to any measurement along the size dimension, the probability of an element being animate is 1/2, which is also the <i>overall</i> probability (across all sizes) of an object being animate. Likewise, if we restrict ourselves to a particular animacy column, the probability that an object is of a particular size (e.g., small) is always 1/3, which is also the overall probability of an object being that size.
        ]]></text>
      </example>
      <example required="true" hooks="math" id="c19d3c8586c94f6a921e60e1b02acc12">
        <text><![CDATA[
Are the probabilities for the dimensions in the following table independent?
<table class="fig_table" style="font-size:12px;">
 <tr>
  <td></td>
  <td><b>can fly</b><br/><b>{flying squirrel, bat, robin}</b></td>
  <td><b>cannot fly<br/><b>{wolf, bear}</b></td>
 </tr>
 <tr>
  <td><b>has fur</b><br/><b>{flying squirrel, bat, wolf, bear}</b></td>
  <td>{bat, flying squirrel}<br/><b style="color:firebrick;">2 / 5</b></td>
  <td>{wolf, bear}<br/><b style="color:firebrick;">2 / 5</b></td>
 </tr> 
 <tr>
  <td><b>has no fur</b><br/><b>{robin}</b></td>
  <td>{robin}<br/><b style="color:firebrick;">1 / 5</b></td>
  <td>\emptyset<br/><b style="color:firebrick;">0 / 5</b></td>
 </tr>
</table>
No, they are not independent because the overall probability that an element can fly is 3/5, while the probability that an element can fly if it has no fur is 1 and the probability that an element can fly if it does have fur is 1/2.
        ]]></text>
      </example>
      <example required="true" hooks="math" id="9da90fc9676f41078c453d26547af531">
        <text><![CDATA[
Are the probabilities for the dimensions in the following table independent?
<table class="fig_table" style="font-size:12px;">
 <tr>
  <td></td>
  <td><b>can fly</b><br/><b>{flying squirrel, bat, robin, crow}</b></td>
  <td><b>cannot fly<br/><b>{bear, crocodile}</b></td>
 </tr>
 <tr>
  <td><b>has fur</b><br/><b>{flying squirrel, bat, bear}</b></td>
  <td>{bat, flying squirrel}<br/><b style="color:firebrick;">2 / 6</b></td>
  <td>{bear}<br/><b style="color:firebrick;">1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>has no fur</b><br/><b>{robin, crow, crocodile}</b></td>
  <td>{robin, crow}<br/><b style="color:firebrick;">2 / 6</b></td>
  <td>{crocodile}<br/><b style="color:firebrick;">1 / 6</b></td>
 </tr>
</table>
Yes, the overall probability that an element has fur is 1/2, which is also the probability that an animal that can fly has fur, and the the probability that an animal that cannot fly has fur. Likewise, the overall probability that an animal can fly is 2/3, which is also the probability that an animal with fur can fly, and the probability that an animal without fur can fly.
        ]]></text>
      </example>
      <fact required="true" hooks="math" id="34847b5b03be4d828f576c213ddb41da">
        <text><![CDATA[
Suppose we know that for some logical formulas %f and %g, the following is true:
\begin{eqnarray}
\Pr[&nbsp;%f&nbsp;] & = & %p \\
\Pr[&nbsp;%g&nbsp;] & = & %q
\end{eqnarray}
If the probabilities for %f and %g are <i>independent</i>, then we have that:
\begin{eqnarray}
  \Pr[&nbsp;%f \wedge %g&nbsp;] & = & %p \cdot %q
\end{eqnarray}
        ]]></text>
      </fact>
      <fact required="true" hooks="math" id="f20ad7cd3da6435c93e7713bc1de1397">
        <text><![CDATA[
Suppose we know that for some logical formulas %f, the following is true:
\begin{eqnarray}
\Pr[&nbsp;%f&nbsp;] & = & %p
\end{eqnarray}
Then we have that:
\begin{eqnarray}
\Pr[&nbsp;\neg(%f)&nbsp;] & = & 1 %- %p \\
\Pr[&nbsp;%f \wedge %g&nbsp;] & = & %p \cdot %q
\end{eqnarray}
        ]]></text>
      </fact>
      <text hooks="math" ><![CDATA[
As long as dimensions are independent and different measurements are mutually exclusive, the facts above are sufficient to determine the probability of any logical formula because the logical operators \neg and \wedge are functionally complete (i.e., they can be used to represent all other logical operations).
      ]]></text>
      <fact required="true" hooks="math" id="d3c827818f0c467eae71bac30e94fc77">
        <text><![CDATA[
Suppose we know that for some logical formulas %f and %g, the following is true:
\begin{eqnarray}
\Pr[&nbsp;%f&nbsp;] & = & %p \\
\Pr[&nbsp;%g&nbsp;] & = & %q
\end{eqnarray}
Then if %f and %g are <i>mutually exclusive</i> (i.e., <i><b>can never both be true at the same time</b></i>), we have:
\begin{eqnarray}
  \Pr[&nbsp;%f \vee %g&nbsp;] & = & %p + %q
\end{eqnarray}
One common situation in which this arises is if the two formulas represent different measurements of an object along the same dimension.
        ]]></text>
      </fact>
      <fact required="true" hooks="math" id="43a96350455f45e09544fe92da280fe4">
        <text><![CDATA[
Suppose we know that for some logical formulas %f and %g, the following is true:
\begin{eqnarray}
\Pr[&nbsp;%f&nbsp;] & = & %p \\
\Pr[&nbsp;%g&nbsp;] & = & %q
\end{eqnarray}
If the probabilities that %f and %g are true are <i>independent</i>, then we have that:
\begin{eqnarray}
\Pr[&nbsp;%f \vee %g&nbsp;] & = & %p + %q %- %p \cdot %q \\
                            & = & 1 %- (1 %- %p) \cdot (1 %- %q)
\end{eqnarray}
Notice that 1 %- (1 %- %p) \cdot (1 %- %q) can be derived as the probability of the formula \neg(\neg(%f) \wedge \neg(%g)); the latter formula is equivalent to %f \vee %g via De Morgan's Law.
        ]]></text>
      </fact>
      <example required="true" hooks="math" id="1ea7a17c50de4e75a94056fd7d142944">
        <text><![CDATA[
Suppose we have a domain of discourse that consists of three sets: the objects {<b>elephant</b>, <b>whale</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>}, the sizes {<b>small</b>, <b>medium</b>, <b>large</b>}, and the descriptions {<b>animate</b>, <b>inanimate</b>}. We also have the predicates %[... is of ... size]% and %[... is ...]%, and the axioms as exactly like those in the <a href="#466a5b3c65f24083b66637210a19c1ff">related example above</a>.
<table class="fig_table" style="font-size:12px;">
 <tr>
  <td></td>
  <td></td>
  <td><b>animate</b></td>
  <td><b>inanimate</b></td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td><b>{elephant, mouse, whale}</b><br/><b style="color:firebrick;">3 / 6</b></td>
  <td><b>{book, car, library}</b><br/><b style="color:firebrick;">3 / 6</b></td>
 </tr>
 <tr>
  <td><b>small</b></td>
  <td><b>{book, mouse}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td>{mouse}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{book}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>medium</b></td>
  <td><b>{elephant, car}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td>{elephant}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{car}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>large</b></td>
  <td><b>{library, whale}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td>{whale}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{library}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
</table>
        ]]></text>
        <unorderedlist>
          <item>
            <text><![CDATA[
What is the probability that a replacement for %x chosen uniformly at random from %O = {<b>elephant</b>, <b>whale</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>} is small?
            ]]></text>
            <solution><![CDATA[
The following is a visual representation of the set in question:
<table class="fig_table" style="font-size:12px;">
 <tr>
  <td></td>
  <td><b>animate</b><br/><b>{elephant, mouse, whale}</b><br/><b style="color:firebrick;">3 / 6</b></td>
  <td><b>inanimate<br/><b>{book, car, library}</b><br/><b style="color:firebrick;">3 / 6</b></td>
 </tr>
 <tr>
  <td style="background-color:pink;"><b>small</b><br/><b>{book, mouse}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td style="background-color:pink;">{mouse}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td style="background-color:pink;">{book}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>medium</b><br/><b>{elephant, car}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td>{elephant}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{car}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>large</b><br/><b>{library, whale}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td>{whale}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{library}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
</table>
We can compute the probability as follows:
\begin{eqnarray}
\Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>small</b> size]%&nbsp;] 
  & = & @( %~%~%~%~%~%~ |{ %x | %[%x is of <b>small</b> size]% }|  @; |{<b>elephant</b>, <b>whale</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>}| @) \\
  & = & @( %~%~%~%~%~%~ |{<b>book</b>, <b>mouse</b>}| @; |{<b>elephant</b>, <b>whale</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>}| @) \\
  & = & @( 2 @; 6 @) \\
\end{eqnarray}
            ]]></solution>
          </item>
          <item>
            <text><![CDATA[
What is the probability that a replacement for %x chosen uniformly at random from %O = {<b>elephant</b>, <b>whale</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>} is medium in size <b>and</b> animate?
            ]]></text>
            <solution><![CDATA[       
The following is a visual representation of the possibilities specified by the formula:
<table class="fig_table" style="font-size:12px;">
 <tr>
  <td></td>
  <td style="background-color:lightblue;"><b>animate</b><br/><b>{elephant, mouse, whale}</b><br/><b style="color:firebrick;">3 / 6</b></td>
  <td><b>inanimate<br/><b>{book, car, library}</b><br/><b style="color:firebrick;">3 / 6</b></td>
 </tr>
 <tr>
  <td><b>small</b><br/><b>{book, mouse}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td style="background-color:lightblue;">{mouse}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{book}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td style="background-color:pink;"><b>medium</b><br/><b>{elephant, car}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td style="background-color:thistle;">{elephant}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td style="background-color:pink;">{car}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>large</b><br/><b>{library, whale}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td style="background-color:lightblue;">{whale}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{library}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
</table>
Since <b>medium</b> and <b>animate</b> are measurements along two independent measurement dimensions (i.e., size and animacy), any %x we choose must have exactly one measurement along each dimension. Thus, we must multiply the probability that %x is medium in size by the probability that %x is animate:
\begin{eqnarray}
\Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>medium</b> size]% \wedge %[%x is <b>animate</b>]%&nbsp;] 
  & = & \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>medium</b> size]%&nbsp;] \cdot \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is <b>animate</b>]%&nbsp;]  \\
  & = & @( 2 @; 6 @) \cdot @( 1 @; 2 @) \\
  & = & @( 2 @; 12 @) \\
  & = & @( 1 @; 6@)
\end{eqnarray}
            ]]></solution>
          </item>
          <item>
            <text><![CDATA[
What is the probability that a replacement for %x chosen uniformly at random from %O = {<b>elephant</b>, <b>whale</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>} is small <b>or</b> large in size?
            ]]></text>
            <solution><![CDATA[
The following is a visual representation of the possibilities specified by the formula:
<table class="fig_table" style="font-size:12px;">
 <tr>
  <td></td>
  <td><b>animate</b><br/><b>{elephant, mouse, whale}</b><br/><b style="color:firebrick;">3 / 6</b></td>
  <td><b>inanimate<br/><b>{book, car, library}</b><br/><b style="color:firebrick;">3 / 6</b></td>
 </tr>
 <tr>
  <td style="background-color:pink;"><b>small</b><br/><b>{book, mouse}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td style="background-color:pink;">{mouse}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td style="background-color:pink;">{book}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>medium</b><br/><b>{elephant, car}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td>{elephant}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{car}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td style="background-color:pink;"><b>large</b><br/><b>{library, whale}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td style="background-color:pink;">{whale}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td style="background-color:pink;">{library}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
</table>
Since <b>small</b> and <b>large</b> are both mutually exclusive measurements of %x along the <i>same</i> measurement dimension (i.e., size), %x can never have both measurements at the same time. Thus, we can add the probabilities that %x is of each of these two sizes:
\begin{eqnarray}
\Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>small</b> size]% \vee %[%x is of <b>large</b> size]%&nbsp;] 
  & = & \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>small</b> size]%&nbsp;] + \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>large</b> size]%&nbsp;]  \\
  & = & @( 2 @; 6 @) + @( 2 @; 6 @) \\
  & = & @( 4 @; 6 @) \\
  & = & @( 2 @; 3 @)
\end{eqnarray}
            ]]></solution>
          </item>
          <item>
            <text><![CDATA[
What is the probability that a replacement for %x chosen uniformly at random from %O = {<b>elephant</b>, <b>whale</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>} is small <b>or</b> medium in size, <b>and</b> is inanimate?
            ]]></text>
            <solution><![CDATA[
The following is a visual representation of the possibilities specified by the formula:
<table class="fig_table" style="font-size:12px;">
 <tr>
  <td></td>
  <td><b>animate</b><br/><b>{elephant, mouse, whale}</b><br/><b style="color:firebrick;">3 / 6</b></td>
  <td style="background-color:lightblue;"><b>inanimate<br/><b>{book, car, library}</b><br/><b style="color:firebrick;">3 / 6</b></td>
 </tr>
 <tr>
  <td style="background-color:pink;"><b>small</b><br/><b>{book, mouse}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td style="background-color:pink;">{mouse}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td style="background-color:thistle;">{book}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td style="background-color:pink;"><b>medium</b><br/><b>{elephant, car}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td style="background-color:pink;">{elephant}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td style="background-color:thistle;">{car}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>large</b><br/><b>{library, whale}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td>{whale}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td style="background-color:lightblue;">{library}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
</table> 
Since <b>small</b> and <b>medium</b> are both possible measurements of %x along the <i>same</i> measurement dimension (i.e., size), %x can never have both measurements at the same time. Thus, we can add the probabilities that %x is of each of these two sizes. However, if we also want to consider its animacy, we need to multiply the probability that its size is small or medium by the probability that it is inanimate.
\begin{eqnarray}
\Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;(%[%x is of <b>small</b> size]% \vee %[%x is of <b>medium</b> size]%) \wedge %[%x is <b>inanimate</b>]%&nbsp;]
\end{eqnarray}
Note the parentheses in the formula above. These are important, as they determine the order of operations when we compute the probability:
\begin{eqnarray}
  %~ %~ ... & = & (\Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>small</b> size]%&nbsp;] + \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>medium</b> size]%&nbsp;]) \cdot \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is <b>inanimate</b>]%&nbsp;]  \\
  & = & (@( 2 @; 6 @) + @( 2 @; 6 @)) \cdot @( 1 @; 2 @) \\
  & = & @( 4 @; 6 @) \cdot @( 1 @; 2 @) \\
  & = & @( 2 @; 6 @) \\
  & = & @( 1 @; 3 @)
\end{eqnarray}
The above is equivalent to the following (by the distributive property of \wedge across \vee, and the corresponding distributive property of multiplication across addition):
\begin{eqnarray}
\Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;(%[%x is of <b>small</b> size]% \wedge %[%x is <b>inanimate</b>]%) \vee (%[%x is of <b>medium</b> size]% \wedge %[%x is <b>inanimate</b>]%)&nbsp;]
\end{eqnarray}
We can compute the corresponding probability:
\begin{eqnarray}
  %~ %~ ... & = & 
    (\Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>small</b> size]%&nbsp;] \cdot \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is <b>inanimate</b>]%&nbsp;])
    + (\Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>medium</b> size]%&nbsp;] \cdot \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is <b>inanimate</b>]%&nbsp;]) 
      \\
  & = & (@( 2 @; 6 @) \cdot @( 1 @; 2 @)) + (@( 2 @; 6 @) \cdot @( 1 @; 2 @))  \\
  & = & @( 1 @; 6 @) \cdot @( 1 @; 6 @) \\
  & = & @( 2 @; 6 @) \\
  & = & @( 1 @; 3 @)
\end{eqnarray}
            ]]></solution>
          </item>
          
          
          
          
          
          
          
          
          
          
          <item>
            <text><![CDATA[
What is the probability that a replacement for %x chosen uniformly at random from %O = {<b>elephant</b>, <b>whale</b>, <b>car</b>, <b>book</b>, <b>mouse</b>, <b>library</b>} is medium in size <b>or</b> animate?
            ]]></text>
            <solution><![CDATA[
The following is a visual representation of the possibilities specified by the formula. Notice that we must be careful not to "double count" the intersection of the regions:
<table class="fig_table" style="font-size:12px;">
 <tr>
  <td></td>
  <td style="background-color:lightblue;"><b>animate</b><br/><b>{elephant, mouse, whale}</b><br/><b style="color:firebrick;">3 / 6</b></td>
  <td><b>inanimate<br/><b>{book, car, library}</b><br/><b style="color:firebrick;">3 / 6</b></td>
 </tr>
 <tr>
  <td><b>small</b><br/><b>{book, mouse}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td style="background-color:lightblue;">{mouse}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{book}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td style="background-color:pink;"><b>medium</b><br/><b>{elephant, car}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td style="background-color:thistle;">{elephant}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td style="background-color:pink;">{car}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>large</b><br/><b>{library, whale}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td style="background-color:lightblue;">{whale}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{library}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
</table>
Since <b>medium</b> and <b>animate</b> are independent, we can add the probabilities, but we must subtract the probability of the intersection occurring out of the total.
\begin{eqnarray}
\Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>medium</b> size]% \vee %[%x is <b>inanimate</b>]%&nbsp;]
\end{eqnarray}
We then compute the probability:
\begin{eqnarray}
  %~ %~ ... & = & 
    \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>medium</b> size]%&nbsp;] 
    + \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is <b>animate</b>]%&nbsp;]
    %- (\Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>medium</b> size]%&nbsp;] \cdot \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is <b>animate</b>]%&nbsp;])  \\
  & = & @( 3 @; 6 @) + @( 2 @; 6 @) %- (@( 3 @; 6 @) \cdot @( 2 @; 6 @)) \\
  & = & @( 5 @; 6 @) %- @( 6 @; 36 @) \\
  & = & @( 4 @; 6 @) \\
  & = & @( 2 @; 3 @)
\end{eqnarray}
By De Morgan's Law, the above is equivalent to the following:
\begin{eqnarray}
  \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;\neg(\neg(%[%x is of <b>medium</b> size]%) \wedge \neg(%[%x is <b>inanimate</b>]%))&nbsp;]
\end{eqnarray}
The visual representation can be adjusted to reflect the above (in the diagram below, we show the intersection of the complements; this is then subtract from the overall set or from the probability of 1 to obtain the desired subset):
<table class="fig_table" style="font-size:12px;">
 <tr>
  <td></td>
  <td><b>animate</b><br/><b>{elephant, mouse, whale}</b><br/><b style="color:firebrick;">3 / 6</b></td>
  <td style="background-color:lightblue;"><b>inanimate<br/><b>{book, car, library}</b><br/><b style="color:firebrick;">3 / 6</b></td>
 </tr>
 <tr>
  <td style="background-color:pink;"><b>small</b><br/><b>{book, mouse}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td style="background-color:pink;">{mouse}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td style="background-color:thistle;">{book}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td><b>medium</b><br/><b>{elephant, car}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td>{elephant}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td style="background-color:lightblue;">{car}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
 <tr>
  <td style="background-color:pink;"><b>large</b><br/><b>{library, whale}</b><br/><b style="color:firebrick;">2 / 6</b></td>
  <td style="background-color:pink;">{whale}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td style="background-color:thistle;">{library}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
 </tr> 
</table> 
We can compute the corresponding probability:
\begin{eqnarray}
  %~ %~ ... & = & 
    1 %- ((1 %- \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is of <b>medium</b> size]%&nbsp;])
    \cdot (1 %- \Pr<sub>%x \in %O</sub>&nbsp;[&nbsp;%[%x is <b>animate</b>]%&nbsp;])) \\
  & = & 1 %- ((1 %- @( 2 @; 6 @) ) \cdot (1 %- @( 3 @; 6 @))) \\
  & = & 1 %- (@( 4 @; 6 @) \cdot @( 3 @; 6 @)) \\
  & = & 1 %- @( 12 @; 36 @) \\
  & = & 1 %- @( 1 @; 3 @) \\
  & = & @( 2 @; 3 @)
\end{eqnarray}
            ]]></solution>
          </item>
          
          
          
          
          
          
        </unorderedlist>
      </example>
      <example required="true" hooks="math" id="a09a087317264723914b6b5075891b9d">
        <text><![CDATA[
Suppose we have the following assumptions about the probabilities that two boolean variables are true:
\begin{eqnarray}
  \Pr[ %x \equiv \top ] & = & @( 1 @; 2 @) \\
  \Pr[ %y \equiv \top ] & = & @( 1 @; 2 @) 
\end{eqnarray}
If we count the total number of models involving these two boolean variables, we see that each individual model is 1/4 of the total number of models:
<table class="fig_table truthtable">
  <tr>
    <td><b>%x</b></td>
    <td><b>%y</b></td>
    <td></td>
  </tr>
  <tr><td>\top</td><td>\top</td><td>1/4</td></tr>
  <tr><td>\top</td><td>\bot</td><td>1/4</td></tr>
  <tr><td>\bot</td><td>\top</td><td>1/4</td></tr>
  <tr><td>\bot</td><td>\bot</td><td>1/4</td></tr>
</table>
Since %x and %y are independent dimensions of measurement (each variable can independently either have one of the two distinct "measurements", or values, \top or \bot), we can compute the probability of the particular model {%x \mapsto \top, %y \mapsto \top} being selected as:
\begin{eqnarray}
  \Pr[ (%x \equiv \top) \wedge (%y \equiv \top) ] & = & @( 1 @; 2 @) \cdot @( 1 @; 2 @) \\
                                                  & = & @( 1 @; 4 @)
\end{eqnarray}
However, we cannot directly compute the following because the values of %x and %y are not distinct measurements along the same dimension:
\begin{eqnarray}
  \Pr[ (%x \equiv \top) \vee (%y \equiv \top) ] & = & ...
\end{eqnarray}
Instead, we need to use algebraic laws of logical operators (in particular, <a href="#abd9f8f2a89b44018970dffc4732b77b">De Morgan's Law</a>) to convert the formula above into one that uses only the negation and conjunction operators (\neg and \wedge):
\begin{eqnarray}
  \Pr[ (%x \equiv \top) \vee (%y \equiv \top) ] & = & \Pr[ \neg(\neg(%x \equiv \top) \wedge \neg(%y \equiv \top)) ]
\end{eqnarray}
Once we have the formula above, we can apply the known <a href="#34847b5b03be4d828f576c213ddb41da">algebraic facts</a> for computing probabilities of formulas:
\begin{eqnarray}
  \Pr[ \neg(%x \equiv \top) ] & = & 1 %- \Pr[ %x \equiv \top ] & = & 1 %- @( 1 @; 2 @) & = & @( 1 @; 2 @) \\
  \Pr[ \neg(%y \equiv \top) ] & = & 1 %- \Pr[ %y \equiv \top ] & = & 1 %- @( 1 @; 2 @) & = & @( 1 @; 2 @)
\end{eqnarray}
We can now combine the above:
\begin{eqnarray}
  \Pr[ \neg(%x \equiv \top) \wedge \neg(%y \equiv \top) ] & = & \Pr[ \neg(%x \equiv \top) ] \cdot \Pr[ \neg(%y \equiv \top) ] \\
                                                          & = &  @( 1 @; 2 @) \cdot @( 1 @; 2 @) \\
                              & = & @( 1 @; 4 @)
\end{eqnarray}
Finally, we have:
\begin{eqnarray}
  \Pr[ \neg(\neg(%x \equiv \top) \wedge \neg(%y \equiv \top)) ] & = & 1 %- \Pr[ \neg(%x \equiv \top) \wedge \neg(%y \equiv \top) ] \\
                                                          & = &  1 %- @( 1 @; 4 @) \\
                              & = & @( 3 @; 4 @)
\end{eqnarray}
Thus, we have computed:
\begin{eqnarray}
  \Pr[ (%x \equiv \top) \vee (%y \equiv \top) ] & = & @( 3 @; 4 @)
\end{eqnarray}
        ]]></text>
      </example>
      <example required="true" hooks="math" id="9d455cf85ec4443e82e9779340f5dc69">
        <text><![CDATA[
Suppose we have the following assumptions about the probabilities that two boolean variables are true (note that \Pr[ %x ] and \Pr[ %x \equiv \top ] have the same meaning):
\begin{eqnarray}
  \Pr[ %x ] & = & @( 1 @; 3 @) \\
  \Pr[ %y ] & = & @( 3 @; 5 @) 
\end{eqnarray}
We want to compute the probability that the following formula is true:
\begin{eqnarray}
  %x \Rightarrow %y
\end{eqnarray}
We can do so by first converting the formula using algebraic laws so that it only contains the logical operators \neg and \wedge:
\begin{eqnarray}
  %x \Rightarrow %y & \equiv & \neg(%x) \vee %y \\
                    & \equiv & \neg(\neg(\neg(%x)) \wedge \neg(%y)) \\
                    & \equiv & \neg(%x \wedge \neg(%y))
\end{eqnarray}
We compute the probability of \neg(%y):
\begin{eqnarray}
  \Pr[ \neg(%y \equiv \top) ] & = & 1 %- @( 3 @; 5 @) & = & @( 2 @; 5 @)                          
\end{eqnarray}
We also compute the probability of %x \wedge \neg(%y):
\begin{eqnarray}
  \Pr[ %x \wedge \neg(%y) ] & = & \Pr[ %x ] \cdot \Pr[ \neg(%y) ] & = & @( 1 @; 3 @) \cdot @( 2 @; 5 @) & = & @( 2 @; 15 @)
\end{eqnarray}
Finally, we can compute the probability of the overall formula:
\begin{eqnarray}
  \Pr[ \neg(%x \wedge \neg(%y)) ] & = & 1 %- @( 2 @; 15 @) & = & @( 13 @; 15 @)
\end{eqnarray}
Thus, we can say that:
\begin{eqnarray}
  \Pr[ %x \Rightarrow %y ] & = & 1 %- @( 2 @; 15 @) & = & @( 13 @; 15 @)
\end{eqnarray}
        ]]></text>
      </example>
      
      
      
      
      
    
    
    
    
    
    
    

      
      
      
      
      
      <example required="true" hooks="math" id="9d19849a6b964dc49208e8589f84bcd8">
        <text><![CDATA[
Suppose we have the following assumptions about the probabilities that two boolean variables are true, and that a particular formula is true:
\begin{eqnarray}
  \Pr[ %x ] & = & %p\\
  \Pr[ %y ] & = & @( 3 @; 4 @) \\
  \Pr[ %x \Rightarrow %y ] & = & @( 9 @; 10 @) 
\end{eqnarray}
Note that we do not know exactly what the probability is of %x being true, but we know it is some real number %p such that 0 \leq %p \leq 1.
        ]]></text>
        <paragraph><![CDATA[
We note that %x \Rightarrow %y \equiv \neg(%x \wedge \neg(%y)), and compute the probability that \neg(%x \wedge \neg(%y)) is true (using %p wherever we need the probability that %x is true):
\begin{eqnarray}
  \Pr[ %x \Rightarrow %y ] & = & \Pr[ \neg(%x \wedge \neg(%y)) ] & = & 1 %- (%p \cdot (1 %- @( 3 @; 4 @)))
\end{eqnarray}
At this point, since \Pr[ %x \Rightarrow %y ] = 9/10, we can set up an equation with a single unknown real number variable %p:
\begin{eqnarray}
  @( 9 @; 10 @) & = & 1 %- (%p \cdot (1 %- @( 3 @; 4 @))) \\
  @( 9 @; 10 @) %- 1 & = & %- (%p \cdot (1 %- @( 3 @; 4 @))) \\
  1 %- @( 9 @; 10 @) & = & %p \cdot (1 %- @( 3 @; 4 @)) \\
       @( 1 @; 10 @) & = & %p \cdot @( 1 @; 4 @) \\
                  %p & = & @( 4 @; 10 @) \\
                  %p & = & @( 2 @; 5 @)
\end{eqnarray}
Thus, we have determined the probability \Pr[ %x ] (i.e., the probability that %x is true) to be 2/5.
        ]]></paragraph>
      </example>
      <example required="true" hooks="math" id="12cab9b3d34c456b9fda407857cf50f9">
        <text><![CDATA[
Suppose that that we are working with perfect trees in which each non-leaf node is equally likely to have two or three branches (i.e., the probability that a non-leaf node has two branches is 1/2, and the probability it has three branches is also 1/2). Then we could write the following generating function for a tree of height 2; in this generating function, in each term %c \cdot %x^{%k} the coefficient %c represents the probability that a tree would have width %k:
\begin{eqnarray}
  @( 1 @; 2 @) \cdot %x^2 + @( 1 @; 2 @) \cdot %x^3
\end{eqnarray}
The generating function for a tree of height 3 would then be as follows:
\begin{eqnarray}
  @( 1 @; 2 @) \cdot (@( 1 @; 2 @) \cdot %x^2 + @( 1 @; 2 @) \cdot %x^3)^2 + @( 1 @; 2 @) \cdot (@( 1 @; 2 @) \cdot %x^2 + @( 1 @; 2 @) \cdot %x^3)^3
\end{eqnarray}
In the above generating function, the coefficient of %x^4 would be the probability that a tree of height 3 has width 4.
        ]]></text>
      </example>
      <!--<example required="true" hooks="math" id="7f45bdf024284e56946b18e4e390e27c">
        <text><![CDATA[
    <table class="fig_table" style="font-size:12px;">
 <tr>
  <td></td>
  <td></td>
  <td colspan="3"><b>animate</b></td>
  <td colspan="3"><b>inanimate</b></td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td><b>elephant</b></td>
  <td><b>mouse</b></td>
  <td><b>whale</b></td>
  <td><b>book</b></td>
  <td><b>car</b></td>
  <td><b>library</b></td>
 </tr>
 <tr>
  <td><b>small</b></td>
  <td><b>book</b><br/></td>
  <td>{mouse}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{book}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr> 
 <tr>
  <td></td>
  <td><b>mouse</b></td>
  <td>{mouse}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{book}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr> 
 <tr>
  <td><b>medium</b></td>
  <td><b>elephant</b></td>
  <td>{elephant}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{car}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr> 
 <tr>
  <td></td>
  <td><b>car</b></td>
  <td>{elephant}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{car}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr> 
 <tr>
  <td><b>large</b></td>
  <td><b>library</b></td>
  <td>{whale}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{library}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr> 
 <tr>
  <td></td>
  <td><b>whale</b></td>
  <td>{whale}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td>{library}<br/><b style="color:firebrick;">6 / 36 = 1 / 6</b></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr> 
</table>
        ]]></text>
      </example>-->
    </subsection>
    <assignment title="Permutations, Combinations, and Generating Functions">
      <instructions>
        <text><![CDATA[
In this assignment you will solve problems requiring counting and computation of probabilities.
        ]]></text>
        <paragraph><![CDATA[
You may import the following library function in your module:
        ]]></paragraph>
        <code hooks="Python">
@from math @import factorial
@from fractions @import Fraction
        </code>
        <text hooks="math"><![CDATA[
<b style="color:firebrick;">Your solution may not import any other modules or employ any external library functions.</b> The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
        ]]></text>
      </instructions>
      <problems>
        <problem>
          <text hooks="math"><![CDATA[
For each of the following descriptions, define a mathematical expression for computing the specified count by using multiplication <code>*</code>, integer division <code>//</code>, addition <code>+</code>, and/or the <code>factorial()</code> function. In your Python file, define the variables <code>oneA</code>, <code>oneB</code>, <code>oneC</code>, and so on. For example, a solution to part (h) might look as follows:
          ]]></text>
          <code hooks="Python"><![CDATA[
oneH = factorial(5) // factorial(2)
          ]]></code>
          <text hooks="math"><![CDATA[
In the above manner, solve the following problem parts.
          ]]></text>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
You are given the collection of characters {@a, @b, @c, @d, @e, @f, @g}, and you must count the number of ordered sequences of length four that can be made using these characters in which no character repeats.
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
You are given the collection of characters {@a, @a, @b, @b, @c, @c, @d, @d}, and you must count the number of <i>distinct</i> ordered sequences of length eight that can be made using these characters in which each of the characters from the collection can be used exactly once.
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
You must count the number of different ways that ten people can split into two groups consisting of four people and six people. <b>Hint:</b> once the group of four people has been chosen, this automatically means the remaining six people are also in a group.
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Given a set of size 15, how many distinct subsets of size five does it have?
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Suppose there are seven people and five pets. In how many different ways can we choose three people and two pets to invite to an event (the people and pets are chosen independently).
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
How many different groups of size two, three, four, or five can we choose from a group of seven people?
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Suppose there are nine people and four pets. In how many different ways can we choose a group of three, four, or five people and a group of two, three, or four pets to invite to an event? The number of people we invite and the number of pets we invite are independent.
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
For each of the following descriptions, use Python to define a generating function and then specify using the index notation <code>[...]</code> which coefficient of the generating function corresponds to the correct count. In your Python file, you should include the <a href="#B.8">class definition for generating function found in the appendix</a>. For your solutions, define the variables <code>twoA</code>, <code>twoB</code>, <code>twoC</code>, and so on. For example, a solution to part (h) might look as follows:
          ]]></text>
          <code hooks="Python"><![CDATA[
twoH = ((x**2 + x**3 + x**4)**2)[3]  # Third coefficient is the solution.
          ]]></code>
          <text hooks="math"><![CDATA[
In the above manner, solve the following problem parts.
          ]]></text>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
In how many ways can you choose a combination of four items from a set of six items? <b>Hint:</b> use the <a href="#5d492542e8814412aa4d6599b08a7c04">binomial theorem</a>.
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Suppose you have four six-sided dice, where each dice is labelled with the numbers 0, 2, 4, 6, 8, 10. In how many ways can you roll the four dice so that the total is 20?
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
You must build a fence of length 20. You are allowed to use any number of fence sections, and each fence section can be of length 2, 3, 5, or 7. You decide to buy a particular bundle of fence sections (e.g., four section of length 5, or ten sections of length 2). How many distinct bundles of fence sections could you buy that would allow you to build a fence of the desired length without having any extra fence sections left over <b style="color:green;">(it's fine to count different arrangements of the sections as different bundles, so that 3 + 3 + 7 + 7 and 7 + 7 + 3 + 3 count as two different bundles)</b>. <b>Hint:</b> split the problem into cases based on the number of sections you buy, and then use <code>sum(...)</code>.
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Suppose you have five 50-sided dice, where each dice is labelled with the numbers 0, 1, 2, ..., 49. In how many ways can you roll the five dice so that the total is 158? <b>Hint:</b> use the <code>sum(...)</code> function as in <a href="#d85e5c05e7e64beb81557e9bfea65d55">this example</a>, except with powers of <code>x</code> to build an appropriate generating function.
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Suppose you have <b style="color:green;">five</b> 100-sided dice, where each dice is labelled with the numbers 1, 2, 3, ..., 100. In how many ways can you roll the five dice so that the total is 406? <b>Hint:</b> be careful when applying a theorem; you will need to do a little additional work because the labels start from 1 and not 0.
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
If non-leaf nodes of a tree can have either one, two, or three branches, how many trees of height 3 have width 7? You must write out the generating function; you may not use an algorithm.
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
Implement a function <code>sequences(cs)</code> that takes a list of characters <code>cs</code> as its input and computes the number of distinct ordered sequences of length <code>len(cs)</code> that can be made using these characters. <b>Hint:</b> use <code>set()</code> and the <code>.count()</code> method.
          ]]></text>
          <code hooks="Python"><![CDATA[
>>> sequences(['a','a','a'])
1
>>> sequences(['a','b','c'])
6
>>> sequences(['a','b','b','c'])
12
>>> sequences(['a','a','a','b','b','c','c'])
210
          ]]></code>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
Implement a function <code>solutions(k, n)</code> that takes two integer inputs <code>k</code> and <code>n</code>. The function should compute the number of possible <b><i>positive</i></b> integer solutions to the following equation:
\begin{eqnarray}
 %y_1 + %y_2 + ... + %y_{%k} & = & %n
\end{eqnarray}
Each solution to the above would be some assignment of a positive integer to each of the %y_{%i} so that they add up to %n, and your function must return the total count of <i>all</i> such solutions. <b>Hint:</b> note that the integer must be positive and thus non-zero, so you'll need to think carefully about what generating functions to use; if you use appropriate theorems, your implementation should be very short (two or three lines).
          ]]></text>
          <code hooks="Python"><![CDATA[
>>> solutions(2, 10)
9
>>> solutions(3, 100)
4851
>>> solutions(5, 20)
3876
>>> solutions(6, 10)
126
          ]]></code>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
Implement a function <code>hgtToSizes(h)</code> that takes an integer input <code>h</code> that represents a tree height. The function should return the generating function that represents how many height-<code>h</code> trees there are of each possible <i>size</i> (i.e., total number of all nodes in the tree) if each non-leaf node in the tree can have either one, two, or three branches.
          ]]></text>
          <code hooks="Python"><![CDATA[
>>> hgtToSizes(2)
1*x**2 + 1*x**3 + 1*x**4
>>> hgtToSizes(3)
1*x**3 + 1*x**4 + 2*x**5 + 2*x**6 + 4*x**7 + 5*x**8 + 7*x**9 + 7*x**10 + 6*x**11 + 3*x**12 + 1*x**13
          ]]></code>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
<b>Extra credit:</b> Implement a function <code>hgtToWidthProb(b, h, w)</code> that take three integer inputs:
<ul>
  <li>
    <code>b</code> represents the maximum number of branches each non-leaf node in the tree might have (so each node can have <code>1</code>, <code>2</code>, ..., <code>b-1</code>, or <code>b</code> branches);
  </li>
  <li>
    <code>h</code> represents tree height;
  </li>
  <li>
    <code>w</code> represents a tree width.
  </li>
</ul>
The function should return the probability (represented using a Python <code>Fraction()</code> object) that a tree of height <code>h</code> has width <code>w</code>. <b>Hint:</b> build a generating function by using Python <code>Fraction(...)</code> objects as the coefficients.
          ]]></text>
        </problem>
      </problems>
    </assignment>
    <subsection title="More applications of counting and probability">
      <example required="true" hooks="math" id="6cada6f4925f4dcc8766c67f43ea0f76">
        <text><![CDATA[
Suppose we are modelling how bacterial cells multiply over time. To simplify the problem, assume that time is divided into discrete time steps, and at a given time step, each cell has a 50% chance of dividing into two cells, and a 50% chance of not dividing into two cells. After 5 time steps, what is the probability that there are at least 10 cells?
        ]]></text>
        <paragraph><![CDATA[
We approach the problem by observing that all we need to do is compute the probabilities of the possible widths of trees of height 5 when each node can have either one or two branches (each with probability 1/2). Thus, we would start with:
\begin{eqnarray}
  %g & := & %x
\end{eqnarray}
Next, we would "update" our generating function four times using the following rule:
\begin{eqnarray}
  %g & := & @( 1 @; 2 @) \cdot %g + @( 1 @; 2 @) \cdot %g^2
\end{eqnarray}
Finally, to find the probability that there are at least 10 cells, we would compute the sum of all coefficients of the generating function for the terms %x<sup>10</sup>, %x<sup>11</sup>, %x<sup>12</sup>, ..., %x<sup>16</sup> (the maximum width of any tree of height 5 must be 16).
        ]]></paragraph>
      </example>
      <example required="true" hooks="math" id="5d816a8c1cfe4db581c1a9f444f67627">
        <text><![CDATA[
It is your job to allocate memory for an artificial intelligence algorithm that will model a game. You are not told the details of the game, but you know the following: during each turn, a player rolls a fair six-sided die that has the labels 1, 2, ..., 6. The result of the dice roll determines how many distinct options the player has in making the next move (e.g., if the roll results in a 2, the player has two possible ways they can make a move during that turn).
        ]]></text>
        <paragraph><![CDATA[
The AI algorithm needs to represent and store in memory the entire collection of possible ways the game can progress. Thus, it will use a tree to represent this: each node is a possible turn, and each branch is one of the possible moves a player can make. The number of children that each node has will be determined by the roll of a fair dice.
        ]]></paragraph>
        <paragraph><![CDATA[
Suppose games always last exactly four turns. You decide to allocate enough memory to store exactly 20 nodes. What is the probability that this will be enough memory to store the entire tree of possible ways the game can progress?
















        ]]></paragraph>
      </example>
      <fact title="generalized binomial theorem" required="true" hooks="math" id="a915c2d68c334915ba28a33e588a8745"><![CDATA[
The following identity holds:
\begin{eqnarray}
(%a + %b)^{%n} & = & #( %n #; 0 #) \cdot %a<sup>%n</sup> \cdot %b^0 &nbsp;&nbsp;+&nbsp;&nbsp; #( %n #; 1 #) \cdot %a<sup>%n %- 1</sup> \cdot %b^1 &nbsp;&nbsp;+&nbsp;&nbsp; #( %n #; 2 #) \cdot %a<sup>%n %- 2</sup> \cdot %b^2 &nbsp;&nbsp;+&nbsp;&nbsp; ... &nbsp;&nbsp;+&nbsp;&nbsp; #( %n #; %n #) \cdot %a^0 \cdot %b^{%n} \\
              & = & \Sigma^{%n}<sub>%i = 0</sub> #( %n #; %i #) \cdot %a<sup>%n %- %i</sup> \cdot %b^{%i} \\
              & = & \Sigma^{%n}<sub>%i = 0</sub> #( %n #; %i #) \cdot %a^{%i} \cdot %b<sup>%n %- %i</sup>
\end{eqnarray}
      ]]></fact>
      <example required="true" hooks="math" id="c230ec722e7e4641ab44be832f9389ef">
        <text><![CDATA[
Suppose that a robot is standing in the center of a room. Every second, the robot moves one meter forward with probability 1/3, or it moves one meter backward with probability 2/3. What is the probability that after 10 seconds, the robot will end up in the center of the room?
        ]]></text>
        <paragraph><![CDATA[
We can model this situation using a generating function by representing the forward motion of the robot using a positive exponent, and the backward motion using a negative exponent. Thus, the behavior at any particular time step is:
\begin{eqnarray}
@( 2 @; 3 @) \cdot %x^{-1} +  @( 1 @; 3 @) \cdot %x^1
\end{eqnarray}
After 10 seconds, the probability that the robot moved some distance %d is given by the coefficient of the %x<sup>%d</sup> term in the following generating function:
\begin{eqnarray}
(@( 2 @; 3 @) \cdot %x^{-1} +  @( 1 @; 3 @) \cdot %x^1)<sup>10</sup>
\end{eqnarray}
In this particular problem, we are interested in the coefficient of %x^0. One way to simplify the above is to introduce a factor of %x into the generating function, so that there are no negative exponents:
\begin{eqnarray}
@( 1 @; %x<sup>10</sup> @) \cdot (@( 2 @; 3 @) \cdot %x^0 +  @( 1 @; 3 @) \cdot %x^2)<sup>10</sup>
\end{eqnarray}
We still want to find the coefficient of %x^0 of the above generating function. However, we see that this corresponds to the coefficient of %x<sup>10</sup> of the second term ((2/3)%x^0 + (1/3)%x^2)<sup>10</sup>. We can then use the <a href="#a915c2d68c334915ba28a33e588a8745">generalized binomial theorem</a> to compute this:
\begin{eqnarray}
(@( 2 @; 3 @) \cdot %x^0 +  @( 1 @; 3 @) \cdot %x^2)<sup>10</sup>
  %~ & = & %~ \Sigma<sup>10</sup><sub>%i = 0</sub> %~ #( 10 #; %i #) \cdot (@( 2 @; 3 @))<sup>10 %- %i</sup> \cdot (@( 1 @; 3 @))^{%i} \cdot (%x^2)^{%i}
\end{eqnarray}
The above shows us that the coefficient will correspond to the %i = 5 case, since 2 \cdot 5 = 10. Thus, our desired coefficient is:
\begin{eqnarray}
 #( 10 #; 5 #) \cdot (@( 2 @; 3 @))<sup>10 %- 5</sup> \cdot (@( 1 @; 3 @))^5 & = & #( 10 #; 5 #) \cdot (@( 2 @; 3 @))^5 \cdot (@( 1 @; 3 @))^5
\end{eqnarray}
Notice we can explain the above formula in a different way. Each of the 10 time steps is an indepent choice the robot must make between moving forward or backward. The only way the robot will end up at the center of the room is if the robot chooses to move forward during exactly 5 of those time steps (and moves backward during the other five). This explains the combination term in the above. Then, it is only necessary to compute the probability of choosing to move forward five times, and choosing to move backward five times. This explains the two fraction terms in the above.
        ]]></paragraph>
      </example>
      <example required="true" id="acaa9222d4094692844cc7216e31e838">
        <text hooks="math"><![CDATA[
Suppose that there is an equal likelihood that on a given weekday, a stock price will fall 3, 2, or 1 dollars in value, will stay the same, or will rise 1, 2, or 3 dollars in value. What is the probability that after five weekdays, the stock has risen in value or stayed the same?
        ]]></text>
        <paragraph hooks="math"><![CDATA[
We can model the behavior of the stock price on a given day using a generating function:
\begin{eqnarray}
@( 1 @; 7 @) (%x<sup>%-3</sup> + %x<sup>%-2</sup> + %x<sup>%-1</sup> + %x<sup>0</sup> + %x<sup>1</sup> + %x<sup>2</sup> + %x<sup>3</sup>)
\end{eqnarray}
Given these assumptions, the maximum that the stock price can rise over five days is 3 \cdot 5 = 15. Thus, we then need to compute the sum of the coefficients of %x^{%i} for %i \geq 0 for the following generating function:
\begin{eqnarray}
(@( 1 @; 7 @) (%x<sup>%-3</sup> + %x<sup>%-2</sup> + %x<sup>%-1</sup> + %x<sup>0</sup> + %x<sup>1</sup> + %x<sup>2</sup> + %x<sup>3</sup>))<sup>5</sup>
\end{eqnarray}
We can do so using Python:
        ]]></paragraph>
        <code hooks="Python"><![CDATA[
>>> g = (Fraction(1,7) * @sum(x**i @for i @in @range(-3,4)))**5
>>> @sum(g[i] @for i @in @range(0, 15))
Fraction(1304, 2401)
          ]]></code> 
        <text hooks="math"><![CDATA[
Thus, the overall probability that the stock price will be the same or higher after five days is 1304/2401.
        ]]></text>
      </example>
      <example required="true" id="6d2804bb37bb4f3b914b6f1f2c325a91">
        <text hooks="math"><![CDATA[
Suppose that passwords for a certain device must be sequences that consist of some number of @a and @b characters. Assuming that the password for the device is @a@a@b@a@b, answer each of the following questions.
        ]]></text>
        <unorderedlist>
          <item>
            <text hooks="math"><![CDATA[
Alice's password guessing algorithm is equally likely to choose any 5-character password that can be assembled from the five characters @a, @a, @a, @b, and @b. What is the probability that it will guess the password on its first try?
            ]]></text>
            <solution hooks="math"><![CDATA[
The total number of possible 5-character passwords is:
\begin{eqnarray}
@( 5! %~ @; 2! \cdot 3! @)
\end{eqnarray}
Notice this corresponds to a combination because we are "choosing" which of the five password character positions will be @a (or, equivalently, @b):
\begin{eqnarray}
#( 5 #; 3 #) & = & #( 5 #; 2 #) & = & @( %~ 5!  @; 2! \cdot 3! @).
\end{eqnarray}
Since Alice's algorithm is equally likely to choose any of these, the probability it will choose exactly the correct one is:
\begin{eqnarray}
(@( 5! %~ @; 2! \cdot 3! @))<sup>%-1</sup> & = & (@( 2! \cdot 3! @; %~ 5! @)) & = & @( 1 @; 10 @)
\end{eqnarray}
            ]]></solution>
          </item>
          <item>
            <text hooks="math"><![CDATA[
Bob's password guessing algorithm builds the password from left to right, one character at a time. At each step, the probability that it will choose @a is 2/5, and the probability that it will choose @b is 3/5. What is the probability that it will guess the correct 5-character password on its first try?
            ]]></text>
            <solution hooks="math"><![CDATA[
Each character in the 5-character password is an independent dimension consisting of two mutually exclusive choices (@a and @b). The probability that Bob's algorithm will choose the particular sequence is then the product of probabilities over these five independent dimensions:
\begin{eqnarray}
  @( 2 @; 5 @) \cdot @( 2 @; 5 @) \cdot @( 3 @; 5 @) \cdot @( 2 @; 5 @) \cdot @( 3 @; 5 @) & = & (@( 2 @; 5 @))^3 \cdot (@( 3 @; 5 @))^2 & = & @( 72 @; 3125 @) & \approx & @( 1 @; 50 @)
\end{eqnarray}
Notice that this intuitively makes sense: there are 2^5 = 32 possible 5-character passwords that can be built, and if Bob's algorithm was equally likely to choose @a or @b for each character position, the overall probably would be 1/32. However, since Bob's algorithm is biased in favor of choosing a @b while the actual password has more @a character instances than @b character instances, the probability that Bob's algorithm will guess the correct password is actually lower.
            ]]></solution>
          </item>
          <item>
            <text hooks="math"><![CDATA[
What is the probability that it will guess a 5-character password that is not necessarily correct, but has the correct number of @a and @b characters?
            ]]></text>
            <solution hooks="math"><![CDATA[
We know that the probability that Bob's algorithm will choose a password containing three @a characters and two @b characters is (2/5)^3 \cdot (3/5)^2. However, the number of ways in which this can happen is:
\begin{eqnarray}
#( 5 #; 3 #) & = & #( 5 #; 2 #) & = & @( %~ 5!  @; 2! \cdot 3! @).
\end{eqnarray}
Thus, the probability would be:
\begin{eqnarray}
#( 5 #; 3 #) \cdot (@( 2 @; 5 @))^3 \cdot (@( 3 @; 5 @))^2
\end{eqnarray}
Notice that this is exactly the coefficient of %x^2 in the generalized binomial theorem expansion of the following generating function:
\begin{eqnarray}
((@( 2 @; 5 @)) \cdot %x^0 + (@( 3 @; 5 @)) \cdot %x^1)^5
\end{eqnarray}
            ]]></solution>
          </item>
          <item>
            <text hooks="math"><![CDATA[
Suppose Alice runs her algorithm three times. What is the probability that <b>at least</b> one of the three guesses will be the correct password?
            ]]></text>
            <solution hooks="math"><![CDATA[
We want to measure the probability that at least one of the guesses generated by Alice's algorithm is correct. However, we also want to count any situation in which two or three of the guesses are correct. Thus, we want the probability of the following logical formula:
\begin{eqnarray}
  %[first guess is correct]% \vee %[second guess is correct]% \vee %[third guess is correct]%
\end{eqnarray}
The three situations that correspond to the three predicates above are not mutually exclusive (e.g., the first and third guesses might both be correct). Thus, we cannot simply add the probabilities. Fortunately, the three attempts are completely independent (for example, the probability of possible outcomes in the second attempt is the same whether or not we restrict ourselves to a particular outcome of the first attempt). Thus, we can instead use De Morgan's law and compute the probability of the following:
\begin{eqnarray}
  \neg(\neg(%[first guess is correct]%) \wedge \neg(%[second guess is correct]%) \wedge \neg(%[third guess is correct]%))
\end{eqnarray}
In other words, we instead multiply the complements of the probabilities to find the probability that <i>none</i> of the guesses are correct. Then take the complement of that to determine the probability that <i>at least one</i> guess works. We can can now compute:
\begin{eqnarray}
  1 %- ((1 %- @( 1 @; 10 @))^3) & = & 1 %- (@( 9 @; 10 @))^3 \\
                                & = & 1 %- @( 729 @; 1000 @) \\
                                & = & @( 271 @; 1000 @)
\end{eqnarray}
Thus, the probability of at least one of the guesses being correct is 271/1000.
            ]]></solution>
          </item>
          <item>
            <text hooks="math"><![CDATA[
Suppose Alice runs her algorithm three times. What is the probability that <b>exactly one</b> of the three guesses will be the correct password?
            ]]></text>
            <solution hooks="math"><![CDATA[
In this case, we are considering three mutually exclusive possibilities: the first guess is correct and they other two are not, the second guess is correct and the others are not, and the third guess is correct and the others are not. We can compute each of these probabilities separately and then add them:
\begin{eqnarray}
  (@( 1 @; 10 @) \cdot @( 9 @; 10 @) \cdot @( 9 @; 10 @)) + (@( 9 @; 10 @) \cdot @( 1 @; 10 @) \cdot @( 9 @; 10 @)) + (@( 9 @; 10 @) \cdot @( 9 @; 10 @) \cdot @( 1 @; 10 @)) & = & 3 \cdot (@( 81 @; 1000 @)) \\
         & = & @( 243 @; 1000 @)
\end{eqnarray}
            ]]></solution>
          </item>
          <item>
            <text hooks="math"><![CDATA[
Suppose Bob runs his algorithm three times. What is the probability that <b>all</b> three guesses will be the correct password?
            ]]></text>
            <solution hooks="math"><![CDATA[
If each guess is an independent dimension, we want the probability of a particular measurement along each dimension, so we multiply:
\begin{eqnarray}
  ((@( 2 @; 5 @))^3 \cdot (@( 3 @; 5 @))^2)^3 & = & (@( 8 @; 125 @) \cdot @( 9 @; 25 @))^3 \\
                                              & = & (@( %~ 72 @; 15625 @))^3 \\
                                              & = & @( %~ 373248 @; 3814697265625 @)
\end{eqnarray}
            ]]></solution>
          </item>
        </unorderedlist>
      </example>
    </subsection>
    <assignment title="Generating Functions, Probability, and Logical Formulas">
      <instructions>
        <text><![CDATA[
In this assignment you will solve problems involving logical formulas and the computation of probabilities using generating functions and other counting methods.
        ]]></text>
        <paragraph><![CDATA[
You may import the following library function in your module (and you will want to include at the top of your Python file the latest version of the <a href="#B.8">Python class for working with generating functions</a>):
        ]]></paragraph>
        <code hooks="Python">
@from math @import factorial
@from fractions @import Fraction
        </code>
        <text hooks="math"><![CDATA[
<b style="color:firebrick;">Your solution may not import any other modules or employ any external library functions.</b> The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
        ]]></text>
      </instructions>
      <problems>
        <problem>
          <text hooks="math"><![CDATA[
Suppose we are given the following data about which predicates apply to elements in the collection of objects %O = {<b>tomato</b>, <b>frog</b>, <b>robin</b>, <b>parrot</b>, <b>fox</b>, <b>tree</b>} (this particular collection of concepts and properties is adapted from examples in <a href="http://mitpress.mit.edu/books/semantic-cognition"><i>Semantic Cognition</i></a> by Rogers &amp; McClelland):
<table class="fig_table" style="font-size:15px;">
  <tr>
    <td><b style="color:gray;">object</b></td>
    <td><b style="color:gray;">predicates that apply (i.e., instantiations that are true)</td>
  </tr>
  <tr>
    <td><b>tomato</b></td>
    <td>%[<b>tomato</b> is red]%, %~ %[<b>tomato</b> cannot eat]%, %~ %[<b>tomato</b> cannot fly]%</td>
  </tr>
  <tr>
    <td><b>frog</b></td>
    <td>%[<b>frog</b> can eat]%, %~ %[<b>frog</b> is green]%, %~ %[<b>frog</b> cannot fly]%</td>
  </tr>
  <tr>
    <td><b>robin</b></td>
    <td>%[<b>robin</b> can eat]%, %~ %[<b>robin</b> can fly]%, %~ %[<b>robin</b> is red]%</td>
  </tr>
  <tr>
    <td><b>parrot</b></td>
    <td>%[<b>parrot</b> can eat]%, %~ %[<b>parrot</b> is green]%, %~ %[<b>parrot</b> can fly]%</td>
  </tr>
  <tr>
    <td><b>fox</b></td>
    <td>%[<b>fox</b> is red]%, %~ %[<b>fox</b> cannot fly]%, %~ %[<b>fox</b> can eat]%,</td>
  </tr>
  <tr>
    <td><b>tree</b></td>
    <td>%[<b>tree</b> cannot eat]%, %~ %[<b>tree</b> is green]%, %~ %[<b>tree</b> cannot fly]%</td>
  </tr>
</table>
Answer the following questions about the above information.
          ]]></text>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
Determine whether the following formula is true for all objects %x in %O. Indicate your answer by including in your Python file either <code>oneA = True</code> or, if it is not true, providing a counterexample such as <code>oneA = 'penguin'</code>:
\begin{eqnarray}
  \forall %x, %~ (%[@x is red]% \wedge %[@x can eat]%) \Rightarrow %[@x can fly]%
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Determine whether the following formula is true for all objects %x in %O. Indicate your answer by including in your Python file either <code>oneB = True</code> or, if it is not true, providing a counterexample such as <code>oneB = 'penguin'</code>:
\begin{eqnarray}
  \forall %x, %~ %[@x cannot fly]% \Rightarrow %[@x cannot eat]%
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Separate the predicates into separate dimensions of mutually exclusive properties. Use Python strings such as <code>'cannot fly'</code> to represent each predicate (avoid typos to make grading easier), and define <code>oneC = ...</code> to be a <b>list of sets</b> in which each set contains all the strings for a particular dimension. As an example, here is one way this could be done for the predicates %[... is hot]%, %[... is cold]%, %[... is wide]%, and %[... is narrow]%:
              ]]></text>
              <code hooks="Python"><![CDATA[
oneC = [{'is hot', 'is cold'}, {'is wide', 'is narrow'}]
              ]]></code>
            </part>
            <part>
              <text hooks="math"><![CDATA[
For each pair of dimensions in part (c) above, indicate whether <b>for the given data</b> the pair of dimensions is <a href="#d6bb7bb2c0574f828f9caf17b6666d62">independent</a> (for purposes of probability computation). Indicate your answer by putting every pair of independent dimensions together into a set. For example, if <code>{'is hot', 'is cold'}</code> and <code>{'is wide', 'is narrow'}</code> are independent, and <code>{'is sweet', 'is sour'}</code> and <code>{'is wide', 'is narrow'}</code> are independent, but no other pair of dimensions is independent, then you would write:
              ]]></text>
              <code hooks="Python"><![CDATA[
oneD = [\
  { {'is hot', 'is cold'}, {'is wide', 'is narrow'} },\
  { {'is sweet', 'is sour'}, {'is wide', 'is narrow'} }\
  ]
              ]]></code>
            </part>
            <part>
              <text hooks="math"><![CDATA[
If an object %x is selected uniformly at random from %O (any object has the same probability of being selected as any other), what is the probability that %[@x can fly]% is true? Indicate your answer by including in your Python file using the line <code>oneE = Fraction(..., ...)</code> (filling in the <code>...</code> appropriately).
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Use Python <code>Fraction()</code> objects to write out the computation <code>oneF = ...</code> for the probability that the following formula is true (for an object %x selected uniformly at random from %O):
\begin{eqnarray}
  \Pr<sub>%x \in %O</sub>[ %[@x cannot fly]% \wedge %[@x is red]% ]
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Use Python <code>Fraction()</code> objects to write out the computation <code>oneG = ...</code> for the probability that the following formula is true (for an object %x selected uniformly at random from %O):
\begin{eqnarray}
  \Pr<sub>%x \in %O</sub>[ %[@x is green]% \vee %[@x cannot eat]% ]
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Use Python <code>Fraction()</code> objects to write out the computation <code>oneH = ...</code> for the probability that the following formula is true (for an object %x selected uniformly at random from %O):
\begin{eqnarray}
  \Pr<sub>%x \in %O</sub>[ %[@x is green]% \Rightarrow %[@x cannot fly]% ]
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Use Python <code>Fraction()</code> objects to write out the computation <code>oneI = ...</code> for the probability that a new predicate %[... is slithy]% applies to an object %x chosen from %O given the following information (assuming "slithiness" is independent from all the other dimensions):
\begin{eqnarray}
  \Pr<sub>%x \in %O</sub>[ %[@x is slithy]% \wedge %[@x cannot fly]% ] & = & @( 1 @; 3 @)
\end{eqnarray}
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
Suppose you are modelling a drunken walk along a bridge that is 4 steps wide. The drunk person starts from one end of the bridge (at the center of the bridge's walkway) and at each time step, they will step forward. They will also weave either one step to the right, one step to the left, or will only move forward without moving left or right (each possibility has an equal probability of occurring). They will fall of the bridge if they move 3 or more steps to the left, or 3 or more steps to the right.
          ]]></text>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
What is the minimum number of steps until there is a non-zero probability of falling off the bridge? Indicate your answer using a line of the form <code>twoA = ...</code>.
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Assuming your answer to part (a) is the integer <code>twoA</code>, define the probability <code>twoB = ...</code> (using addition and/or multiplication of Python <code>Fraction()</code> objects) of falling off the bridge after either <code>twoA</code> <b>or</b> after <code>twoA</code> + <code>1</code> time steps. <b>Hint:</b> you cannot fall off the bridge again after you have already fallen off the bridge; compute your probability accordingly.
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
What is the probability <code>twoC = ...</code> that after five steps have been taken, no fall has occurred?
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
Suppose we have the following model for the way a tree grows: it begins growing from a single root node (which exists at time step <code>t</code> = <code>1</code>), and at each time step <code>t</code> (starting with time step <code>t</code> = <code>2</code>), every node that appeared at time step <code>t</code> %- <code>1</code> behaves as follows:
<ul>
  <li>with probability 1/3, the node does not grow any branches (and never again grows any branches);</li>
  <li>with probability 1/3, the node grows one branch;</li>
  <li>with probability 1/3, the node grows two branches.</li>
</ul>
Implement a Python function <code>probHgtAtTime(h, t)</code> that uses generating functions to compute the probability that the tree has height <code>h</code> at time step <code>t</code>.
          ]]></text>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
You are modelling how two different types of bacteria reproduce. At each time step, each cell of type A that exists will behave as follows:
<ul>
  <li>with probability 2/3, the cell will split into two cells;</li>
  <li>with probability 1/3, the cell will not split.</li>
</ul>
Each cell of type B that exists at a given time step will behave as follows:
<ul>
  <li>with probability 1/3, the cell will split into three cells;</li>
  <li>with probability 2/3, the cell will not split.</li>
</ul>
Implement a Python function <code>moreB(t)</code> that uses generating functions to compute the probability that at time step <code>t</code>, there will be strictly more cells of type B than cells of type A. <b>Hint:</b> for each possible number of cells of type A, and for each possible number of cells of type B, we can compute the probability of that particular pair of quantities occuring at the same time; each of these possibilities is mutually exclusive.
          ]]></text>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
Suppose you are advising a company about the amount of funds they should have available to repay potential debt at a future point in time (e.g., to be kept in a separate account from which they can only withdraw at the time they need to pay the debt). The goal is to ensure that the probability the company will go bankrupt at that point in time is below 10%.
          ]]></text>
          <text hooks="math"><![CDATA[
Assume that the mathematical model of the company's performance each month is as follows: given some positive integer <code>c</code>, each month the company will either earn <code>c</code> in funds with probability <code>p</code>, or it will lose an amount <code>c</code> in funds with probability <code>1</code> %- <code>p</code>.
          ]]></text>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
Implement a Python function <code>probInRange(c, p, t, a, b)</code> that computes the probability that the company's net loss or gain after <code>t</code> months will be between <code>a</code> and <code>b</code> (inclusive). You may assume the following (you do not need to check these conditions in your code):
<ul>
  <li><code>c</code> > <code>0</code>;</li>
  <li><code>0</code> < <code>p</code> < <code>1</code>;</li>
  <li><code>t</code> > <code>0</code>;</li>
  <li><code>a</code> \leq <code>b</code>.</li>
</ul>
Your code should work for large values of <code>c</code> and <code>t</code>, and you may assume that <code>p</code> is a Python <code>Fraction()</code> object. <b>Hint:</b> do not build a generating function; instead, use a theorem to determine how to compute the desired coefficient.
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
At time <code>t</code>, the company's performance will be assessed; if its cumulative losses (i.e., negative earnings) at that time are greater than the amount of funding the company allocated to repay its debt, the company will go bankrupt. Implement a Python function <code>minAlloc(c, p, t)</code> that computes the minimum amount of funds the company should allocate (as an integer) so that the probability that the company will go bankrupt is below 10%.
              ]]></text>
            </part>
          </parts>
        </problem>
      </problems>
    </assignment>
  </section>
  <review title="Logic, Counting, and Probability">
    <!--<text><![CDATA[
This section contains a comprehensive collection of review problems going over the course material covered until this point. Many of these problems are an accurate representation of the kinds of problems you may see on an exam.
    ]]></text>-->
    <paragraph hooks="math"><![CDATA[
The following is a breakdown of what you should be able to do at this point in the course (and of what you may be tested on in an exam). Notice that many of the tasks below can be composed. This also means that some problems can be solved in more than one way.
<ul>
  <li>boolean formulas, their meanings, and truth tables
    <ul>
      <li>determine whether a formula is a well-formed formula</li>
      <li>determine the meaning of a formula without variables</li>
      <li>solve for an assignment of values to variables that makes a formula true</li>
      <li>build a truth table for a formula with variables</li>
      <li>for a given model (assignment of variables to values), find the meaning of a formula</li>
    </ul>
  </li>
  <li>boolean algebra 
    <ul>
      <li>common algebraic laws, and applying algebraic laws
        <ul>
          <li>commutativity, associativity, and identity of \vee and \wedge</li>
          <li>distributivity of \wedge and invertibility of&nbsp;&nbsp;\neg</li>
          <li>De Morgan's laws</li>
          <li>representing \oplus, \Rightarrow, and \Leftrightarrow using \vee, \wedge, and&nbsp;&nbsp;\neg</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>models, model sets, satisfaction of formulas, and common problems involving formulas
    <ul>
      <li>determine whether a given model satisfies a given formula</li>
      <li>given a formula, find the set of all models that satisfy a formula</li>
      <li>given a formula, solve the boolean satisfiability problem</li>
      <li>given a formula, solve the maximum boolean satisfiability problem</li>
      <li>given a formula, solve the counting boolean satisfiability problem</li>
      <li>counting problems
        <ul>
          <li>determine the number of rows in a truth table for a formula, or a given number of variables</li>
          <li>determine the number of possible truth tables for a given number of variables</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>using formulas to represent properties of "real-world" systems and entities
    <ul>
      <li>representing states of a system using boolean variables</li>
      <li>representing constraints and relationships between system states using formulas</li>
      <li>answering questions about systems and entities being modeled
        <ul>
          <li>finding a system state that satisfies a formula</li>
          <li>finding a system state with the maximum number of variables assigned to \top</li>
          <li>counting the number of system states that satisfy a formula</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>set theory, algebra of sets, and relationships to boolean algebra
    <ul>
      <li>perform computations involving set union, intersection, difference, and complement</li>
      <li>find the size of a set</li>
      <li>find the power set (or the size of a power set) of a set</li>
      <li>apply algebraic laws of set operations</li>
      <li>convert logical operations on formulas into corresponding set operations on model sets (and vice versa)</li>
    </ul>
  </li>
  <li>theorems, proofs, predicates, universal quantification, and induction
    <ul>
      <li>given a domain of discourse and collection of predicates, count the number of predicate instantiations possible</li>
      <li>determine whether a well-formed formula is a theorem</li>
      <li>determine whether an inference rule holds (i.e., \bot rows can become \top, but \top rows must stay \top)</li>
      <li>identify or apply common inference rules and logical (algebraic) laws
        <ul>
          <li>modus ponens</li>
          <li>\forall-instantiation</li>
          <li>induction</li>
        </ul>
      </li>
      <li>assemble a proof given axioms and a goal (using the representation involving a vertical list of subformulas)</li>
      <li>determine whether a proof is valid</li>
    </ul>
  </li>
  <li>inductively defining trees and measurements (height, width, size) on trees
    <ul>
      <li>defining recurrence relations for...
        <ul>
          <li>tree width</li>
          <li>tree size</li>
          <li>tree height</li>
        </ul>
      </li>
      <li>converting between different ways of representing measurements:
        <ul>
          <li>recurrence relations</li>
          <li>closed-form functions</li>
          <li>summations</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>counting and probability
    <ul>
      <li>permutations and combinations</li>
      <li>treating counts (possible/total) as probabilities</li>
      <li>combining counts and probabilities
        <ul>
          <li>multiplying counts or probabilities for independent simultaneous choices</li>
          <li>adding counts or probabilities for mutually exclusive choices</li>
        </ul>
      </li>
      <li>using generating functions for breaking up counts and probabilities by measurement dimensions
        <ul>
          <li>defining generating functions that represent various scenarios
            <ul>
              <li>counting trees by width, size, and height</li>
              <li>throwing dice, adding coins, and so on</li>
              <li>random walks and sequences of independent events</li>
            </ul>
          </li>
          <li>binomial theorem</li>
          <li>negative binomial theorem</li>
          <li>generalized binomial theorem</li>
        </ul>
      </li>
      <li>reasoning about data represented as a set of predicates defined over a domain of discourse
        <ul>
          <li>identifying independent dimensions</li>
          <li>computing the probability of a logical formula being true
            <ul>
              <li>logical \vee applied to two mutually exclusive measurements</li>
              <li>logical \vee applied to two independent properties</li>
              <li>logical \wedge applied to two independent properties</li>
              <li>logical \neg applied to any property</li>
            </ul>
          </li>          
        </ul>
      </li>
    </ul>
  </li>
</ul>
    ]]></paragraph>
  </review>
  <appendix title="Python">
    <text><![CDATA[
The Python programming language will be among the languages we use in this course. This language supports the object-oriented, imperative, and functional programming paradigms, has automatic memory managememt, and natively supports common high-level data structures such as lists and sets. Python is often used as an interpreted language, but it can also be compiled.
    ]]></text>
    <subsection title="Obtaining Python">
      <text><![CDATA[
The latest version of Python 3 can be downloaded at: <b><a href="http://www.python.org/getit/">http://www.python.org/getit/</a></b>. In this course, we will require the use if <b>Python 3</b>, which has been installed on all the <a href="http://www.bu.edu/cs/resources/laboratories/undergraduate-lab/">CS Department's undergraduate computing lab</a> machines, as well as on <code>csa2/csa3</code>.
      ]]></text>
    </subsection>
    <subsection title="Assembling a Python module">
      <text><![CDATA[
The simplest Python program is a single file (called a <i>module</i>) with the file extension <code>.py</code>. For example, suppose the following is contained within a file called <code>example.py</code>:
      ]]></text>
      <code hooks="Python">
# This is a comment in "example.py".
# Below is a Python statement.
@print("Hello, world.")
      </code>
      <text><![CDATA[
Assuming Python is installed on your system, to run the above program from the command line you can use the following (you may need to use <code>python3</code>, <code>python3.2</code>, <code>python3.3</code>, etc. depending on the Python installation you're using). Note that in the examples below <code>%&gt;</code> represents a terminal prompt, which may look different on your system.
      ]]></text>
      <code hooks="Python">
%> python example.py
Hello, world.
      </code>
      <text><![CDATA[
If you run Python without an argument on the command line, you will enter Python's interactive prompt. You can then evaluate expressions and execute individual statements using this prompt; you can also load and execute a Python module file:
      ]]></text>
      <code hooks="Python">
%> python
Python 3.2 ...
Type "help", "copyright", "credits" or "license" for more information.
>>> @exec(@open("example.py").read()) # Load "example.py" module.
Hello, world.
>>> x = "Hello." # Execute an assignment statement.
>>> @print(x)     # Execute a "print" statement.
Hello.
>>> x            # Evaluate a string expression.
'Hello.'
>>> 1 + 2        # Evaluate a numerical expression.
3
      </code>
    </subsection>
    <subsection title="Common data structures (i.e., Python expressions)">
      <text><![CDATA[
Python provides native support for several data structures that we will use throughout this course: integers, strings, lists, tuples, sets, and dictionaries (also known as finite maps). In this subsection, we present how instances of these data structures are represented in Python, as well as the most common operations and functions that can be applied to these data structure instances.
      ]]></text>
      <unorderedlist>
        <item>
          <text><![CDATA[<b>Booleans</b> consist of two constants: <code>True</code> and <code>False</code>.]]></text>
          <unorderedlist>
            <item><![CDATA[The usual logical operations are available using the operators <code>and</code>, <code>or</code>, and <code>not</code>.]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> @True                                      # A boolean constant.
@True
>>> @False                                     # A boolean constant.
@False
>>> @True @and @False @or @True @and (@not @False)    # A boolean expression.
@True
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Integers</b> are written as in most other programming languages (i.e., as a sequence of digits).]]></text>
          <unorderedlist>
            <item><![CDATA[The usual arithmetic operations are available using the operators <code>+</code>, <code>*</code>, <code>-</code>, and <code>/</code>. The infix operator <code>//</code> represents integer division, and the infix operators <code>**</code> represents exponentiation. Negative integers are prefixed with the negation operator <code>-</code>.]]></item>
            <item><![CDATA[The usual relational operators <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> are available.]]></item>
            <item><![CDATA[The <code>int()</code> function can convert a string that looks like an integer into an integer.]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> 123                                       # An integer constant.
@True
>>> 1 * (2 + 3) // 4 - 5                      # An integer expression.
-4
>>> 4 * 5 >= 19                               # A boolean expression involving integers.
@True
>>> @int("123")                                # A string being converted into an integer
123
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Strings</b> are delimited by either <code>'</code> or <code>"</code> characters. Strings can be treated as lists of single-character strings. Another way to look at this is that there is no distinction between a character and a string: all characters are just strings of length 1. Multiline strings can be delimited using <code>"""</code> or <code>'''</code> (i.e., three quotation mark characters at the beginning and end of the string literal).]]></text>
          <unorderedlist>
            <item><![CDATA[The empty string is denoted using <code>''</code> or <code>""</code>.]]></item>
            <item><![CDATA[Two strings can be concatenated using <code>+</code>.]]></item>
            <item><![CDATA[The function <code>len()</code> returns the length of a string.]]></item>
            <item><![CDATA[Individual characters in a string can be accessed using the bracketed index notation (e.g., <code>s[i]</code>). These characters are also strings themselves.]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> 'Example.'                                # A string.
'Example.'
>>> "Example."                                # Alternate notation for a string.
'Example.'
>>> @len("ABCD")                               # String length.
4
>>> "ABCD" + "EFG"                            # String concatenation.
'ABCDEFG'
>>> "ABCD"[2]                                 # Third character in the string.
'C'
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Lists</b> are similar to arrays: they are ordered sequences of objects and/or values. The entries of a list can be of a mixture of different types, and lists containing one or more objects are delimited using <code>[</code> and <code>]</code>, with the individual list entries separated by commas. Lists cannot be members of sets.]]></text>
          <unorderedlist>
            <item><![CDATA[The empty list is denoted using <code>[]</code>.]]></item>
            <item><![CDATA[Two lists can be concatenated using <code>+</code>.]]></item>
            <item><![CDATA[The function <code>len()</code> returns the length of a list.]]></item>
            <item><![CDATA[Individual entries in a list can be accessed using the bracketed index notation (e.g., <code>a[i]</code>).]]></item>
            <item><![CDATA[To check if a value is in a list, use the <code>in</code> relational operator.]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> [1,2,"A","B"]                             # A list.
[1, 2, 'A', 'B']
>>> [1, 2] + ['A','B']                        # Concatenating lists.
[1, 2, 'A', 'B']
>>> @len([1,2,"A","B"] )                       # List length.
4
>>> [1,2,"A","B"][0]                          # First entry in the list.
1
>>> 1 @in [1, 2]                               # List containment check.
@True
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Tuples</b> are similar to lists (they are ordered, and can contain objects of different types), except they are delimited by parentheses <code>(</code> and <code>)</code>, with entries separated by commas. The main distinction between lists and tuples is that tuples are hashable (i.e., they can be members of sets).]]></text>
          <unorderedlist>
            <item><![CDATA[The empty tuple is denoted using <code>()</code>.]]></item>
            <item><![CDATA[A tuple containing a single object <code>x</code> is denoted using <code>(x, )</code>.]]></item>
            <item><![CDATA[Two tuples can be concatenated using <code>+</code>.]]></item>
            <item><![CDATA[A tuple can be turned into a list using the <code>list()</code> function.]]></item>
            <item><![CDATA[A list can be turned into a tuple using the <code>tuple()</code> function.]]></item>
            <item><![CDATA[The function <code>len()</code> returns the length of a tuple.]]></item>
            <item><![CDATA[Individual entries in a tuple can be accessed using the bracketed index notation (e.g., <code>t[i]</code>).]]></item>
            <item><![CDATA[To check if a value is in a tuple, use the <code>in</code> relational operator.]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> (1,2,"A","B")                             # A tuple.
(1, 2, 'A', 'B')
>>> (1,)                                      # Another tuple.
(1,)
>>> (1, 2) + ('A','B')                        # Concatenating tuples.
(1, 2, 'A', 'B')
>>> @list((1, 2, 'A','B'))                     # A tuple being converted into a list.
[1, 2, 'A', 'B']
>>> @tuple([1, 2, 'A','B'])                    # A list being converted into a tuple.
(1, 2, 'A', 'B')
>>> @len((1,2,"A","B"))                        # Tuple length.
4
>>> (1,2,"A","B")[0]                          # First entry in the tuple.
1
>>> 1 @in (1, 2)                               # Tuple containment check.
@True
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Sets</b> are unordered sequences that cannot contain duplicates. They are a close approximation of mathematical sets. Sets cannot be members of sets.]]></text>
          <unorderedlist>
            <item><![CDATA[The empty set is denoted using <code>set()</code>.]]></item>
            <item><![CDATA[The methods <code>.union()</code> and <code>.intersect</code> correspond to the standard set operations.]]></item>
            <item><![CDATA[A list or tuple can be turned into a set using the <code>set()</code> function.]]></item>
            <item><![CDATA[A set can be turned into a list or tuple using the <code>list()</code> or <code>list()</code> function, respectively.]]></item>
            <item><![CDATA[The function <code>len()</code> returns the size of a set.]]></item>
            <item><![CDATA[To access individual entries in a set, it is necessary to turn the set into a list or tuple.]]></item>
            <item><![CDATA[To check if a value is in a set, use the <code>in</code> relational operator.]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> {1,2,"A","B"}                             # A set.
{1, 2, 'A', 'B'}
>>> ({1,2}.union({3,4})).intersection({4,5})  # Set operations.
{4}
>>> @set([1, 2]).union(@set(('A','B')))         # Converting a list and a tuple to sets.
{'A', 1, 2, 'B'}
>>> @len({1,2,"A","B"})                        # Set size.
4
>>> 1 @in {1,2,"A","B"}                        # Tuple containment check.
@True
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Frozen sets</b> are like sets, except they can be members of other sets. A set can be turned into a frozen set using the <code>frozenset()</code> function.]]></text>
          <code hooks="Python">
>>> @frozenset({1,2,3})                        # A frozen set.
@frozenset({1, 2, 3})
>>> {@frozenset({1,2}), @frozenset({3,4})}      # Set of frozen sets.
{@frozenset({3, 4}), @frozenset({1, 2})}
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Dictionaries</b> are unordered collections of associations between some set of keys and some set of values. Dictionaries are also known as finite maps.]]></text>
          <unorderedlist>
            <item><![CDATA[The empty dictionary is denoted using <code>{}</code>.]]></item>
            <item><![CDATA[The list of keys that the dictionary associates with values can be obtained using <code>list(d.keys())</code>.]]></item>
            <item><![CDATA[The list of values that the dictionary contains can be obtained using <code>list(d.values())</code>.]]></item>
            <item><![CDATA[The function <code>len()</code> returns the number of entries in the dictionary.]]></item>
            <item><![CDATA[Individual entries in a dictionary can be accessed using the bracketed index notation (e.g., <code>d[key]</code>).]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> {"A":1, "B":2}                            # A dictionary.
{'A': 1, 'B': 2}
>>> @list({"A":1, "B":2}.keys())               # Dictionary keys.
['A', 'B']
>>> @list({"A":1, "B":2}.values())             # Dictionary values.
[1, 2]
>>> @len({"A":1, "B":2})                       # Dictionary size.
2
>>> {"A":1, "B":2}["A"]                       # Obtain a dictionary value using a key.
1
          </code>
        </item>
      </unorderedlist>
    </subsection>
    <subsection title="Function, procedure, and method invocations">
      <text><![CDATA[
Python provides a variety of ways to supply parameter arguments when invoking functions, procedures, and methods.
      ]]></text>
      <unorderedlist>
        <item>
          <text><![CDATA[
 <b>Function calls and method/procedure invocations</b> consist of the function, procedure, or method name followed by a parenthesized, comma-delimited list of arguments. For example, suppose a function or procedure <code>example()</code> is defined as follows:
          ]]></text>
          <code hooks="Python">
@def example(x, y, z):
  @print("Invoked.")
  @return x + y + z
          </code>
          <text><![CDATA[
    To invoke the above definition, we can use one of the following techniques.
          ]]></text>
          <unorderedlist>
            <item>
              <text><![CDATA[
<b>Passing arguments directly</b> involves listing the comma-delimited arguments directly between parentheses.
              ]]></text>
              <code hooks="Python">
>>> example(1,2,3)
Invoked.
6
              </code>
            </item>
            <item>
              <text><![CDATA[
<b>The argument unpacking operator</b> (also known as the <code>*</code>-operator, the <b>scatter</b> operator, or the <b>splat</b> operator) involves providing a list to the function, preceded by the <code>*</code> symbol; the arguments will be drawn from the elements in the list.
              ]]></text>
              <code hooks="Python">
>>> args = [1,2,3]
>>> example(*args)
Invoked.
6
              </code>
            </item>
           <item>
              <text><![CDATA[
<b>The keyword argument unpacking operator</b> (also known as the <code>**</code>-operator) involves providing a dictionary to the function, preceded by the <code>**</code> symbol; each named paramter in the function definition will be looked up in the dictionary, and the value associated with that dictionary key will be used as the argument passed to that parameter.
              ]]></text>
              <code hooks="Python">
>>> args = {'z':3, 'x':1, 'y':2}
>>> example(**args)
Invoked.
6
              </code>
            </item>
          </unorderedlist>
        </item>
        <item>
          <text><![CDATA[
<b>Default parameter values</b> can be specified in any definition. Suppose the following definition is provided.
          ]]></text>
          <code hooks="Python">
@def example(x = 1, y = 2, z = 3):
  @return x + y + z
          </code>
          <text><![CDATA[
The behavior is then as follows: if an argument corresponding to a parameter is not supplied, the default value found in the definition is used. If an argument is supplied, the supplied argument value is used.
          ]]></text>
          <code hooks="Python">
>>> example(0, 0)
3
>>> example(0)
5
>>> example()
6
          </code>
        </item>
      </unorderedlist>
    </subsection>
    <subsection title="Comprehensions">
      <text><![CDATA[
Python provides concise notations for defining data structures and performing logical computations. In particular, it support a comprehension notation that can be used to build lists, tuples, sets, and dictionaries.
      ]]></text>
      <unorderedlist>
        <item>
          <text><![CDATA[<b>List comprehensions</b> make it possible to construct a list by iterating over one or more other data structure instances (such as a list, tuple, set, or dictionary) and performing some operation on each element or combination of elements. The resulting list will contain the result of evaluating the body for every combination.]]></text>
          <code hooks="Python">
>>> [ x @for x @in [1,2,3] ]
[1, 2, 3]
>>> [ 2 * x @for x @in {1,2,3} ]
[2, 4, 6]
>>> [ x + y @for x @in {1,2,3} @for y @in (1,2,3) ]
[2, 3, 4, 3, 4, 5, 4, 5, 6]
          </code>
          <text><![CDATA[It is also possible to add conditions anywhere after the first <code>for</code> clause. This will filter which combinations are actually used to add a value to the resulting list.]]></text>
          <code hooks="Python"><![CDATA[
>>> [ x @for x @in {1,2,3} @if x < 3 ]
[1, 2]
>>> [ x + y @for x @in {1,2,3} @for y @in (1,2,3) @if x > 2 @and y > 1 ]
[5, 6]
          ]]></code>
        </item>
        <item>
          <text><![CDATA[<b>Set comprehensions</b> make it possible to construct a set by iterating over one or more other data structure instances (such as a list, tuple, set, or dictionary) and performing some operation on each element or combination of elements. The resulting list will contain the result of evaluating the body for every combination. Notice that the result will contain no duplicates because the result is a set.]]></text>
          <code hooks="Python">
>>> { x @for x @in [1,2,3,1,2,3] }
{1, 2, 3}
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Dictionary comprehensions</b> make it possible to construct a dictionary by iterating over one or more other data structure instances (such as a list, tuple, set, or dictionary) and performing some operation on each element or combination of elements. The resulting dictionary will contain the result of evaluating the body for every combination.]]></text>
          <code hooks="Python">
>>> { key : 2 @for key @in ["A","B","C"] }
{'A': 2, 'C': 2, 'B': 2}
          </code>
        </item>
      </unorderedlist>
    </subsection>
    <subsection title="Other useful built-in functions">
      <text><![CDATA[
The built-in function <code>type()</code> can be used to determine the type of a value. Below, we provide examples of how to check whether a given expression has one of the common Python types:
      ]]></text>
      <code hooks="Python">
>>> @type(@True) == @bool
@True
>>> @type(123) == @int
@True
>>> @type("ABC") == @str
@True
>>> @type([1,2,3]) == @list
@True
>>> @type(("A",1,{1,2})) == @tuple
@True
>>> @type({1,2,3}) == @set
@True
>>> @type({"A":1, "B":2}) == @dict
@True
      </code>
    </subsection>
    <subsection title="Common Python definition and control constructs (i.e., Python statements)">
      <text><![CDATA[
A Python program is a sequence of Python statements. Each statement is either a function definition, a variable assignment, a conditional statement (i.e., <code>if</code>, <code>else</code>, and/or <code>elif</code>), an iteration construct (i.e., a <code>for</code> or <code>while</code> loop), a <code>return</code> statement, or a <code>break</code> or <code>continue</code> statement.
      ]]></text>
      <unorderedlist>
        <item>
          <text><![CDATA[<b>Variable assignments</b> make it possible to assign a value or object to a variable.]]></text>
          <code hooks="Python">
x = 10
          </code>
          <text><![CDATA[It is also possible to assign a tuple (or any computation that produces a tuple) to another tuple:]]></text>
          <code hooks="Python">
(x, y) = (1, 2)
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Function and procedure definitions</b> consist of the <code>def</code> keyword, followed by the name of the function or procedure, and then by one or more arguments (delimited by parentheses and separated by commas).]]></text>
          <code hooks="Python">
@def example(a, b, c):
    @return a + b + c
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Conditional statements</b> consist of one or more branches, each with its own boolean expression as the condition (with the exception of <code>else</code>). The body of each branch is an indented sequence of statements.]]></text>
          <code hooks="Python"><![CDATA[
@def fibonacci(n):
    # Computes the nth Fibonacci number.
    @if n <= 0:
        @return 0
    @elif n <= 2:
        @return 1
    @else:
        @return fibonacci(n-1) + fibonacci(n-2)
          ]]></code>
        </item>
        <item>
          <text><![CDATA[<b>Iteration constructs</b> make it possible to repeat a sequence of statements over and over. The body of an iteration construct is an indented sequence of statements.]]></text>
          <unorderedlist>
            <item>
              <text><![CDATA[The <b>while</b> construct has a boolean expression as its condition (much like <code>if</code>). The body is executed over and over until the expression in the condition evaluates to <code>False</code>, or a <code>break</code> statement is encountered.]]></text>
              <code hooks="Python"><![CDATA[
@def example1(n):
    # Takes an integer n and returns the sum of
    # the integers from 1 to n-1.
    i = 0
    sum = 0
    @while i < n:
        sum = sum + i
        i = i + 1
    @return sum

@def example2(n):
    # Takes an integer n and returns the sum of
    # the integers from 1 to n-1.
    i = 0
    sum = 0
    @while True:
        sum = sum + i
        i = i + 1
        @if i == n:
            @break
    @return sum
              ]]></code>
            </item>
            <item>
              <text><![CDATA[The <b>for</b> construct makes it possible to repeat a sequence of statements once for every object in a list, tuple, or set, or once for every key in a dictionary.]]></text>
              <code hooks="Python"><![CDATA[
@def example3(n):
    # Takes an integer n and returns the sum of
    # the integers from 1 to n-1.
    sum = 0
    @for i @in @range(0,n):
        sum = sum + i
    @return sum

@def example4(d):
    # Takes a dictionary d that maps keys to
    # integers and returns the sum of the integers.
    sum = 0
    @for key @in d:
        sum = sum + d[key]
    @return sum
              ]]></code>
            </item>
          </unorderedlist>
        </item>
      </unorderedlist>
    </subsection>
    <subsection title="Class for representing generating functions">
      <text><![CDATA[
The following is a small, stand-alone Python class for representing generating functions:
      ]]></text>
      <code hooks="Python"><![CDATA[
@class G():
    @def __init__(self, g = {1: 1}): self.g = g
    @def __getitem__(self, i): @return self.g.get(i,0)
    @def k(self): @return @list(self.g.keys())
    @def __repr__(self): @return self.__str__()
    @def __str__(g): @return " + ".join([@str(g[i])+"*x**"+@str(i) @for i @in g.g])
    @def __add__(x, y): @return G({i:x[i]+y[i] @for i @in x.k()+y.k()})
    @def __radd__(x, y):
        r = {i:x[i] @for i @in x.g}
        r[0] = r.get(0,0) + y
        @return G(r)
    @def __mul__(x, y):
        g = {}
        @for i @in x.g:
            @for j @in y.g: g[i+j] = g.get(i+j,0) + x[i]*y[j]
        @return G(g)
    @def __rmul__(x, y): @return G({i:y*x[i] for i in x.g})
    @def __pow__(x, y, r = 1):
        @if x.g == {1:1} @and y <= 0: @return G({y:1})
        @while y >= 1: (r,y) = (r*x, y-1)
        @return r

x = G()
      ]]></code>
      <text><![CDATA[
It is possible to use the above class in the following ways:
      ]]></text>
      <unorderedlist>
        <item>
          <text><![CDATA[<b>Building a generating function</b> is straightforward: you can use <code>x</code> and the operators <code>*</code>, <code>+</code>, and <code>**</code>:]]></text>
          <code hooks="Python">
>>> x
1*x**1
>>> (1 + x) ** 3
1*x**0 + 3*x**1 + 3*x**2 + 1*x**3
>>> (1 + x + x**2) * (x**4 + x**5)
1*x**4 + 2*x**5 + 2*x**6 + 1*x**7
          </code>
          <text><![CDATA[<b>Accessing coefficients</b> is possible using the bracket notation (as with dictionaries and lists):]]></text>
          <code hooks="Python">
>>> g = (1 + x) ** 3
>>> g
1*x**0 + 3*x**1 + 3*x**2 + 1*x**3
>>> g[0]
1
>>> g[1]
3
>>> g[2]
3
          </code>
        </item>
      </unorderedlist>  
    </subsection>
  </appendix>
</material>
